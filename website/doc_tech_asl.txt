ASL Manual

Overview of ASL
===============

What is ASL?
------------

The Abstract Syntax Layer (ASL) is a framework for specifying and building
protocol stacks.  The ASL framework is based on a protocol specification
grammar (asl), tools that validate and interpret this grammar, and a set of target 
code generators that produce outputs from protocol specifications written in
the ASL grammar.

The current set of targets are broadly aimed at multi-channel connected
protocols.  The AMQP protocol (for which ASL was developed) is a specific instance 
of such a protocol.  Targets cover functionality ranging from basic serialisation 
code to full frameworks for client APIs and server implementations.

ASL is designed to be easy to extend and modify; the range of code generation
targets and their functionality is not pre-defined.  The only fixed part of the whole
ASL framework is the ASL grammar itself.

Note that the ASL grammar is not fully compatible with the AMQP protocol,
which was forked and modified separately starting from June 2006.  The
public initial release of AMQP had no concept of grammar at all.

What is an ASL Specification?
-----------------------------

In gross terms, an ASL specification consists of a set of class and method
definitions, plus a target.  The classes and methods provide a structure for
the protocol.  The target specifies the name of a back-end code generator
that will turn the specifications into usable source code.

The ASL framework is roughly a front-end that parses, denormalises, and
checks the protocol specifications, plus a set of back-ends that turn these
specifications into usable source code.

This front-end/back-end architecture is based on the XNF model oriented
programming (MOP) concept.  ASL is built using MOP and anyone wanting to
modify or extend ASL should have prior MOP experience.

ASL Targets
-----------

At code generation time, the protocol developer specifies a "target". The
target defines entirely what kind of code generation the framework will
do.  ASL itself defines no fixed architecture on the produced code.

These targets have been developed:

1. A standard C stack (stdc), which produces a full client stack (also called
   an API), and a server structure into which the developer adds custom code.
2. Prototype stacks in perl, Java, and C#.  These generate only the client
   stacks.
3. A documentation target (doc) that produces extensive documentation for the
   protocol.
4. A PAL target (pal) that produces a scripting language for the protocol.
   PAL is documented separately.

Each target is named 'asl_xxx.gsl' where 'xxx' is the target name.  So, you
can see how the stdc target works by reading asl_stdc.gsl.

Naming Conventions
------------------

The only naming conventions imposed by ASL are the extensions for files.
File names themselves can be defined by the protocol developer.  Note
that complex protocols need large numbers of files, and the names used
can be quite important for clarity.

ASL Base Specifications
-----------------------

The ASL framework includes a set of "base specifications", which are an
optional foundation for multi-channel connected protocols.  The base
specifications (asl_base.asl) define:

* A set of constants, including error codes (asl_constants.asl).
* The connection class and methods (asl_connection.asl).
* The channel class and methods (asl_channel.asl).
* A number of standard domains such as reply-code.

The base specifications are not mandatory, but they are intended to make
the development of AMQP-like protocols faster and easier.  The base
specifications use these files:

 * asl_base.asl - base specifications.
 * asl_constants.asl - protocol constants.
 * asl_connection.asl - the 'connection' class.
 * asl_channel.asl - the 'channel' class.

The Chassis Concept
-------------------

ASL is used explicitly for asymmetric client-server protocols, and uses
the concept of 'chassis' to encapsulate these roles.  In a protocol
specification, functionality can be tied to either or both chassis,
telling the code generators, "output this code in the appropriate form
for the current chassis being generated".

For example, if a particular method is sent by the client to the server
but not vice-versa, sending code would be generated in the client stack,
and validating code in server stack.  The chassis information is not used
by all targets.

Specification Hierarchy
-----------------------

ASL uses the MOP inheritence technique very heavily.  That is, one ASL
file can inherit from other files.  ASL files can also include other
ASL files.  Inclusion copies specifications from one file into an
other, and makes it simpler to break large grammars into smaller pieces.
Inheritence lets the developer create variations on a protocol.

A typical protocol specification (like the demo protocol examined below)
uses both these techniques to create a hierachy of protocol specification
files.

We can look at some specific examples from the demo protocol:

 * The two chassis specifications inherit from the same base protocol
   specification called demo.asl.  This lets the chassis specifications
   share the same classes and methods, and layer ASL code on top of
   those.
 * Each class is defined as a seperate .asl file, and included into the
   base protocol specification.  This lets the author edit each class
   separately; simpler and more convenient than editing the whole protocol
   as a single file.

Worked Example - Demo protocol
------------------------------

The ASL project includes a complete worked example, 'demo', which uses
the base specifications.  The demo protocol implements a simple message
routing service, based on the concepts of 'exchange' and 'queue', as
developed in AMQP.

We provide a summary of the demo protocol specifications.  The demo
protocol uses the stdc target, which uses two chassis specifications,
one for the server and one for the client.

Helicopter overview
...................

The specifications themselves are composed of these ASL files:

 * demo_client_proto.asl - chassis specification for the client.
 * demo_server_proto.asl - chassis specification for the server.
 * demo.asl - demo protocol base specification.
 * demo_access.asl - 'access' class.
 * demo_basic.asl - 'basic' class.
 * demo_exchange.asl - 'exchange' class.
 * demo_queue.asl - 'queue' class.

The demo.asl file inherits from asl_base.asl, so incorporates the connection
and channel classes from that base specification.  The client and server
chassis inherit from demo.asl, so include all its classes, plus those from
asl_base.asl.

The two chassis specifications also inherit from these files, which in the
current implementation implement rules for the 'stdc' target:

 * asl_client.asl - base specification for a client chassis.
 * asl_server.asl - base specification for a server chassis.

To generate code, we issue these commands:

    gsl demo_client_proto.asl
    gsl demo_server_proto.asl

In the ASL project.pdl, these two files are defined using the "gsl data"
class, which issues the above commands automatically at build time.

Chassis specification for client
................................

The client chassis specification is the top-level specification for generating
the client stack.  This specification inherits from demo.asl and asl_client,
and then adds the information needed to generate the client stack properly:

    <?xml version="1.0"?>
    <protocol comment = "ASL demo client" script  = "asl_gen" chassis = "client">
    <inherit name = "demo" />
    <inherit name = "asl_client" />

The specification sets two options, the first specifies the name that is used
to identify clients on the wire, and the second tells the stdc target to
generate a "synchronous client", that is, one which can be used from normal
applications.  We explain the stdc back-end later.

    <option name = "product_name" value = "ASL Demo Client" />
    <option name = "syncapi" value = "1" />

The specification declares defaults for a method (this is to test the use
of defaults):

    <class name = "queue">
    <defaults method = "declare">
        <field name = "ticket"       default = "0" />
        <field name = "passive"      default = "0" />
        <field name = "durable"      default = "0" />
        <field name = "exclusive"    default = "0" />
    </defaults>
    </class>

The specification then provides code implementations for methods.  This
is how the protocol implementor adds specific code to the generated
client stack:

    <class name = "basic">
    <action name = "get-ok">
        demo_content_$(class.name)_set_routing_key (
            self->content, method->exchange, method->routing_key, 0);
        demo_content_$(class.name)_list_push_back (
            session->arrived_$(class.name)_list,
            self->content);
    </action>
    </class>
    </protocol>

Chassis specification for server
................................

The server chassis specification is the top-level specification for generating
the server framework.  This specification inherits from demo.asl and asl_server,
and then adds the information needed to generate the server framework properly:

    <?xml version="1.0"?>
    <protocol
        comment = "ASL demo server"
        script  = "asl_gen"
        chassis = "server"
        >
    <inherit name = "demo" />
    <inherit name = "asl_server" />
    <option name = "product_name" value = "ASL Demo Server" />

The specification provides code implementations for methods.  This
is how the protocol implementor connects the generated server framework
with custom-written classes that do the actual work.  This interface
is part of the stdc target and is explained in detail later:

    <class name = "channel">
        <action name = "flow">
            channel->active = method->active;
        </action>
    </class>
    ...
    </protocol>

Demo protocol base specification
................................

The demo protocol base specification defines the Demo protocol without any
chassis or target-specific data.  We use the protocol base specification
to generate documentation, for example.

The specification inherits from asl_base.asl, the ASL base specification.
It includes all the protocol classes (this is just a way of keeping the
text readable and editable).  Then, it defines a set of options that are
used in the generation of the client and server layers:

    <?xml version="1.0"?>
    <protocol
        name     = "demo"
        comment  = "ASL demo protocol"
        script   = "asl_gen"
        target   = "stdc"
        >
    <inherit name = "asl_base" />
    <include filename = "demo_access.asl" />
    <include filename = "demo_exchange.asl" />
    <include filename = "demo_queue.asl" />
    <include filename = "demo_basic.asl" />

    <option name = "protocol_name"     value = "DEMO" />
    <option name = "protocol_port"     value = "7654" />
    <option name = "protocol_class"    value = "1" />
    <option name = "protocol_instance" value = "1" />
    <option name = "protocol_major"    value = "1" />
    <option name = "protocol_minor"    value = "1" />

The file then defines a set of domains that are shared by all classes in
this protocol.  Domains can be defined in any of the class files as well;
it is just convenient to place these in the protocol base specification:

    <domain name = "access ticket" type = "short">
    ...
    </domain>
    ...
    </protocol>

Access class
............

The access.asl defines the access class, a set of methods that do access
control work.  The class file defines the name and index and continues
with a mix of documentation, chassis rules, and method specifications.
The specific grammar for a class is explained in detail later.

    <?xml version="1.0"?>
    <class name = "access" index = "30">
    <doc>
    ...
    </doc>
    <chassis name = "server" implement = "MUST" />
    <chassis name = "client" implement = "MUST" />
    <method name = "request" synchronous = "1" index = "10">
    ...
    </method>
    ...
    </class>


Exchange class
..............

Queue class
...........
ame = "ticket" domain = "access ticket">
        <doc>
        The access ticket must be for the access realm that holds the
        queue.
        </doc>
        <doc name = "rule">
        The client MUST provide a valid access ticket giving "read" access
        rights to the queue's access realm.  Note that purging a queue is
        equivalent to reading all messages and discarding them.
        </doc>
    </field>

    <field name = "queue" domain = "queue name">
        <doc name = "rule">
        The queue must exist. Attempting to purge a non-existing queue
        causes a channel exception.
        </doc>
        <assert check = "notnull" />
    </field>
    </method>


    <method name = "purge-ok" synchronous = "1" index = "31">
    confirms a queue purge
    <doc>
        This method confirms the purge of a queue.
    </doc>
    <chassis name = "client" implement = "MUST" />

    <field name = "message count" type = "long">
        number of messages purged
        <doc>
        Reports the number of messages purged.
        </doc>
    </field>
    </method>


    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <method name = "delete" synchronous = "1" index = "40">
    delete a queue
    <doc>
        This method deletes a queue.  When a queue is deleted any pending
        messages are sent to a dead-letter queue if this is defined in the
        server configuration, and all consumers on the queue are cancelwled.
    </doc>
    <doc name = "rule">
        The server SHOULD use a dead-letter queue to hold messages that
        were pending on a deleted queue, and MAY provide facilities for
        a system administrator to move these messages back to an active
        queue.
    </doc>
    <chassis name = "server" implement = "MUST" />
    <response name = "delete-ok" />

    <field name = "ticket" domain = "access ticket">
        <doc name = "rule">
        The client MUST provide a valid access ticket giving "active"
        access rights to the queue's access realm.
        </doc>
    </field>

    <field name = "queue" domain = "queue name">
        <doc name = "rule">
        The queue must exist. Attempting to delete a non-existing queue
        causes a channel exception.
        </doc>
        <assert check = "notnull" />
    </field>

    <field name = "if unused" type = "bit">
        delete only if unused
        <doc>
        If set, the server will only delete the queue if it has no
        consumers. If the queue has consumers the server does does not
        delete it but raises a channel exception instead.
        </doc>
    </field>

    <field name = "if empty" type = "bit">
        delete only if empty
        <doc>
        If set, the server will only delete the queue if it has no
        messages. If the queue is not empty the server raises a channel
        exception.
        </doc>
    </field>
    </method>


    <method name = "delete-ok" synchronous = "1" index = "41">
    confirm deletion of a queue
    <doc>
        This method confirms the deletion of a queue.
    </doc>
    <chassis name = "client" implement = "MUST" />

    <field name = "message count" type = "long">
        number of messages purged
        <doc>
        Reports the number of messages purged.
        </doc>
    </field>
    </method>

    </class>

Base specification for client chassis
.....................................

    <?xml version="1.0"?>
    <!--
        Copyright (c) 1996-2006 iMatix Corporation

        This program is free software; you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation; either version 2 of the License, or (at
        your option) any later version.

        This program is distributed in the hope that it will be useful, but
        WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        General Public License for more details.

        For information on alternative licensing for OEMs, please contact
        iMatix Corporation.
    -->
    <protocol
        comment = "ASL standard client actions"
        abstract = "1"
        >

    <class name = "connection">
    <context>
        icl_shortstr_t
            server_host;
        icl_shortstr_t
            server_name;
        icl_shortstr_t
            server_product;                 //  Reported by server
        icl_shortstr_t
            server_version;
        icl_shortstr_t
            server_platform;
        icl_shortstr_t
            server_copyright;
        icl_shortstr_t
            server_information;
        icl_shortstr_t
            server_instance;
    </context>

    <action name = "start">
        <local>
        asl_field_list_t
            *fields;                        //  Decoded responses
        </local>
        //
        fields = asl_field_list_new (method->server_properties);
        if (fields) {
            asl_field_list_cpy (fields, connection->server_host,            "host");
            asl_field_list_cpy (fields, connection->server_instance,        "instance");
            asl_field_list_cpy (fields, connection->server_product,         "product");
            asl_field_list_cpy (fields, connection->server_version,         "version");
            asl_field_list_cpy (fields, connection->server_platform,        "platform");
            asl_field_list_cpy (fields, connection->server_copyright,       "copyright");
            asl_field_list_cpy (fields, connection->server_information,     "information");
            asl_field_list_destroy (&fields);
        }
    </action>

    <action name = "close">
        if (!connection->silent)
            icl_console_print ("W: connection closed: %d - %s",
                connection->reply_code, connection->reply_text);
    </action>
    </class>

    <class name = "channel">
    <action name = "alert">
        if (!session->silent)
            icl_console_print ("W: alert from server: %d - %s",
                session->reply_code, session->reply_text);
    </action>
    <action name = "close">
        if (!session->silent)
            icl_console_print ("W: channel closed: %d - %s",
                session->reply_code, session->reply_text);
    </action>
    </class>

    </protocol>

Base specification for server chassis
.....................................

    <?xml version="1.0"?>
    <!--
        Copyright (c) 1996-2006 iMatix Corporation

        This program is free software; you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation; either version 2 of the License, or (at
        your option) any later version.

        This program is distributed in the hope that it will be useful, but
        WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        General Public License for more details.

        For information on alternative licensing for OEMs, please contact
        iMatix Corporation.
    -->
    <protocol
        comment = "ASL standard server actions"
        abstract = "1"
        >

    <class name = "connection">
    <action name = "start-ok">
        $(basename)_connection_start_ok (connection, method);
    </action>

    <action name = "tune-ok">
        $(basename)_connection_tune_ok (connection, method);
    </action>

    <action name = "open">
        $(basename)_connection_open (connection, method);
    </action>
    </class>

    </protocol>




ASL Framework Architecture
==========================

Split between ASL and OpenAMQ
-----------------------------

    (what goes where)


Generation relationships
-------------------------

    (e.g. if I pick a completely random file like say, asl_channel.icl, where does it fit in?)


States and transitions between them in ASL FSMs
-----------------------------------------------

ASL FSMs interface
------------------

    (asl_client_agent, syncapi=0 vs. syncapi=1)
    (asl_server_agent)

The stdc Target
===============

- options
<option name = "protocol_name"     value = "DEMO" />
<option name = "protocol_port"     value = "7654" />
<option name = "protocol_class"    value = "1" />
<option name = "protocol_instance" value = "1" />
<option name = "protocol_major"    value = "1" />
<option name = "protocol_minor"    value = "1" />



The doc Target
==============

The pal Target
==============



Reference
=========
