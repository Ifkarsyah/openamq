ASL Manual

Overview of ASL
===============

What is ASL?
------------

The Abstract Syntax Layer (ASL) is a framework for specifying and building
protocol stacks.  The ASL framework is based on a protocol specification
grammar (asl), tools that validate and interpret this grammar, and a set of target 
code generators that produce outputs from protocol specifications written in
the ASL grammar.

The current set of targets are broadly aimed at multi-channel connected
protocols.  The AMQP protocol (for which ASL was developed) is a specific instance 
of such a protocol.  Targets cover functionality ranging from basic serialisation 
code to full frameworks for client APIs and server implementations.

ASL is designed to be easy to extend and modify; the range of code generation
targets and their functionality is not pre-defined.  The only fixed part of the whole
ASL framework is the ASL grammar itself.

Note that the ASL grammar is not fully compatible with the AMQP protocol,
which was forked and modified separately starting from June 2006.  The
first public release of AMQP had no concept of grammar at all.

What is an ASL Specification?
-----------------------------

In gross terms, an ASL specification consists of a set of class and method
definitions, plus a target.  The classes and methods provide a structure for
the protocol.  The target specifies the name of a back-end code generator
that will turn the specifications into usable source code.

The ASL framework is roughly a front-end that parses, denormalises, and
checks the protocol specifications, plus a set of back-ends that turn these
specifications into usable source code.

This front-end/back-end architecture is based on the XNF model oriented
programming (MOP) concept.  ASL is built using MOP and anyone wanting to
modify or extend ASL should have prior MOP experience.

ASL Targets
-----------

At code generation time, the protocol developer specifies a "target". The
target defines entirely what kind of code generation the framework will
do.  ASL itself defines no fixed architecture on the produced code.

These targets have been developed:

1. A standard C stack (stdc), which produces a full client stack (also called
   an API), and a server stack into which the developer adds custom code.
2. Prototype stacks in perl, Java, and C#.  These generate only the client
   stacks.
3. A documentation target (doc) that produces extensive documentation for the
   protocol.
4. A PAL target (pal) that produces a scripting language for the protocol.
   PAL is documented separately.

Each target is named 'asl_xxx.gsl' where 'xxx' is the target name.  So, you
can see how the stdc target works by reading asl_stdc.gsl.

Naming Conventions
------------------

The only naming conventions imposed by ASL are the extensions for files.
File names themselves can be defined by the protocol developer.  Note
that complex protocols need large numbers of files, and the names used
can be quite important for clarity.

ASL Base Specifications
-----------------------

The ASL framework includes a set of "base specifications", which are an
optional foundation for multi-channel connected protocols.  The base
specifications (asl_base.asl) define:

* A set of constants, including error codes (asl_constants.asl).
* The connection class and methods (asl_connection.asl).
* The channel class and methods (asl_channel.asl).
* A number of standard domains such as reply-code.

The base specifications are not mandatory, but they are intended to make
the development of AMQP-like protocols faster and easier.  The base
specifications use these files:

 * asl_base.asl - base specifications.
 * asl_constants.asl - protocol constants.
 * asl_connection.asl - the 'connection' class.
 * asl_channel.asl - the 'channel' class.

The Chassis Concept
-------------------

ASL is used explicitly for asymmetric client-server protocols, and uses
the concept of 'chassis' to encapsulate these roles.  In a protocol
specification, functionality can be tied to either or both chassis,
telling the code generators, "output this code in the appropriate form
for the current chassis being generated".

For example, if a particular method is sent by the client to the server
but not vice-versa, sending code would be generated in the client stack,
and validating code in server stack.  The chassis information is not used
by all targets.

Specification Hierarchy
-----------------------

ASL uses the MOP inheritence technique very heavily.  That is, one ASL
file can inherit from other files.  ASL files can also include other
ASL files.  Inclusion copies specifications from one file into an
other, and makes it simpler to break large grammars into smaller pieces.
Inheritence lets the developer create variations on a protocol.

A typical protocol specification (like the demo protocol examined below)
uses both these techniques to create a hierachy of protocol specification
files.

We can look at some specific examples from the demo protocol:

 * The two chassis specifications inherit from the same base protocol
   specification called demo.asl.  This lets the chassis specifications
   share the same classes and methods, and layer ASL code on top of
   those.
 * Each class is defined as a seperate .asl file, and included into the
   base protocol specification.  This lets the author edit each class
   separately; simpler and more convenient than editing the whole protocol
   as a single file.

Worked Example - Demo protocol
==============================

The ASL project includes a complete worked example, 'demo', which uses
the base specifications.  The demo protocol implements a simple message
routing service, based on the concepts of 'exchange' and 'queue', as
developed in AMQP.

We provide a summary of the demo protocol specifications.  The demo
protocol uses the stdc target, which uses two chassis specifications,
one for the server and one for the client.

Helicopter overview
-------------------

The specifications themselves are composed of these ASL files:

 * demo_client_proto.asl - chassis specification for the client.
 * demo_server_proto.asl - chassis specification for the server.
 * demo.asl - demo protocol base specification.
 * demo_access.asl - 'access' class.
 * demo_basic.asl - 'basic' class.
 * demo_exchange.asl - 'exchange' class.
 * demo_queue.asl - 'queue' class.

The demo.asl file inherits from asl_base.asl, so incorporates the connection
and channel classes from that base specification.  The client and server
chassis inherit from demo.asl, so include all its classes, plus those from
asl_base.asl.

The two chassis specifications also inherit from these files, which in the
current implementation implement rules for the 'stdc' target:

 * asl_client.asl - base specification for a client chassis.
 * asl_server.asl - base specification for a server chassis.

To generate code, we issue these commands:

    gsl demo.asl
    gsl demo_client_proto.asl
    gsl demo_server_proto.asl

In the ASL project.pdl, these three files are defined using the "gsl data"
or "gsl public data" classes, which issue the above commands automatically at build time.
(The difference between the classes is that the public class also installs the file
into the $IBASE/bin directory for reuse by further applications.)

Chassis specification for client
--------------------------------

The client chassis specification (demo_client_proto.asl) is the top-level specification for generating
the client stack.  This specification inherits from demo.asl and asl_client,
and then adds the information needed to generate the client stack properly:

    <?xml version="1.0"?>
    <protocol comment = "ASL demo client" script  = "asl_gen" chassis = "client">
    <inherit name = "demo" />
    <inherit name = "asl_client" />

The specification sets two options, the first specifies the name that is used
to identify clients on the wire, and the second tells the stdc target to
generate a "synchronous client", that is, one which can be used from normal
applications.  We explain the stdc back-end later.

    <option name = "product_name" value = "ASL Demo Client" />
    <option name = "syncapi" value = "1" />

The specification declares defaults for a method (this is to test the use
of defaults):

    <class name = "queue">
    <defaults method = "declare">
        <field name = "ticket"       default = "0" />
        <field name = "passive"      default = "0" />
        <field name = "durable"      default = "0" />
        <field name = "exclusive"    default = "0" />
    </defaults>
    </class>

The specification then provides code implementations for methods.  This
is how the protocol implementor adds specific code to the generated
client stack:

    <class name = "basic">
    <action name = "get-ok">
        demo_content_$(class.name)_set_routing_key (
            self->content, method->exchange, method->routing_key, 0);
        demo_content_$(class.name)_list_push_back (
            session->arrived_$(class.name)_list,
            self->content);
    </action>
    </class>
    </protocol>

Chassis specification for server
--------------------------------

The server chassis specification (demo_server_proto.asl) is the top-level specification
for generating the stack.  This specification inherits from demo.asl and
asl_server, and then adds the information needed to generate the server stack properly:

    <?xml version="1.0"?>
    <protocol
        comment = "ASL demo server"
        script  = "asl_gen"
        chassis = "server"
        >
    <inherit name = "demo" />
    <inherit name = "asl_server" />
    <option name = "product_name" value = "ASL Demo Server" />

The specification provides code implementations for methods.  This
is how the protocol implementor connects the generated server stack
with custom-written classes that do the actual work.  This interface
is part of the stdc target and is explained in detail later:

    <class name = "channel">
        <action name = "flow">
            channel->active = method->active;
        </action>
    </class>
    ...
    </protocol>

Demo protocol base specification
--------------------------------

The demo protocol base specification (demo.asl) defines the Demo protocol
without any chassis or target-specific data.  We use the protocol base
specification to generate documentation, for example.

The specification inherits from asl_base.asl, the ASL base specification.
It includes all the protocol classes (this is just a way of keeping the
text readable and editable).  Then, it defines a set of options that are
used in the generation of the client and server layers:

    <?xml version="1.0"?>
    <protocol
        name     = "demo"
        comment  = "ASL demo protocol"
        script   = "asl_gen"
        target   = "stdc"
        >
    <inherit name = "asl_base" />
    <include filename = "demo_access.asl" />
    <include filename = "demo_exchange.asl" />
    <include filename = "demo_queue.asl" />
    <include filename = "demo_basic.asl" />

    <option name = "protocol_name"     value = "DEMO" />
    <option name = "protocol_port"     value = "7654" />
    <option name = "protocol_class"    value = "1" />
    <option name = "protocol_instance" value = "1" />
    <option name = "protocol_major"    value = "1" />
    <option name = "protocol_minor"    value = "1" />

The file then defines a set of domains that are shared by all classes in
this protocol.  Domains can be defined in any of the class files as well;
it is just convenient to place these in the protocol base specification:

    <domain name = "access ticket" type = "short">
    ...
    </domain>
    ...
    </protocol>

The access class
----------------

The demo_access.asl file defines the access class, a set of methods that do access
control work.  The class file defines the name and index and continues
with a mix of documentation, chassis rules, and method specifications.
The specific grammar for a class is explained in detail later.

    <?xml version="1.0"?>
    <class
        name    = "access"
        handler = "connection"
        index   = "30"
    >
    work with access tickets
    <doc>
    The protocol control access to server resources using access tickets.
    A client must explicitly request access tickets before doing work.
    An access ticket grants a client the right to use a specific set of
    resources - called a "realm" - in specific ways.
    </doc>

    <doc name = "grammar">
        access              = C:REQUEST S:REQUEST-OK
    </doc>

    <chassis name = "server" implement = "MUST" />
    <chassis name = "client" implement = "MUST" />

    <method name = "request" synchronous = "1" index = "10">
    request an access ticket
    ... (method body ommitted for brevity)
    </method>

    <method name = "request-ok" synchronous = "1" index = "11">
    grant access to server resources
    ... (method body ommitted for brevity)
    </method>

    </class>

The exchange class
------------------

The demo_exchange.asl file defines the exchange class, a set of methods to
work with server-side exchange entities.  In the demo protocol, exchanges
are simple routing entities that direct messages into message queues.

    <?xml version="1.0"?>
    <class
        name    = "exchange"
        handler = "channel"
        index   = "40"
    >
    work with exchanges
    <doc>
    Exchanges match and distribute messages across queues.  Exchanges can be
    configured in the server or created at runtime.
    </doc>

    <doc name = "grammar">
        exchange            = C:DECLARE S:DECLARE-OK
                            / C:DELETE  S:DELETE-OK
    </doc>

    <chassis name = "server" implement = "MUST" />
    <chassis name = "client" implement = "MUST" />

    <method name = "declare" synchronous = "1" index = "10">
    declare exchange, create if needed
    ... (method body ommitted for brevity)
    </method>

    <method name = "declare-ok" synchronous = "1" index = "11">
    confirms an exchange declaration
    ... (method body ommitted for brevity)
    </method>

    <method name = "delete" synchronous = "1" index = "20">
    delete an exchange
    ... (method body ommitted for brevity)
    </method>

    <method name = "delete-ok" synchronous = "1" index = "21">
    confirm deletion of an exchange
    ... (method body ommitted for brevity)
    </method>

    </class>

The queue class
---------------

The demo_queue.asl class defines the queue class, a set of methods to
work with server-side message queues.  In the demo protocol, message
queues hold messages until they can be consumed by applications.

    <?xml version="1.0"?>
    <class
        name    = "queue"
        handler = "channel"
        index   = "50"
    >
    work with queues
    <doc>
    Queues store and forward messages.  Queues can be configured in the server
    or created at runtime.  Queues must be attached to at least one exchange
    in order to receive messages from publishers.
    </doc>

    <doc name = "grammar">
        queue               = C:DECLARE  S:DECLARE-OK
                            / C:BIND     S:BIND-OK
                            / C:CANCEL   S:CANCEL-OK
                            / C:PURGE    S:PURGE-OK
                            / C:DELETE   S:DELETE-OK
    </doc>

    <chassis name = "server" implement = "MUST" />
    <chassis name = "client" implement = "MUST" />

    <method name = "declare" synchronous = "1" index = "10">
    declare queue, create if needed
    ... (method body ommitted for brevity)
    </method>

    <method name = "declare-ok" synchronous = "1" index = "11">
    confirms a queue definition
    ... (method body ommitted for brevity)
    </method>

    <method name = "bind" synchronous = "1" index = "20">
    bind queue to an exchange
    ... (method body ommitted for brevity)
    </method>

    <method name = "bind-ok" synchronous = "1" index = "21">
    confirm bind successful
    ... (method body ommitted for brevity)
    </method>

    <method name = "purge" synchronous = "1" index = "30">
    ... (method body ommitted for brevity)
    </method>

    <method name = "purge-ok" synchronous = "1" index = "31">
    confirms a queue purge
    ... (method body ommitted for brevity)
    </method>

    <method name = "delete" synchronous = "1" index = "40">
    delete a queue
    ... (method body ommitted for brevity)
    </method>

    <method name = "delete-ok" synchronous = "1" index = "41">
    confirm deletion of a queue
    ... (method body ommitted for brevity)
    </method>

    </class>

Base specification for client chassis
-------------------------------------

The asl_client.asl base class defines common specifications for all protocol
client layers that are generated from the default backends (which generate ANSI
C layers).  Thus all protocols (demo included) start with this base set of
specifications.

    <?xml version="1.0"?>
    <protocol
        comment = "ASL standard client actions"
        abstract = "1"
        >

The specifications are defined per class.  For the connection class, we define
a set of properties, called the "context", that exist for each client-side
connection.  Note that these are populated by the pre-supplied client protocol
stack implementation.

    <class name = "connection">
    <context>
        icl_shortstr_t
            server_host;
        icl_shortstr_t
            server_name;
        icl_shortstr_t
            server_product;                 //  Reported by server
        icl_shortstr_t
            server_version;
        icl_shortstr_t
            server_platform;
        icl_shortstr_t
            server_copyright;
        icl_shortstr_t
            server_information;
        icl_shortstr_t
            server_instance;
    </context>

The base specification, like the chassis specification that is derived from
it, can specify code to be executed when protocol methods are received.  In
the following example we specify code to be executed when the server sends
us a Connection.Start method.  Note that the ASL entity is "action", which
can be read as "action to take when this method is received".

    <action name = "start">
        <local>
        asl_field_list_t
            *fields;                        //  Decoded responses
        </local>
        //
        fields = asl_field_list_new (method->server_properties);
        if (fields) {
            asl_field_list_cpy (fields, connection->server_host,            "host");
            asl_field_list_cpy (fields, connection->server_instance,        "instance");
            asl_field_list_cpy (fields, connection->server_product,         "product");
            asl_field_list_cpy (fields, connection->server_version,         "version");
            asl_field_list_cpy (fields, connection->server_platform,        "platform");
            asl_field_list_cpy (fields, connection->server_copyright,       "copyright");
            asl_field_list_cpy (fields, connection->server_information,     "information");
            asl_field_list_destroy (&fields);
        }
    </action>

All contexts and actions are inherited to the derived chassis class, which
can add further context variables, and further class actions.

Base specification for server chassis
-------------------------------------

The asl_server.asl base class defines common specifications for all protocol
server layers that are generated from the default backends (which generate ANSI
C layers).  Thus all protocols (demo included) start with this base set of
specifications.

    <?xml version="1.0"?>
    <protocol
        comment = "ASL standard server actions"
        abstract = "1"
        >

The specifications are defined per class.  For the server chassis, we define
a set of actions; this is the glue that tells the generated code how to 
implement a given protocol method:

    <class name = "connection">
    <action name = "start-ok">
        $(basename)_connection_start_ok (connection, method);
    </action>
    <action name = "tune-ok">
        $(basename)_connection_tune_ok (connection, method);
    </action>
    <action name = "open">
        $(basename)_connection_open (connection, method);
    </action>
    </class>

If we do not specify an action for a protocol method, the method has no effect.
Most often - as in the above example - we pass the protocol method to some
hand-written code that implements the necessary work.

Required hand-written files
---------------------------

The stdc target assumes a number of hand-written files, apart from the ASL model
files needed to define the protocol and the chassis.  The hand-written files we
defined for demo protocol implementation can be used as a basis for other protocols.
We explain these files, and what they do, in more detail in the section on the stdc
target.  We will now provide a summary explanation.

Hand-written files for client stack
...................................

These hand-written client stack files are assumed by the stdc target and must
be provided by the developer:

 * demo_client_classes.icl - collection of all classes used in client stack.
 * demo_client_channel.icl - implementation of client channel class.
 * demo_client_config.opf - OPF configuration specification for client stack.

This file is optional, but useful, and normally copied from ASL at the same time
as the above files:

 * demo_cli.c - test program for demo protocol.

Hand-written files for server stack
...................................

These hand-written server stack files are assumed by the stdc target and must
be provided by the developer:

 * demo_server_classes.icl - collection of all classes used in server stack.
 * demo_server_connection.icl - implementation of server connection class.
 * demo_server_channel.icl - implementation of server channel class.
 * demo_broker.icl - implementation of server broker class.
 * demo_server_config.opf - OPF configuration specification for server stack.

These files are optional but useful, since they define the main server program:

 * demo_srv.c - example mainline program.
 * demo_server_main.inc - actual mainline code.
 * demo_srv_base.cfg - configuration data used by default.

These files are additionally used by the demo protocol server chassis (the classes
are included from demo_server_classes, and the methods they contain are referred to
in demo_server_proto.asl:

 * demo_exchange.icl - exchange class.
 * demo_queue.icl - queue master class.
 * demo_queue_basic.icl - basic queue class.
 * demo_queue_list.icl - queue list class.

Code generation process
-----------------------

The demo protocol uses the stdc target.  This defines two stacks, one for the
client and one for the server.  Each of these is generated independently.  There
are also shared files, which are generated from the demo protocol base
specification, the demo.asl file.

Generating the client stack
...........................

To generate the client stack manually we issue this gsl command:

    gsl demo_client_proto.asl

In a PDL project file, this is expressed as:

    <file name = "demo_client_proto.asl" class = "gsl data" />

The generated client stack consists of these files:

 * demo_client_agent.smt - the client-side protocol state machine.
 * demo_client_connection.icl - the connection class.
 * demo_client_session.icl - the session class.
 * demo_client_method.icl - the client method glue class.

We explain the purpose of each of these in more detail when we explain how
the stdc target is constructed.

These files are all models, and themselves need to be "compiled" via code
generation.  When we do this fully, we get this additional set of generated
files for the client stack (with indentation showing the relationship between
further generated files and their parents):

    demo_client_agent.smt
        demo_client_agent.c
        demo_client_agent.h
    demo_client_channel.icl
        demo_client_channel.c
        demo_client_channel.h
        demo_client_channel_test.c
        demo_client_channel_table.icl
            demo_client_channel_table.c
            demo_client_channel_table.h
            demo_client_channel_table_test.c
    demo_client_classes.icl
        demo_client_classes.c
        demo_client_classes.h
    demo_client_config.opf
        demo_client_config.icl
            demo_client_config.c
            demo_client_config.h
            demo_client_config_test.c
    demo_client_connection.icl
        demo_client_connection.c
        demo_client_connection.h
        demo_client_connection_test.c
    demo_client_method.icl
        demo_client_method.c
        demo_client_method.h
        demo_client_method_test.c
    demo_client_session.icl
        demo_client_session.c
        demo_client_session.h
        demo_client_session_test.c

See base2/asl/project.pdl for the project specification needed
for the demo client stack, providing Boom with all information necessary
to generate, compile, link, and install the files.

Generating the server stack
...........................

To generate the server stack manually we issue this gsl command:

    gsl demo_server_proto.asl

In a PDL project file, this is expressed as:

    <file name = "demo_server_proto.asl" class = "gsl data" />

The generated server stack consists of these files:

 * demo_server_agent.smt - the server-side protocol state machine.
 * demo_server_method.icl - the server method glue class.

These files are all models, and themselves need to be "compiled" via code
generation.  When we do this fully, we get this additional set of generated
files for the server stack (with .c and .f files generated for classes not
shown, for brevity):

    demo_broker_agent.smt
    demo_exchange_agent.smt
    demo_exchange_table.icl
    demo_queue_agent.smt
    demo_queue_table.icl
    demo_server_agent.smt
    demo_server_channel_agent.smt
    demo_server_channel_table.icl
    demo_server_config.icl
    demo_server_connection_list.icl
    demo_server_connection_table.icl
    demo_server_method.icl

See base2/asl/project.pdl for the project specification needed
for the demo server stack, providing Boom with all information necessary
to generate, compile, link, and install the files.

Generating the common classes
.............................

A number of classes are shared by the client and server stack.  These
are generated from the protocol base specification (demo.asl).  We
would issue this gsl command by hand:

    gsl demo.asl

In a PDL project file, this is expressed as:

    <file name = "demo.asl" class = "gsl public data" />

The generated shared classes consist of these files:

 * demo_constants.icl - protocol constants.
 * demo_content_basic.icl - the shared Basic content class.
 * demo_content_basic_list.icl - list of Basic contents.

These are the final files generated when we compile all the models:

    demo_constants.icl
        demo_constants.c
        demo_constants.h
    demo_content_basic.icl
        demo_content_basic.c
        demo_content_basic.h
        demo_content_basic_test.c
    demo_content_basic_list.icl
        demo_content_basic_list.c
        demo_content_basic_list.h
        demo_content_basic_list_test.c

See base2/asl/project.pdl for the project specification needed
for the demo shared clases, providing Boom with all information necessary
to generate, compile, link, and install the files.




The stdc target
===============

Protocol options
----------------

specified in protocol base specification.

<option name = "protocol_name"     value = "DEMO" />
<option name = "protocol_port"     value = "7654" />
<option name = "protocol_class"    value = "1" />
<option name = "protocol_instance" value = "1" />
<option name = "protocol_major"    value = "1" />
<option name = "protocol_minor"    value = "1" />

in client chassis

<option name = "product_name" value = "ASL Demo Client" />
<option name = "syncapi"      value = "1" />

in server chassis

<option name = "product_name" value = "ASL Demo Server" />


Architecture of client stack
----------------------------

- layers
- sync. vs async


Client session handling
.......................

- general design
- synchronisation

Client protocol state machine
.............................

- general design
- each state
- error handling

Hand-written files for client stack
...................................

 * demo_client_classes.icl - collection of all classes used in client stack.
 * demo_client_channel.icl - implementation of client channel class.
 * demo_client_config.opf - OPF configuration specification for client stack.

Architecture of server stack
----------------------------

Server protocol state machine
.............................

- general design
- each state
- error handling

Hand-written files for server stack
...................................

 * demo_server_classes.icl - collection of all classes used in server stack.
 * demo_server_connection.icl - implementation of server connection class.
 * demo_server_channel.icl - implementation of server channel class.
 * demo_broker.icl - implementation of server broker class.
 * demo_server_config.opf - OPF configuration specification for server stack.


The doc target
==============

The pal target
==============


Reference
=========
