<page
    name = "pal"
    title = "Scripting AMQP"
    subtitle = "The PAL Scripting Language"
    >
<content type = "gurudoc">

Introduction
************

PAL - the protocol automation language - is a scripting language
designed to automate ASL-modeled protocols, such as the
AMQ protocol. PAL is written as XML and combines two
sets of functionality:

 1. A simple scripting language.

 2. A set of commands that automate the protocol.

The scripting language functionality provides loops, conditional and
repeated blocks, variables etc. The protocol method commands talk to the
server and manipulate content.

Sample PAL Scripts
==================

This section is in the form of a tutorial that explains each
functionality with an example. Here is a sample PAL script:

    &lt;?xml?&gt;
    &lt;pal script = "amq_pal_gen"&gt;
        &lt;echo&gt;
        Hello world!
        &lt;/echo&gt;
    &lt;/pal&gt;

To compile the script use "pal" command. It will create an executable for
you. You can run the executable straight away. Use "-h" option to get
command line parameters for the executable.

    $ pal hello.pal
    2007/03/23 06:46:41: gsl/4 M: Generating hello.c...
    Compiling hello...
    Linking hello...
    $ ./hello
    06:46:56: Hello world!
    $

Here is a script that demonstrates some of the standard PAL control
commands:

    &lt;?xml?&gt;
    &lt;pal script = "amq_pal_gen"&gt;
        &lt;set name = "index" value = "0" /&gt;
        &lt;repeat&gt;
            &lt;inc name = "index" /&gt;
            &lt;if name = "index" value = "10"&gt;
                &lt;break/&gt;
            &lt;/if&gt;
            &lt;else&gt;
                &lt;echo&gt;I can count up to $index&lt;/echo&gt;
            &lt;/else&gt;
        &lt;/repeat&gt;
    &lt;/pal&gt;

And an equivalent, shorter version:

    &lt;?xml?&gt;
    &lt;pal script = "amq_pal_gen"&gt;
        &lt;repeat times = "10" counter = "index"&gt;
            &lt;echo&gt;I can count up to $index&lt;/echo&gt;
        &lt;/repeat&gt;
    &lt;/pal&gt;

To connect to a server and open a session we use the &lt;session&gt; control
command. Here is a script that connects to a server and then echoes the
connection properties:

    &lt;?xml?&gt;
    &lt;pal script = "amq_pal_gen"&gt;
        &lt;session&gt;
            &lt;echo&gt;channel_max=$$(name)&lt;/echo&gt;
            &lt;echo&gt;class_id=$$(name)&lt;/echo&gt;
            &lt;echo&gt;frame_max=$$(name)&lt;/echo&gt;
            &lt;echo&gt;heartbeat=$$(name)&lt;/echo&gt;
            &lt;echo&gt;host=$$(name)&lt;/echo&gt;
            &lt;echo&gt;known_hosts=$$(name)&lt;/echo&gt;
            &lt;echo&gt;method_id=$$(name)&lt;/echo&gt;
            &lt;echo&gt;reply_code=$$(name)&lt;/echo&gt;
            &lt;echo&gt;reply_text=$$(name)&lt;/echo&gt;
            &lt;echo&gt;server_copyright=$$(name)&lt;/echo&gt;
            &lt;echo&gt;server_host=$$(name)&lt;/echo&gt;
            &lt;echo&gt;server_information=$$(name)&lt;/echo&gt;
            &lt;echo&gt;server_name=$$(name)&lt;/echo&gt;
            &lt;echo&gt;server_platform=$$(name)&lt;/echo&gt;
            &lt;echo&gt;server_product=$$(name)&lt;/echo&gt;
            &lt;echo&gt;server_version=$$(name)&lt;/echo&gt;
            &lt;echo&gt;version_major=$$(name)&lt;/echo&gt;
            &lt;echo&gt;version_minor=$$(name)&lt;/echo&gt;
        &lt;/session&gt;
    &lt;/pal&gt;

Note that the script does not specify what server to talk to, nor the IP
port. These and other options are passed on the command-line. For the
standard C PAL implementation run the script executable with "-h" to get
a list of all options.

Having established a session we can send methods to the server:

    &lt;?xml?&gt;
    &lt;pal script = "amq_pal_gen"&gt;
        &lt;session&gt;
            &lt;queue_declare queue = "myqueue" /&gt;
            &lt;queue_bind queue = "myqueue" exchange = "myexchange" /&gt;
            &lt;basic_content size = "64000" message_id = "id-0001" /&gt;
            &lt;basic_publish exchange = "myexchange" routing_key = "myqueue" /&gt;
            &lt;basic_browse queue = "myqueue" /&gt;
            &lt;basic_arrived&gt;
                &lt;echo&gt;Message '$message_id' came back to us&lt;/echo&gt;
            &lt;/basic_arrived&gt;
            &lt;empty&gt;
                &lt;echo&gt;Message did not come back, this is bad!&lt;/echo&gt;
            &lt;/empty&gt;
        &lt;/session&gt;
    &lt;/pal&gt;

PAL lets us define often-used method arguments at the 'session' level.
These are then inherited to methods that don't explicity specify them.
So we can rewrite the above script to make it shorter:

    &lt;?xml?&gt;
    &lt;pal script = "amq_pal_gen"&gt;
        &lt;session
            exchange = "myexchange"
            queue = "myqueue"
            &gt;
            &lt;exchange_declare class = "fanout" /&gt;
            &lt;queue_declare /&gt;
            &lt;queue_bind /&gt;
            &lt;basic_content size = "64000" message_id = "id-0001" /&gt;
            &lt;basic_publish routing_key = "myqueue" /&gt;
            &lt;basic_browse /&gt;
            &lt;basic_arrived&gt;
                &lt;echo&gt;Message '$message_id' came back to us&lt;/echo&gt;
            &lt;/basic_arrived&gt;
            &lt;empty&gt;
                &lt;echo&gt;Message did not come back, this is bad!&lt;/echo&gt;
            &lt;/empty&gt;
        &lt;/session&gt;
    &lt;/pal&gt;

We can also create content bodies by reading data from test data files,
or by running helper commands.  See the 'read' and 'exec' options for
the content commands.  It's as simple as (for instance):

    &lt;basic_content exec = "perl -S myprog.pl" /&gt;

Scripts can be made flexible by passing arguments on the command
line.  Here is a simple example:

    &lt;?xml?&gt;
    &lt;pal script = "amq_pal_gen"&gt;
        &lt;set name = "number" value = "1234" cmdline = "N" /&gt;
        &lt;set name = "string" value = "abcd" cmdline = "S" /&gt;
        &lt;echo&gt;Number=$number, string=$string&lt;/echo&gt;
    &lt;/pal&gt;

Which we can run with the options -N and -S:

    cmdline -N 9999 -S XXXX
    
Lastly let's look at macros, which are ways of collecting repetitive
commands into groups to save time:

    &lt;?xml?&gt;
    &lt;pal script = "amq_pal_gen"&gt;
        &lt;macro name = "queue new"&gt;
            &lt;exchange_declare exchange = "stdqueue" class = "fanout" /&gt;
            &lt;queue_declare queue = "$queue" /&gt;
            &lt;queue_bind queue = "$queue" exchange = "stdqueue" /&gt;
        &lt;/macro&gt;
        &lt;macro name = "send message"&gt;
            &lt;basic_content size = "$size" message_id = "id-$random" /&gt;
            &lt;basic_publish exchange = "stdqueue" routing_key = "$queue" /&gt;
        &lt;/macro&gt;
        &lt;session&gt;
            &lt;set name = "queue" value = "myqueue" /&gt;
            &lt;invoke macro = "queue new" /&gt;
            &lt;invoke macro = "send message"&gt;
                &lt;set name = "size" value = "64000" /&gt;
            &lt;/invoke&gt;
            &lt;basic_browse queue = "myqueue" /&gt;
            &lt;basic_arrived&gt;
                &lt;echo&gt;Message '$message_id' came back to us&lt;/echo&gt;
            &lt;/basic_arrived&gt;
            &lt;empty&gt;
                &lt;echo&gt;Message did not come back, this is bad!&lt;/echo&gt;
            &lt;/empty&gt;
        &lt;/session&gt;
    &lt;/pal&gt;

If you use macros to any extent you'll want to look at the &lt;include&gt;
command, described in the next section.

Scripting Commands
******************

Summary
=======

These are the basic scripting commands, which can be nested to form
scripts of any complexity:

    invoke  - invoke a macro
    server  - start a protocol server
    set     - define or modify a variable
    inc     - increment a counter variable
    dec     - decrement a counter variable
    echo    - echo text to the console
    abort   - echo text to the console and abort the script
    assert  - assert some condition is true
    repeat  - repeat a loop some number of times
    while   - repeat a loop while some condition is true
    break   - exit a loop
    if      - execute commands if a condition is true
    else    - execute commands if the previous if condition was false
    elsif   - combined if and else
    wait    - wait for the server to return data

Overall PAL Script Structure
============================

The overall structure of the PAL script is:

    &lt;pal script = "amq_pal_gen"&gt;
        [ &lt;include filename = "filename" /&gt; ]...
        [ &lt;macro name = "macroname"&gt;
            [ script command ]...
          &lt;/macro&gt; ]...
        [ &lt;session&gt;
            [ script command ]...
          &lt;/session&gt; ]...
    &lt;/pal&gt;

The Include Command
===================

The &lt;include&gt; command copies the contents of another PAL file into the
current script.  It has this syntax:

    &lt;include filename = "scriptfile" /&gt;

 - The filename must include the file extension (usually .pal). The
   included file should not have a &lt;pal&gt; level but may contain macros
   or script commands.

The Macro Command
=================

The &lt;macro&gt; command defines a block of commands that can be reused in
as a single command in the script.  It has this syntax:
    
    &lt;macro
        name = "macroname"&gt;
        [ script command ]...
    &lt;/macro&gt;

 - Macros have no effect until they are used through the 'invoke'
   command.

The Session Command
===================

The &lt;session&gt; command defines a session:

    &lt;session
      [ restart = "0 | 1" ]
      [ error_handling = "abort | recover"]
      [ server = "servername" ]
        &gt;
        [ script command ]...
    &lt;/session&gt;

 - PAL may in future allow multiple sessions to be started in parallel,
   but for now sessions are executed serially.

 - If the restart option is 1, the session will restart in a new connection,
   whatever the state of previous sessions.  If 0, the session will restart
   in the previous connection, if any.

 - If error_handling is 'abort', the script will exit if the server reports
   an error on any command.  This is the default behaviour.

 - If error_handling is 'recover', the script will reconnect.  You can use
   this in scripts that deliberately provoke server errors.  However, mixing
   error recovery with asynchronous methods such as sending or receiving
   messages may have interesting results as the asynchronous methods can
   interfere with session shutdown and restart.

 - The servername can be used to test multiple servers in a single script.
   This option is not used for general-purpose scripts.

The Invoke Command
==================

The &lt;invoke&gt; command expands a macro:

    &lt;invoke
        macro = "macroname"
        /&gt;

 - If the macro uses variables in commands, you can set these variables
   either before the &lt;invoke&gt; command, or inside it, using &lt;set&gt; commands.

The Server Command
==================

The &lt;server&gt; commands starts or restarts a protocol server:

    &lt;server
        name = "servername"
      [ stdout = "filename" ]
      [ stderr = "filename" ]
      [ where = "directory" ]
        /&gt;

 - Do not specify a file extension (.exe) or your scripts will not be
   portable.

 - If a protocol server was already started, this command stops the server
   and then restarts it.

 - Only one protocol server can be started at a time.

 - The name value can include arbitrary server arguments but not shell
   redirection commands.

 - To redirect the server's output, use the stdout and stderr options.

The Timer Command
=================

The &lt;timer&gt; commands shows or resets the script timer.

    &lt;timer
      [ action = "show | reset" ]
        /&gt;

 - The action is optional and defaults to "reset".
 
The Set Command
===============

The &lt;set&gt; command defines a variable. Variables can be strings or integers.
You can use variables in repeat, while, and if blocks, and as symbols for
templating arguments and strings. Untyped variables are typed according
to their value.

    &lt;set
        name = "variablename"
      [ value = "newvalue" ]
      [ type = "string | integer" ]
        cmdline = "char"
        /&gt;

 - The value is optional, and defaults to "".
 
 - If the value is purely numeric, the type will default to "integer",
   and if not the type will default to "string".

 - The cmdline option specifies a single character. Do not use one of
   the command-line options already used by the PAL implementation (see
   section at the end of this document).
   
The Inc Command
===============

The &lt;inc&gt; command increments an integer variable:

    &lt;inc
        name = "variablename"
        /&gt;

The Dec Command
===============

The &lt;dec&gt; command decrements an integer variable:  

    &lt;dec
        name = "variablename"
        /&gt;

 - Decrementing a variable below zero is illegal and raises a fatal error.
   This is done to catch script errors - negative values are normally not
   meaningful in test scripts.
   
The Echo Command
================

The &lt;echo&gt; command echoes a line of text:

    &lt;echo [trace = "1|2|3"]&gt;line of text&lt;/echo&gt;

 - The text can use variables with the syntax: $variablename.

 - The trace level set using a command-line switch.  Use the help option
   (-h) on the test program for details.

The Assert Command
==================

The &lt;assert&gt; command tests a condition and aborts the script if the
condition is false.

    &lt;assert
        name = "variablename"
      [ test = "eq | ne | gt | lt | ge | le" ]
      [ value = "testvalue" ]
        &gt;[line of text]&lt;/assert&gt;

 - The variablename is a script variable, or a connection or session
   property, or a standard PAL variable.

 - If the test and value are not specified, they default to "ne" and
   "0" or "" depending on the type of variable.

 - If just the test is not specified, it defaults to "eq".

 - If the assert statement includes a message, this is printed before
   an assertion failure.

The Repeat Command
==================

The &lt;repeat&gt; command defines an iterative loop, which can run forever
or for a specified number of times. The counter is global (do not use
the same counter for two nested loops). To access the counter within
the repeat loop, use $variablename.

    &lt;repeat
      [ counter = "variablename" ]
      [ times = "integer" ]
      [ progress = "integer" ]
        &gt;
        [ script command ]...
    &lt;/repeat&gt;

 - If the times attribute is not specified, the loop will run forever
   or until the script does a &lt;break/&gt;.

 - The counter does not need to be previously defined. If no counter
   is specified, the repeat loop will create its own internal counter
   which cannot then be used as a symbolic value.

 - If the progress option is set to an integer N, then after every N
   passes through the loop, the test script will print a dot to the
   standard error output.

The While Command
=================

The &lt;while&gt; command defines a conditional loop, which runs so long as
a specified condition is true:

    &lt;while
        name = "variablename"
      [ test = "eq | ne | gt | lt | ge | le" ]
      [ value = "testvalue" ]
      [ counter = "variablename" ]
      [ progress = "integer" ]
        &gt;
        [ script command ]...
    &lt;/while&gt;

 - See the &lt;assert&gt; command for an explanation of the test and value
   properties.

 - If a counter is specified, this variable is automatically set to
   zero when the while loop starts and incremented each time the loop
   runs.  You can access the counter variable after the while loop.

 - If the progress option is set to an integer N, then after every N
   passes through the loop, the test script will print a dot to the
   standard error output.

The Break Command
=================

The &lt;break&gt; command exits the enveloping repeat or while loop and has
this syntax:

    &lt;break/&gt;
    
The If Command
==============

The &lt;if&gt; command defines a block that is executed if a specific condition
is true:

    &lt;if
        name = "variablename"
      [ test = "eq | ne | gt | lt | ge | le" ]
      [ value = "testvalue" ]
        &gt;
        [ script command ]...
    &lt;/if&gt;

 - See the &lt;assert&gt; command for an explanation of the test and value
   properties.

The Else Command
================

The &lt;else&gt; command defines a block that is executed if the previous &lt;if&gt;
condition was false:

    &lt;else&gt;
        [ script command ]...
    &lt;/else&gt;

The Elsif Command
=================

The &lt;elsif&gt; command defines a block that is executed if the previous &lt;if&gt;
condition was false and some further condition is true:

    &lt;elsif
        name = "variablename"
      [ test = "eq | ne | gt | lt | ge | le" ]
      [ value = "testvalue" ]
        &gt;
        [ script command ]...
    &lt;/elsif&gt;

 - See the &lt;assert&gt; command for an explanation of the test and value
   properties.

The Wait Command
================

The &lt;wait&gt; command pauses the script for a number of milliseconds, or
until content is received from the server:

    &lt;wait
      [ timeout = "milliseconds" ]
        /&gt;

 - Inside a session the default timeout is 'forever'.  Outside a session,
   the default timeout is 'zero'.
   
Here is an example of using the &lt;wait&gt; command:

    &lt;?xml?&gt;
    &lt;pal script = "amq_pal_gen"&gt;
        &lt;set name = "index" value = "0" /&gt;
        &lt;echo&gt;Waiting without an active connection...&lt;/echo&gt;
        &lt;wait timeout = "1000" /&gt;
        &lt;session&gt;
            &lt;echo&gt;Waiting inside an active connection...&lt;/echo&gt;
            &lt;wait timeout = "1000" /&gt;
        &lt;/session&gt;
        &lt;echo&gt;OK&lt;/echo&gt;
    &lt;/pal&gt;

The Abort Command
=================

The &lt;abort&gt; command echoes a line of text and halts the script.

    &lt;abort&gt;line of text&lt;/abort&gt;

 - The text can use variables with the syntax: $variablename.

The Exit Command
================

The &lt;exit&gt; command halts the script.

    &lt;exit [status = "value"] &gt;

 - The default status value is 0.

PAL Variables
=============

PAL uses the convention '$name' to allow variable substitution.  This
is allowed in:

 - The body of &lt;echo&gt; and &lt;abort&gt; commands.
 - All attributes except variablenames.

PAL defines all connection and session properties as variables. These
are the connection properties:

 -  channel_max - proposed maximum channels.
 -  class_id - failing method class.
 -  frame_max - proposed maximum frame size.
 -  heartbeat - desired heartbeat delay.
 -  host - server to connect to.
 -  known_hosts - list of known hosts.
 -  method_id - failing method ID.
 -  reply_code - reply code from server.
 -  reply_text - localised reply text.
 -  server_copyright - server copyright.
 -  server_host - server hostname and port.
 -  server_information - other server information.
 -  server_name - server instance name.
 -  server_platform - operating platform.
 -  server_product - name of server implementation.
 -  server_version - version of server.
 -  version_major - protocol major version.
 -  version_minor - protocol major version.

These are the session properties:

 -  active - start/stop content frames.
 -  class_id - failing method class.
 -  cluster_id - Cluster id.
 -  consumer_count - number of consumers.
 -  consumer_tag - consumer tag.
 -  content_size - message content size.
 -  delivery_tag - server-assigned delivery tag.
 -  exchange - exchange name.
 -  identifier - staging identifier.
 -  message_count - number of messages in queue.
 -  method_id - failing method ID.
 -  queue - queue name.
 -  redelivered - message is being redelivered.
 -  reply_code - reply code from server.
 -  reply_text - localised reply text.
 -  routing_key - Message routing key.
 -  staged_size - already staged amount.
 -  ticket - access ticket granted by server.

Note that the standard ASL technique for returning values from protocol
methods is via the session properties. Thus the variable 'message_count'
holds the number of messages after a queue.browse request and a
queue.browse-ok response.

PAL also defines these built-in variables:

  - $script - name of current PAL script.
  
  - $connection - 1 if the connection is alive, else 0.
  
  - $session - 1 if the session is alive, else 0.

  - $random - a random integer in the range 0..32767, when used as an
    insertion value, produces a 4-digit hex string.

  - $body_size - the body size of the last content to be created, 
    arrived, or returned.

You must not name your own variables using any of the connection,
session, or built-in names. PAL resolves a variable reference in this
order:

 1. First, in-built variables.
 2. Content properties, inside an arrived/returned loop.
 3. Session properties.
 4. Connection properties.
 5. Script variables and counters.

Here is a sample script that demonstrates various ways of using
variables:

    &lt;?xml?&gt;
    &lt;pal script = "amq_pal_gen"&gt;
        &lt;set name = "expect_major"   value = "9" /&gt;
        &lt;set name = "exchange_class" value = "fanout" /&gt;
        &lt;set name = "queue"          value = "test-queue" /&gt;
        &lt;set name = "exchange"       value = "test-exchange" /&gt;
        &lt;set name = "times"          value = "100" /&gt;
        &lt;set name = "size"           value = "64000" /&gt;
        &lt;session
            queue    = "$queue"
            exchange = "$exchange"
            &gt;
            &lt;echo&gt;Connected to $server_product/$server_version - $server_platform&lt;/echo&gt;
            &lt;assert name = "version_major" value = "$expect_major" /&gt;
            &lt;exchange_declare class = "$exchange_class" /&gt;
            &lt;queue_declare /&gt;
            &lt;queue_bind /&gt;
            &lt;repeat times = "$times" counter = "id"&gt;
              &lt;basic_content size = "$size" content_type = "text/html" message_id = "id-$id" /&gt;
              &lt;basic_publish routing_key = "$queue" /&gt;
            &lt;/repeat&gt;
            &lt;repeat&gt;
                &lt;basic_browse /&gt;
                &lt;basic_returned&gt;
                    &lt;echo&gt;Returned: $message_id&lt;/echo&gt;
                &lt;/basic_returned&gt;
                &lt;basic_arrived&gt;
                    &lt;inc name = "count" /&gt;
                    &lt;echo&gt;Arrived: $message_id&lt;/echo&gt;
                &lt;/basic_arrived&gt;
                &lt;empty&gt;
                    &lt;break/&gt;
                &lt;/empty&gt;
            &lt;/repeat&gt;
            &lt;echo&gt;Total number of messages exchanged: $count&lt;/echo&gt;
        &lt;/session&gt;
    &lt;/pal&gt;

Protocol Commands
*****************

General Principles
==================

ASL protocols have the useful property of being very high-level. That
is, the protocol methods generally need little or no abstraction to be
immediately obvious and useful to application developers. This makes it
reasonable in PAL to simply expose the protocol methods directly to the
scripting language. This strategy is helped by:

- The use of clear and consistent names for methods and method
  properties.
- The use of intelligent defaults for optional properties.

ASL protocols share the same connection and channel initiation and
tear-down architecture. The methods used to do this - such as
Connection.Tune - are hidden from the PAL developer. Specifically, we
hide:

 - All Connection class methods.
 - The Channel.Open and Close methods.
 - All methods sent by the server and received by the client. Since PAL
   is for client-side automation, these cannot be scripted.

Content Commands
================

For each content class, PAL provides a command to create the content
and set its properties. E.g.

    &lt;basic_content
      [ size = "bodysize"  ("1024") ]
      [ fill = "random | null | repeat"  ("random") ]
      [ read = "..." ]
      [ exec = "..." ]
      [ headers = "0|(1)" ]
      [ content_type = "propertyvalue" ]
      [ content_encoding = "propertyvalue" ]
      [ message_id = "propertyvalue" ]
        &gt;
        [ &lt;headers&gt;
          [ &lt;field
                name = "fieldname"
              [ value = "fieldvalue" ]
              [ type = "string | integer"  ("string") ]
                /&gt; ]...
        &lt;/headers&gt; ]
    &lt;/basic_content&gt;

 - The size attribute specifies the size in octets of the content buffer.
   Its default value is "1024".                                   

 - The fill attribute specifies the fill mode. It can be "random", which
   sets the body to random data, or "null", which sets it to binary zeroes.
   (Note: the fill attribute is not implemented in the current version of
   PAL).

 - The read attribute specifies a file from which to read the content
   body. This is useful when you want to send test messages with a specific
   format.

 - The exec attribute specifies a command to run, so that the stdout of
   the command can be used as the content body.  The command must be the
   name of an executable program, on the path, with arguments as desired.
   The program receives the current content body as stdin, much like a
   web server CGI program.
   
 - If the headers field is set to zero, the output of the executed
   program is not reparsed. If one, the output is reparsed to collect
   message properties and headers as follows: each line specifies a
   header field name, followed by ":", followed by a space and a value.
   Field names starting with "x-table-" are stored as-is (minus the
   x-table- prefix) in a field table with that name. Other fields must
   match known content properties. Hyphens are allowed in field names,
   and field names are case-insensitive.  The headers are ended with a
   blank line. Parsed headers create a CGI-like interface for calling
   programs.

 - For each content property defined in the protocol (except field tables)
   PAL defines an attribute for the content command.

 - For field tables, PAL defines a child entity with the same name, e.g.
   'headers'.  Field tables are then constructed from one or more &lt;field&gt;
   definitions.

 - After a content command, the script can access the content body size
   as a variables ($body_size in expressions, or body_size in assertions
   and conditions).

Processing Arrived Content
==========================

For each content class, PAL provides a command that lets you process
arrived messages. Contents do not necessarily arrive in a strict
synchronous order - it depends on the protocol - so this command acts as
a loop, and repeats for each arrived content at the moment it is
invoked.

    &lt;basic_arrived
      [ counter = "variablename" ]
        &gt;
        [ script command ]...
    &lt;/basic_arrived&gt;
    &lt;empty&gt;
        [ script command ]...
    &lt;/empty&gt;

 - If a counter is specified, this variable is automatically set to
   zero when the loop starts and incremented each time the loop
   runs.  You can access the counter variable after the loop.

 - If there was no arrived content, the script executes the
   following &lt;empty&gt; command, if any.

You can use these variables within an arrived loop:

 - $body_size - size of content body.
 - $exchange - original exchange to which content was sent.
 - $routing_key - routing key specified in content.
 - $producer_id - original producer id.

Processing Returned Content
---------------------------

We process returned content in a similar way to arrived content:

    &lt;basic_returned
      [ counter = "variablename" ]
        &gt;
        [ script command ]...
    &lt;/basic_returned&gt;
    &lt;empty&gt;
        [ script command ]...
    &lt;/empty&gt;

 - If a counter is specified, this variable is automatically set to
   zero when the loop starts and incremented each time the loop
   runs.  You can access the counter variable after the loop.

 - If there was no arrived content, the script executes the
   following &lt;empty&gt; command, if any.

Synchronous Content Processing
==============================

PAL does not provide any asynchronous content processing. The script
runs as a single-threaded procedure from start to end. Content will
arrive when the script is busy, i.e. during any command that talks to
the server. To process content after such commands, use the 'arrived'
commands. To process content while not doing such commands, use &lt;wait/&gt;
and then use the arrived command.

Protocol Method Commands
========================

A protocol method command sends a protocol method to the server.  If the
method is a synchronous method, the script waits for a response from the
server.  If the method is asynchronous, the script continues without
waiting.  The basic syntax for protocol method commands is:

    &lt;class_method [properties...]&gt;
        &lt;field_table_name&gt;
          [ &lt;field
                name = "fieldname"
              [ value = "fieldvalue" ]
              [ type = "string | integer"  ("string") ]
                /&gt; ]...
        &lt;/field_table_name&gt;
    &lt;/class_method&gt;

Properties that are not specified take a default value, which is zero
for numeric properties, FALSE for Boolean properties, and NULL for
strings and field tables.

The Channel_flow Command
--------------------------------

The &lt;channel_flow&gt; command (enable/disable flow from peer):

    &lt;channel_flow
        [ active = "start/stop content frames" ]
    /&gt;

This method asks the peer to pause or restart the flow of content data.
This is a simple flow-control mechanism that a peer can use to avoid   
oveflowing its queues or otherwise finding itself receiving more       
messages than it can process. Note that this method is not intended for
window control. The peer that receives a request to stop sending       
content should finish sending the current content, if any, and then    
wait until it receives a Flow restart method.                          

The Channel.Flow method accepts the following arguments:
- active (bit) - start/stop content frames. If 1, the peer starts     
  sending content frames. If 0, the peer stops sending content frames.

The Channel_flow_ok Command
--------------------------------

The &lt;channel_flow_ok&gt; command (confirm a flow method):

    &lt;channel_flow_ok
        [ active = "current flow setting" ]
    /&gt;

Confirms to the peer that a flow command was received and processed.

The Channel.Flow-Ok method accepts the following arguments:
- active (bit) - current flow setting. Confirms the setting of the
  processed flow method: 1 means the peer will start sending or   
  continue to send content frames; 0 means it will not.           

The Access_request Command
--------------------------------

The &lt;access_request&gt; command (request an access ticket):

    &lt;access_request
        [ realm = "name of requested realm" ]
        [ exclusive = "request exclusive access" ]
        [ passive = "request passive access" ]
        [ active = "request active access" ]
        [ write = "request write access" ]
        [ read = "request read access" ]
    /&gt;

This method requests an access ticket for an access realm. The server
responds by granting the access ticket. If the client does not have  
access rights to the requested realm this causes a connection        
exception. Access tickets are a per-channel resource.                

The Access.Request method accepts the following arguments:
- realm (shortstr) - name of requested realm. Must start with a slash 
  "/" and continue with path names separated by slashes. A path name  
  consists of any combination of at least one of [A-Za-z0-9] plus zero
  or more of [.-_+!=:].                                               
- exclusive (bit) - request exclusive access. Request exclusive access
  to the realm. If the server cannot grant this - because there are   
  other active tickets for the realm - it raises a channel exception. 
- passive (bit) - request passive access. Request message passive   
  access to the specified access realm. Passive access lets a client
  get information about resources in the realm but not to make any  
  changes to them.                                                  
- active (bit) - request active access. Request message active access
  to the specified access realm. Acvtive access lets a client get    
  create and delete resources in the realm.                          
- write (bit) - request write access. Request write access to the    
  specified access realm. Write access lets a client publish messages
  to all exchanges in the realm.                                     
- read (bit) - request read access. Request read access to the      
  specified access realm. Read access lets a client consume messages
  from queues in the realm.                                         

The Exchange_declare Command
--------------------------------

The &lt;exchange_declare&gt; command (declare exchange, create if needed):

    &lt;exchange_declare
        [ ticket = "access ticket granted by server" ]
        [ exchange = "exchange name" ]
        [ type = "exchange type" ]
        [ passive = "do not create exchange" ]
        [ durable = "request a durable exchange" ]
        [ auto_delete = "auto-delete when unused" ]
        [ internal = "create internal exchange" ]
    /&gt;

This method creates an exchange if it does not already exist, and if
the exchange exists, verifies that it is of the correct and expected
class.                                                              

The Exchange.Declare method accepts the following arguments:
- ticket (short) - access ticket granted by server. When a client      
  defines a new exchange, this belongs to the access realm of the      
  ticket used. All further work done with that exchange must be done   
  with an access ticket for the same realm. An access ticket granted by
  the server for a certain set of access rights within a specific      
  realm. Access tickets are valid within the channel where they were   
  created, and expire when the channel closes.                         
- exchange (shortstr) - exchange name. The exchange name is a       
  client-selected string that identifies the exchange for publish   
  methods. Exchange names may consist of any mixture of digits,     
  letters, and underscores. Exchange names are scoped by the virtual
  host.                                                             
- type (shortstr) - exchange type. Each exchange belongs to one of a   
  set of exchange types implemented by the server. The exchange types  
  define the functionality of the exchange - i.e. how messages are     
  routed through it. It is not valid or meaningful to attempt to change
  the type of an existing exchange.                                    
- passive (bit) - do not create exchange. If set, the server will not
  create the exchange. The client can use this to check whether an   
  exchange exists without modifying the server state.                
- durable (bit) - request a durable exchange. If set when creating a   
  new exchange, the exchange will be marked as durable. Durable        
  exchanges remain active when a server restarts. Non-durable exchanges
  (transient exchanges) are purged if/when a server restarts.          
- auto_delete (bit) - auto-delete when unused. If set, the exchange is
  deleted when all queues have finished using it.                     
- internal (bit) - create internal exchange. If set, the exchange may
  not be used directly by publishers, but only when bound to other   
  exchanges. Internal exchanges are used to construct wiring that is 
  not visible to applications.                                       
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   
- arguments (table) - arguments for declaration. A set of arguments for
  the declaration. The syntax and semantics of these arguments depends 
  on the server implementation. This field is ignored if passive is 1. 

The Exchange_declare_nowait Command
--------------------------------

The &lt;exchange_declare_nowait&gt; command (declare exchange, create if needed):

    &lt;exchange_declare_nowait
        [ ticket = "access ticket granted by server" ]
        [ exchange = "exchange name" ]
        [ type = "exchange type" ]
        [ passive = "do not create exchange" ]
        [ durable = "request a durable exchange" ]
        [ auto_delete = "auto-delete when unused" ]
        [ internal = "create internal exchange" ]
    /&gt;

This method creates an exchange if it does not already exist, and if
the exchange exists, verifies that it is of the correct and expected
class.                                                              

The Exchange.Declare method accepts the following arguments:
- ticket (short) - access ticket granted by server. When a client      
  defines a new exchange, this belongs to the access realm of the      
  ticket used. All further work done with that exchange must be done   
  with an access ticket for the same realm. An access ticket granted by
  the server for a certain set of access rights within a specific      
  realm. Access tickets are valid within the channel where they were   
  created, and expire when the channel closes.                         
- exchange (shortstr) - exchange name. The exchange name is a       
  client-selected string that identifies the exchange for publish   
  methods. Exchange names may consist of any mixture of digits,     
  letters, and underscores. Exchange names are scoped by the virtual
  host.                                                             
- type (shortstr) - exchange type. Each exchange belongs to one of a   
  set of exchange types implemented by the server. The exchange types  
  define the functionality of the exchange - i.e. how messages are     
  routed through it. It is not valid or meaningful to attempt to change
  the type of an existing exchange.                                    
- passive (bit) - do not create exchange. If set, the server will not
  create the exchange. The client can use this to check whether an   
  exchange exists without modifying the server state.                
- durable (bit) - request a durable exchange. If set when creating a   
  new exchange, the exchange will be marked as durable. Durable        
  exchanges remain active when a server restarts. Non-durable exchanges
  (transient exchanges) are purged if/when a server restarts.          
- auto_delete (bit) - auto-delete when unused. If set, the exchange is
  deleted when all queues have finished using it.                     
- internal (bit) - create internal exchange. If set, the exchange may
  not be used directly by publishers, but only when bound to other   
  exchanges. Internal exchanges are used to construct wiring that is 
  not visible to applications.                                       
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   
- arguments (table) - arguments for declaration. A set of arguments for
  the declaration. The syntax and semantics of these arguments depends 
  on the server implementation. This field is ignored if passive is 1. 

The Exchange_delete Command
--------------------------------

The &lt;exchange_delete&gt; command (delete an exchange):

    &lt;exchange_delete
        [ ticket = "access ticket granted by server" ]
        [ exchange = "exchange name" ]
        [ if_unused = "delete only if unused" ]
    /&gt;

This method deletes an exchange. When an exchange is deleted all queue
bindings on the exchange are cancelled.                               

The Exchange.Delete method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- exchange (shortstr) - exchange name. The exchange name is a       
  client-selected string that identifies the exchange for publish   
  methods. Exchange names may consist of any mixture of digits,     
  letters, and underscores. Exchange names are scoped by the virtual
  host.                                                             
- if_unused (bit) - delete only if unused. If set, the server will only
  delete the exchange if it has no queue bindings. If the exchange has 
  queue bindings the server does not delete it but raises a channel    
  exception instead.                                                   
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Exchange_delete_nowait Command
--------------------------------

The &lt;exchange_delete_nowait&gt; command (delete an exchange):

    &lt;exchange_delete_nowait
        [ ticket = "access ticket granted by server" ]
        [ exchange = "exchange name" ]
        [ if_unused = "delete only if unused" ]
    /&gt;

This method deletes an exchange. When an exchange is deleted all queue
bindings on the exchange are cancelled.                               

The Exchange.Delete method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- exchange (shortstr) - exchange name. The exchange name is a       
  client-selected string that identifies the exchange for publish   
  methods. Exchange names may consist of any mixture of digits,     
  letters, and underscores. Exchange names are scoped by the virtual
  host.                                                             
- if_unused (bit) - delete only if unused. If set, the server will only
  delete the exchange if it has no queue bindings. If the exchange has 
  queue bindings the server does not delete it but raises a channel    
  exception instead.                                                   
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Queue_declare Command
--------------------------------

The &lt;queue_declare&gt; command (declare queue, create if needed):

    &lt;queue_declare
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ passive = "do not create queue" ]
        [ durable = "request a durable queue" ]
        [ exclusive = "request an exclusive queue" ]
        [ auto_delete = "auto-delete queue when unused" ]
    /&gt;

This method creates or checks a queue. When creating a new queue the
client can specify various properties that control the durability of
the queue and its contents, and the level of sharing for the queue. 

The Queue.Declare method accepts the following arguments:
- ticket (short) - access ticket granted by server. When a client      
  defines a new queue, this belongs to the access realm of the ticket  
  used. All further work done with that queue must be done with an     
  access ticket for the same realm. The client provides a valid access 
  ticket giving "active" access to the realm in which the queue exists 
  or will be created, or "passive" access if the if-exists flag is set.
  An access ticket granted by the server for a certain set of access   
  rights within a specific realm. Access tickets are valid within the  
  channel where they were created, and expire when the channel closes. 
- queue (shortstr) - queue name. The queue name identifies the queue 
  within the vhost. Queue names may consist of any mixture of digits,
  letters, and underscores.                                          
- passive (bit) - do not create queue. If set, the server will not  
  create the queue. The client can use this to check whether a queue
  exists without modifying the server state.                        
- durable (bit) - request a durable queue. If set when creating a new  
  queue, the queue will be marked as durable. Durable queues remain    
  active when a server restarts. Non-durable queues (transient queues) 
  are purged if/when a server restarts. Note that durable queues do not
  necessarily hold persistent messages, although it does not make sense
  to send persistent messages to a transient queue.                    
- exclusive (bit) - request an exclusive queue. Exclusive queues may
  only be consumed from by the current connection. Setting the      
  'exclusive' flag always implies 'auto-delete'.                    
- auto_delete (bit) - auto-delete queue when unused. If set, the queue
  is deleted when all consumers have finished using it. Last consumer 
  can be cancelled either explicitly or because its channel is closed.
  If there was no consumer ever on the queue, it won't be deleted.    
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   
- arguments (table) - arguments for declaration. A set of arguments for
  the declaration. The syntax and semantics of these arguments depends 
  on the server implementation. This field is ignored if passive is 1. 

The Queue_declare_nowait Command
--------------------------------

The &lt;queue_declare_nowait&gt; command (declare queue, create if needed):

    &lt;queue_declare_nowait
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ passive = "do not create queue" ]
        [ durable = "request a durable queue" ]
        [ exclusive = "request an exclusive queue" ]
        [ auto_delete = "auto-delete queue when unused" ]
    /&gt;

This method creates or checks a queue. When creating a new queue the
client can specify various properties that control the durability of
the queue and its contents, and the level of sharing for the queue. 

The Queue.Declare method accepts the following arguments:
- ticket (short) - access ticket granted by server. When a client      
  defines a new queue, this belongs to the access realm of the ticket  
  used. All further work done with that queue must be done with an     
  access ticket for the same realm. The client provides a valid access 
  ticket giving "active" access to the realm in which the queue exists 
  or will be created, or "passive" access if the if-exists flag is set.
  An access ticket granted by the server for a certain set of access   
  rights within a specific realm. Access tickets are valid within the  
  channel where they were created, and expire when the channel closes. 
- queue (shortstr) - queue name. The queue name identifies the queue 
  within the vhost. Queue names may consist of any mixture of digits,
  letters, and underscores.                                          
- passive (bit) - do not create queue. If set, the server will not  
  create the queue. The client can use this to check whether a queue
  exists without modifying the server state.                        
- durable (bit) - request a durable queue. If set when creating a new  
  queue, the queue will be marked as durable. Durable queues remain    
  active when a server restarts. Non-durable queues (transient queues) 
  are purged if/when a server restarts. Note that durable queues do not
  necessarily hold persistent messages, although it does not make sense
  to send persistent messages to a transient queue.                    
- exclusive (bit) - request an exclusive queue. Exclusive queues may
  only be consumed from by the current connection. Setting the      
  'exclusive' flag always implies 'auto-delete'.                    
- auto_delete (bit) - auto-delete queue when unused. If set, the queue
  is deleted when all consumers have finished using it. Last consumer 
  can be cancelled either explicitly or because its channel is closed.
  If there was no consumer ever on the queue, it won't be deleted.    
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   
- arguments (table) - arguments for declaration. A set of arguments for
  the declaration. The syntax and semantics of these arguments depends 
  on the server implementation. This field is ignored if passive is 1. 

The Queue_bind Command
--------------------------------

The &lt;queue_bind&gt; command (bind queue to an exchange):

    &lt;queue_bind
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ exchange = "exchange name" ]
        [ routing_key = "message routing key" ]
    /&gt;

This method binds a queue to an exchange. Until a queue is bound it   
will not receive any messages. In a classic messaging model,          
store-and-forward queues are bound to a dest exchange and subscription
queues are bound to a dest_wild exchange.                             

The Queue.Bind method accepts the following arguments:
- ticket (short) - access ticket granted by server. The client provides
  a valid access ticket giving "active" access rights to the queue's   
  access realm. An access ticket granted by the server for a certain   
  set of access rights within a specific realm. Access tickets are     
  valid within the channel where they were created, and expire when the
  channel closes.                                                      
- queue (shortstr) - queue name. Specifies the name of the queue to    
  bind. If the queue name is empty, refers to the current queue for the
  channel, which is the last declared queue. The queue name identifies 
  the queue within the vhost. Queue names may consist of any mixture of
  digits, letters, and underscores.                                    
- exchange (shortstr) - exchange name. The exchange name is a       
  client-selected string that identifies the exchange for publish   
  methods. Exchange names may consist of any mixture of digits,     
  letters, and underscores. Exchange names are scoped by the virtual
  host.                                                             
- routing_key (shortstr) - message routing key. Specifies the routing  
  key for the binding. The routing key is used for routing messages    
  depending on the exchange configuration. Not all exchanges use a     
  routing key - refer to the specific exchange documentation. If the   
  routing key is empty and the queue name is empty, the routing key    
  will be the current queue for the channel, which is the last declared
  queue.                                                               
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   
- arguments (table) - arguments for binding. A set of arguments for the
  binding. The syntax and semantics of these arguments depends on the  
  exchange class.                                                      

The Queue_bind_nowait Command
--------------------------------

The &lt;queue_bind_nowait&gt; command (bind queue to an exchange):

    &lt;queue_bind_nowait
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ exchange = "exchange name" ]
        [ routing_key = "message routing key" ]
    /&gt;

This method binds a queue to an exchange. Until a queue is bound it   
will not receive any messages. In a classic messaging model,          
store-and-forward queues are bound to a dest exchange and subscription
queues are bound to a dest_wild exchange.                             

The Queue.Bind method accepts the following arguments:
- ticket (short) - access ticket granted by server. The client provides
  a valid access ticket giving "active" access rights to the queue's   
  access realm. An access ticket granted by the server for a certain   
  set of access rights within a specific realm. Access tickets are     
  valid within the channel where they were created, and expire when the
  channel closes.                                                      
- queue (shortstr) - queue name. Specifies the name of the queue to    
  bind. If the queue name is empty, refers to the current queue for the
  channel, which is the last declared queue. The queue name identifies 
  the queue within the vhost. Queue names may consist of any mixture of
  digits, letters, and underscores.                                    
- exchange (shortstr) - exchange name. The exchange name is a       
  client-selected string that identifies the exchange for publish   
  methods. Exchange names may consist of any mixture of digits,     
  letters, and underscores. Exchange names are scoped by the virtual
  host.                                                             
- routing_key (shortstr) - message routing key. Specifies the routing  
  key for the binding. The routing key is used for routing messages    
  depending on the exchange configuration. Not all exchanges use a     
  routing key - refer to the specific exchange documentation. If the   
  routing key is empty and the queue name is empty, the routing key    
  will be the current queue for the channel, which is the last declared
  queue.                                                               
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   
- arguments (table) - arguments for binding. A set of arguments for the
  binding. The syntax and semantics of these arguments depends on the  
  exchange class.                                                      

The Queue_purge Command
--------------------------------

The &lt;queue_purge&gt; command (purge a queue):

    &lt;queue_purge
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
    /&gt;

This method removes all messages from a queue. It does not cancel
consumers. Purged messages are deleted without any formal "undo" 
mechanism.                                                       

The Queue.Purge method accepts the following arguments:
- ticket (short) - access ticket granted by server. The access ticket
  must be for the access realm that holds the queue. An access ticket
  granted by the server for a certain set of access rights within a  
  specific realm. Access tickets are valid within the channel where  
  they were created, and expire when the channel closes.             
- queue (shortstr) - queue name. Specifies the name of the queue to    
  purge. If the queue name is empty, refers to the current queue for   
  the channel, which is the last declared queue. The queue name        
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Queue_purge_nowait Command
--------------------------------

The &lt;queue_purge_nowait&gt; command (purge a queue):

    &lt;queue_purge_nowait
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
    /&gt;

This method removes all messages from a queue. It does not cancel
consumers. Purged messages are deleted without any formal "undo" 
mechanism.                                                       

The Queue.Purge method accepts the following arguments:
- ticket (short) - access ticket granted by server. The access ticket
  must be for the access realm that holds the queue. An access ticket
  granted by the server for a certain set of access rights within a  
  specific realm. Access tickets are valid within the channel where  
  they were created, and expire when the channel closes.             
- queue (shortstr) - queue name. Specifies the name of the queue to    
  purge. If the queue name is empty, refers to the current queue for   
  the channel, which is the last declared queue. The queue name        
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Queue_delete Command
--------------------------------

The &lt;queue_delete&gt; command (delete a queue):

    &lt;queue_delete
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ if_unused = "delete only if unused" ]
        [ if_empty = "delete only if empty" ]
    /&gt;

This method deletes a queue. When a queue is deleted any pending   
messages are sent to a dead-letter queue if this is defined in the 
server configuration, and all consumers on the queue are cancelled.

The Queue.Delete method accepts the following arguments:
- ticket (short) - access ticket granted by server. The client provides
  a valid access ticket giving "active" access rights to the queue's   
  access realm. An access ticket granted by the server for a certain   
  set of access rights within a specific realm. Access tickets are     
  valid within the channel where they were created, and expire when the
  channel closes.                                                      
- queue (shortstr) - queue name. Specifies the name of the queue to    
  delete. If the queue name is empty, refers to the current queue for  
  the channel, which is the last declared queue. The queue name        
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- if_unused (bit) - delete only if unused. If set, the server will only
  delete the queue if it has no consumers. If the queue has consumers  
  the server does does not delete it but raises a channel exception    
  instead.                                                             
- if_empty (bit) - delete only if empty. If set, the server will only  
  delete the queue if it has no messages. If the queue is not empty the
  server raises a channel exception.                                   
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Queue_delete_nowait Command
--------------------------------

The &lt;queue_delete_nowait&gt; command (delete a queue):

    &lt;queue_delete_nowait
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ if_unused = "delete only if unused" ]
        [ if_empty = "delete only if empty" ]
    /&gt;

This method deletes a queue. When a queue is deleted any pending   
messages are sent to a dead-letter queue if this is defined in the 
server configuration, and all consumers on the queue are cancelled.

The Queue.Delete method accepts the following arguments:
- ticket (short) - access ticket granted by server. The client provides
  a valid access ticket giving "active" access rights to the queue's   
  access realm. An access ticket granted by the server for a certain   
  set of access rights within a specific realm. Access tickets are     
  valid within the channel where they were created, and expire when the
  channel closes.                                                      
- queue (shortstr) - queue name. Specifies the name of the queue to    
  delete. If the queue name is empty, refers to the current queue for  
  the channel, which is the last declared queue. The queue name        
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- if_unused (bit) - delete only if unused. If set, the server will only
  delete the queue if it has no consumers. If the queue has consumers  
  the server does does not delete it but raises a channel exception    
  instead.                                                             
- if_empty (bit) - delete only if empty. If set, the server will only  
  delete the queue if it has no messages. If the queue is not empty the
  server raises a channel exception.                                   
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Basic_qos Command
--------------------------------

The &lt;basic_qos&gt; command (specify quality of service):

    &lt;basic_qos
        [ prefetch_size = "prefetch window in octets" ]
        [ prefetch_count = "prefetch window in messages" ]
        [ global = "apply to entire connection" ]
    /&gt;

This method requests a specific quality of service. The QoS can be     
specified for the current channel or for all channels on the           
connection. The particular properties and semantics of a qos method    
always depend on the content class semantics. Though the qos method    
could in principle apply to both peers, it is currently meaningful only
for the server.                                                        

The Basic.Qos method accepts the following arguments:
- prefetch_size (long) - prefetch window in octets. The client can     
  request that messages be sent in advance so that when the client     
  finishes processing a message, the following message is already held 
  locally, rather than needing to be sent down the channel. Prefetching
  gives a performance improvement. This field specifies the prefetch   
  window size in octets. The server will send a message in advance if  
  it is equal to or smaller in size than the available prefetch size   
  (and also falls into other prefetch limits). May be set to zero,     
  meaning "no specific limit", although other prefetch limits may still
  apply. The prefetch-size is ignored if the no-ack option is set.     
- prefetch_count (short) - prefetch window in messages. Specifies a    
  prefetch window in terms of whole messages. This field may be used in
  combination with the prefetch-size field; a message will only be sent
  in advance if both prefetch windows (and those at the channel and    
  connection level) allow it. The prefetch-count is ignored if the     
  no-ack option is set.                                                
- global (bit) - apply to entire connection. By default the QoS    
  settings apply to the current channel only. If this field is set,
  they are applied to the entire connection.                       

The Basic_consume Command
--------------------------------

The &lt;basic_consume&gt; command (start a queue consumer):

    &lt;basic_consume
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ consumer_tag = "consumer tag" ]
        [ no_local = "do not deliver own messages" ]
        [ no_ack = "no acknowledgement needed" ]
        [ exclusive = "request exclusive access" ]
    /&gt;

This method asks the server to start a "consumer", which is a transient
request for messages from a specific queue. Consumers last as long as  
the channel they were created on, or until the client cancels them.    

The Basic.Consume method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- queue (shortstr) - queue name. Specifies the name of the queue to    
  consume from. If the queue name is null, refers to the current queue 
  for the channel, which is the last declared queue. The queue name    
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- consumer_tag (shortstr) - consumer tag. Specifies the identifier for 
  the consumer. The consumer tag is local to a connection, so two      
  clients can use the same consumer tags. If this field is empty the   
  server will generate a unique tag. Identifier for the consumer, valid
  within the current connection.                                       
- no_local (bit) - do not deliver own messages. If the no-local field  
  is set the server will not send messages to the client that published
  them.                                                                
- no_ack (bit) - no acknowledgement needed. If this field is set the  
  server does not expect acknowledgments for messages. That is, when a
  message is delivered to the client the server automatically and     
  silently acknowledges it on behalf of the client. This functionality
  increases performance but at the cost of reliability. Messages can  
  get lost if a client dies before it can deliver them to the         
  application.                                                        
- exclusive (bit) - request exclusive access. Request exclusive    
  consumer access, meaning only this consumer can access the queue.
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Basic_consume_nowait Command
--------------------------------

The &lt;basic_consume_nowait&gt; command (start a queue consumer):

    &lt;basic_consume_nowait
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ consumer_tag = "consumer tag" ]
        [ no_local = "do not deliver own messages" ]
        [ no_ack = "no acknowledgement needed" ]
        [ exclusive = "request exclusive access" ]
    /&gt;

This method asks the server to start a "consumer", which is a transient
request for messages from a specific queue. Consumers last as long as  
the channel they were created on, or until the client cancels them.    

The Basic.Consume method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- queue (shortstr) - queue name. Specifies the name of the queue to    
  consume from. If the queue name is null, refers to the current queue 
  for the channel, which is the last declared queue. The queue name    
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- consumer_tag (shortstr) - consumer tag. Specifies the identifier for 
  the consumer. The consumer tag is local to a connection, so two      
  clients can use the same consumer tags. If this field is empty the   
  server will generate a unique tag. Identifier for the consumer, valid
  within the current connection.                                       
- no_local (bit) - do not deliver own messages. If the no-local field  
  is set the server will not send messages to the client that published
  them.                                                                
- no_ack (bit) - no acknowledgement needed. If this field is set the  
  server does not expect acknowledgments for messages. That is, when a
  message is delivered to the client the server automatically and     
  silently acknowledges it on behalf of the client. This functionality
  increases performance but at the cost of reliability. Messages can  
  get lost if a client dies before it can deliver them to the         
  application.                                                        
- exclusive (bit) - request exclusive access. Request exclusive    
  consumer access, meaning only this consumer can access the queue.
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Basic_cancel Command
--------------------------------

The &lt;basic_cancel&gt; command (end a queue consumer):

    &lt;basic_cancel
        [ consumer_tag = "consumer tag" ]
    /&gt;

This method cancels a consumer. This does not affect already delivered
messages, but it does mean the server will not send any more messages 
for that consumer. The client may receive an abitrary number of       
messages in between sending the cancel method and receiving the       
cancel-ok reply.                                                      

The Basic.Cancel method accepts the following arguments:
- consumer_tag (shortstr) - consumer tag. Identifier for the consumer,
  valid within the current connection.                                
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Basic_cancel_nowait Command
--------------------------------

The &lt;basic_cancel_nowait&gt; command (end a queue consumer):

    &lt;basic_cancel_nowait
        [ consumer_tag = "consumer tag" ]
    /&gt;

This method cancels a consumer. This does not affect already delivered
messages, but it does mean the server will not send any more messages 
for that consumer. The client may receive an abitrary number of       
messages in between sending the cancel method and receiving the       
cancel-ok reply.                                                      

The Basic.Cancel method accepts the following arguments:
- consumer_tag (shortstr) - consumer tag. Identifier for the consumer,
  valid within the current connection.                                
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Basic_publish Command
--------------------------------

The &lt;basic_publish&gt; command (publish a message):

    &lt;basic_publish
        [ content = "content buffer to transfer" ]
        [ ticket = "access ticket granted by server" ]
        [ exchange = "exchange name" ]
        [ routing_key = "Message routing key" ]
        [ mandatory = "indicate mandatory routing" ]
        [ immediate = "request immediate delivery" ]
    /&gt;

This method publishes a message to a specific exchange. The message  
will be routed to queues as defined by the exchange configuration and
distributed to any active consumers when the transaction, if any, is 
committed.                                                           

The Basic.Publish method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- exchange (shortstr) - exchange name. Specifies the name of the     
  exchange to publish to. The exchange name can be empty, meaning the
  default exchange. If the exchange name is specified, and that      
  exchange does not exist, the server will raise a channel exception.
  The exchange name is a client-selected string that identifies the  
  exchange for publish methods. Exchange names may consist of any    
  mixture of digits, letters, and underscores. Exchange names are    
  scoped by the virtual host.                                        
- routing_key (shortstr) - Message routing key. Specifies the routing
  key for the message. The routing key is used for routing messages  
  depending on the exchange configuration.                           
- mandatory (bit) - indicate mandatory routing. This flag tells the    
  server how to react if the message cannot be routed to a queue. If   
  this flag is set, the server will return an unroutable message with a
  Return method. If this flag is zero, the server silently drops the   
  message.                                                             
- immediate (bit) - request immediate delivery. This flag tells the    
  server how to react if the message cannot be routed to a queue       
  consumer immediately. If this flag is set, the server will return an 
  undeliverable message with a Return method. If this flag is zero, the
  server will queue the message, but with no guarantee that it will    
  ever be consumed.                                                    

The Basic_get Command
--------------------------------

The &lt;basic_get&gt; command (direct access to a queue):

    &lt;basic_get
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ no_ack = "no acknowledgement needed" ]
    /&gt;

This method provides a direct access to the messages in a queue using a
synchronous dialogue that is designed for specific types of application
where synchronous functionality is more important than performance.    

The Basic.Get method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- queue (shortstr) - queue name. Specifies the name of the queue to    
  consume from. If the queue name is null, refers to the current queue 
  for the channel, which is the last declared queue. The queue name    
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- no_ack (bit) - no acknowledgement needed. If this field is set the  
  server does not expect acknowledgments for messages. That is, when a
  message is delivered to the client the server automatically and     
  silently acknowledges it on behalf of the client. This functionality
  increases performance but at the cost of reliability. Messages can  
  get lost if a client dies before it can deliver them to the         
  application.                                                        

The Basic_ack Command
--------------------------------

The &lt;basic_ack&gt; command (acknowledge one or more messages):

    &lt;basic_ack
        [ delivery_tag = "server-assigned delivery tag" ]
        [ multiple = "acknowledge multiple messages" ]
    /&gt;

This method acknowledges one or more messages delivered via the Deliver
or Get-Ok methods. The client can ask to confirm a single message or a 
set of messages up to and including a specific message.                

The Basic.Ack method accepts the following arguments:
- delivery_tag (longlong) - server-assigned delivery tag. The
  server-assigned and channel-specific delivery tag          
- multiple (bit) - acknowledge multiple messages. If set to 1, the    
  delivery tag is treated as "up to and including", so that the client
  can acknowledge multiple messages with a single method. If set to   
  zero, the delivery tag refers to a single message. If the multiple  
  field is 1, and the delivery tag is zero, tells the server to       
  acknowledge all outstanding mesages.                                

The Basic_reject Command
--------------------------------

The &lt;basic_reject&gt; command (reject an incoming message):

    &lt;basic_reject
        [ delivery_tag = "server-assigned delivery tag" ]
        [ requeue = "requeue the message" ]
    /&gt;

This method allows a client to reject a message. It can be used to 
interrupt and cancel large incoming messages, or return untreatable
messages to their original queue.                                  

The Basic.Reject method accepts the following arguments:
- delivery_tag (longlong) - server-assigned delivery tag. The
  server-assigned and channel-specific delivery tag          
- requeue (bit) - requeue the message. If this field is zero, the     
  message will be discarded. If this bit is 1, the server will attempt
  to requeue the message.                                             

The File_qos Command
--------------------------------

The &lt;file_qos&gt; command (specify quality of service):

    &lt;file_qos
        [ prefetch_size = "prefetch window in octets" ]
        [ prefetch_count = "prefetch window in messages" ]
        [ global = "apply to entire connection" ]
    /&gt;

This method requests a specific quality of service. The QoS can be     
specified for the current channel or for all channels on the           
connection. The particular properties and semantics of a qos method    
always depend on the content class semantics. Though the qos method    
could in principle apply to both peers, it is currently meaningful only
for the server.                                                        

The File.Qos method accepts the following arguments:
- prefetch_size (long) - prefetch window in octets. The client can     
  request that messages be sent in advance so that when the client     
  finishes processing a message, the following message is already held 
  locally, rather than needing to be sent down the channel. Prefetching
  gives a performance improvement. This field specifies the prefetch   
  window size in octets. May be set to zero, meaning "no specific      
  limit". Note that other prefetch limits may still apply. The         
  prefetch-size is ignored if the no-ack option is set.                
- prefetch_count (short) - prefetch window in messages. Specifies a   
  prefetch window in terms of whole messages. This is compatible with 
  some file API implementations. This field may be used in combination
  with the prefetch-size field; a message will only be sent in advance
  if both prefetch windows (and those at the channel and connection   
  level) allow it. The prefetch-count is ignored if the no-ack option 
  is set.                                                             
- global (bit) - apply to entire connection. By default the QoS    
  settings apply to the current channel only. If this field is set,
  they are applied to the entire connection.                       

The File_consume Command
--------------------------------

The &lt;file_consume&gt; command (start a queue consumer):

    &lt;file_consume
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ consumer_tag = "consumer tag" ]
        [ no_local = "do not deliver own messages" ]
        [ no_ack = "no acknowledgement needed" ]
        [ exclusive = "request exclusive access" ]
    /&gt;

This method asks the server to start a "consumer", which is a transient
request for messages from a specific queue. Consumers last as long as  
the channel they were created on, or until the client cancels them.    

The File.Consume method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- queue (shortstr) - queue name. Specifies the name of the queue to    
  consume from. If the queue name is null, refers to the current queue 
  for the channel, which is the last declared queue. The queue name    
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- consumer_tag (shortstr) - consumer tag. Specifies the identifier for 
  the consumer. The consumer tag is local to a connection, so two      
  clients can use the same consumer tags. If this field is empty the   
  server will generate a unique tag. Identifier for the consumer, valid
  within the current connection.                                       
- no_local (bit) - do not deliver own messages. If the no-local field  
  is set the server will not send messages to the client that published
  them.                                                                
- no_ack (bit) - no acknowledgement needed. If this field is set the  
  server does not expect acknowledgments for messages. That is, when a
  message is delivered to the client the server automatically and     
  silently acknowledges it on behalf of the client. This functionality
  increases performance but at the cost of reliability. Messages can  
  get lost if a client dies before it can deliver them to the         
  application.                                                        
- exclusive (bit) - request exclusive access. Request exclusive    
  consumer access, meaning only this consumer can access the queue.
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The File_consume_nowait Command
--------------------------------

The &lt;file_consume_nowait&gt; command (start a queue consumer):

    &lt;file_consume_nowait
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ consumer_tag = "consumer tag" ]
        [ no_local = "do not deliver own messages" ]
        [ no_ack = "no acknowledgement needed" ]
        [ exclusive = "request exclusive access" ]
    /&gt;

This method asks the server to start a "consumer", which is a transient
request for messages from a specific queue. Consumers last as long as  
the channel they were created on, or until the client cancels them.    

The File.Consume method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- queue (shortstr) - queue name. Specifies the name of the queue to    
  consume from. If the queue name is null, refers to the current queue 
  for the channel, which is the last declared queue. The queue name    
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- consumer_tag (shortstr) - consumer tag. Specifies the identifier for 
  the consumer. The consumer tag is local to a connection, so two      
  clients can use the same consumer tags. If this field is empty the   
  server will generate a unique tag. Identifier for the consumer, valid
  within the current connection.                                       
- no_local (bit) - do not deliver own messages. If the no-local field  
  is set the server will not send messages to the client that published
  them.                                                                
- no_ack (bit) - no acknowledgement needed. If this field is set the  
  server does not expect acknowledgments for messages. That is, when a
  message is delivered to the client the server automatically and     
  silently acknowledges it on behalf of the client. This functionality
  increases performance but at the cost of reliability. Messages can  
  get lost if a client dies before it can deliver them to the         
  application.                                                        
- exclusive (bit) - request exclusive access. Request exclusive    
  consumer access, meaning only this consumer can access the queue.
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The File_cancel Command
--------------------------------

The &lt;file_cancel&gt; command (end a queue consumer):

    &lt;file_cancel
        [ consumer_tag = "consumer tag" ]
    /&gt;

This method cancels a consumer. This does not affect already delivered
messages, but it does mean the server will not send any more messages 
for that consumer.                                                    

The File.Cancel method accepts the following arguments:
- consumer_tag (shortstr) - consumer tag. Identifier for the consumer,
  valid within the current connection.                                
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The File_cancel_nowait Command
--------------------------------

The &lt;file_cancel_nowait&gt; command (end a queue consumer):

    &lt;file_cancel_nowait
        [ consumer_tag = "consumer tag" ]
    /&gt;

This method cancels a consumer. This does not affect already delivered
messages, but it does mean the server will not send any more messages 
for that consumer.                                                    

The File.Cancel method accepts the following arguments:
- consumer_tag (shortstr) - consumer tag. Identifier for the consumer,
  valid within the current connection.                                
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The File_open Command
--------------------------------

The &lt;file_open&gt; command (request to start staging):

    &lt;file_open
        [ identifier = "staging identifier" ]
        [ content_size = "message content size" ]
    /&gt;

This method requests permission to start staging a message. Staging  
means sending the message into a temporary area at the recipient end 
and then delivering the message by referring to this temporary area. 
Staging is how the protocol handles partial file transfers - if a    
message is partially staged and the connection breaks, the next time 
the sender starts to stage it, it can restart from where it left off.

The File.Open method accepts the following arguments:
- identifier (shortstr) - staging identifier. This is the staging      
  identifier. This is an arbitrary string chosen by the sender. For    
  staging to work correctly the sender must use the same staging       
  identifier when staging the same message a second time after recovery
  from a failure. A good choice for the staging identifier would be the
  SHA1 hash of the message properties data (including the original     
  filename, revised time, etc.).                                       
- content_size (longlong) - message content size. The size of the      
  content in octets. The recipient may use this information to allocate
  or check available space in advance, to avoid "disk full" errors     
  during staging of very large messages.                               

The File_open_ok Command
--------------------------------

The &lt;file_open_ok&gt; command (confirm staging ready):

    &lt;file_open_ok
        [ staged_size = "already staged amount" ]
    /&gt;

This method confirms that the recipient is ready to accept staged data.
If the message was already partially-staged at a previous time the     
recipient will report the number of octets already staged.             

The File.Open-Ok method accepts the following arguments:
- staged_size (longlong) - already staged amount. The amount of      
  previously-staged content in octets. For a new message this will be
  zero.                                                              

The File_stage Command
--------------------------------

The &lt;file_stage&gt; command (stage message content):

    &lt;file_stage
        [ content = "content buffer to transfer" ]
    /&gt;

This method stages the message, sending the message content to the
recipient from the octet offset specified in the Open-Ok method.  

The File_publish Command
--------------------------------

The &lt;file_publish&gt; command (publish a message):

    &lt;file_publish
        [ ticket = "access ticket granted by server" ]
        [ exchange = "exchange name" ]
        [ routing_key = "Message routing key" ]
        [ mandatory = "indicate mandatory routing" ]
        [ immediate = "request immediate delivery" ]
        [ identifier = "staging identifier" ]
    /&gt;

This method publishes a staged file message to a specific exchange. The
file message will be routed to queues as defined by the exchange       
configuration and distributed to any active consumers when the         
transaction, if any, is committed.                                     

The File.Publish method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- exchange (shortstr) - exchange name. Specifies the name of the     
  exchange to publish to. The exchange name can be empty, meaning the
  default exchange. If the exchange name is specified, and that      
  exchange does not exist, the server will raise a channel exception.
  The exchange name is a client-selected string that identifies the  
  exchange for publish methods. Exchange names may consist of any    
  mixture of digits, letters, and underscores. Exchange names are    
  scoped by the virtual host.                                        
- routing_key (shortstr) - Message routing key. Specifies the routing
  key for the message. The routing key is used for routing messages  
  depending on the exchange configuration.                           
- mandatory (bit) - indicate mandatory routing. This flag tells the    
  server how to react if the message cannot be routed to a queue. If   
  this flag is set, the server will return an unroutable message with a
  Return method. If this flag is zero, the server silently drops the   
  message.                                                             
- immediate (bit) - request immediate delivery. This flag tells the    
  server how to react if the message cannot be routed to a queue       
  consumer immediately. If this flag is set, the server will return an 
  undeliverable message with a Return method. If this flag is zero, the
  server will queue the message, but with no guarantee that it will    
  ever be consumed.                                                    
- identifier (shortstr) - staging identifier. This is the staging      
  identifier of the message to publish. The message must have been     
  staged. Note that a client can send the Publish method asynchronously
  without waiting for staging to finish.                               

The File_ack Command
--------------------------------

The &lt;file_ack&gt; command (acknowledge one or more messages):

    &lt;file_ack
        [ delivery_tag = "server-assigned delivery tag" ]
        [ multiple = "acknowledge multiple messages" ]
    /&gt;

This method acknowledges one or more messages delivered via the Deliver
method. The client can ask to confirm a single message or a set of     
messages up to and including a specific message.                       

The File.Ack method accepts the following arguments:
- delivery_tag (longlong) - server-assigned delivery tag. The
  server-assigned and channel-specific delivery tag          
- multiple (bit) - acknowledge multiple messages. If set to 1, the    
  delivery tag is treated as "up to and including", so that the client
  can acknowledge multiple messages with a single method. If set to   
  zero, the delivery tag refers to a single message. If the multiple  
  field is 1, and the delivery tag is zero, tells the server to       
  acknowledge all outstanding mesages.                                

The File_reject Command
--------------------------------

The &lt;file_reject&gt; command (reject an incoming message):

    &lt;file_reject
        [ delivery_tag = "server-assigned delivery tag" ]
        [ requeue = "requeue the message" ]
    /&gt;

This method allows a client to reject a message. It can be used to 
return untreatable messages to their original queue. Note that file
content is staged before delivery, so the client will not use this 
method to interrupt delivery of a large message.                   

The File.Reject method accepts the following arguments:
- delivery_tag (longlong) - server-assigned delivery tag. The
  server-assigned and channel-specific delivery tag          
- requeue (bit) - requeue the message. If this field is zero, the     
  message will be discarded. If this bit is 1, the server will attempt
  to requeue the message.                                             

The Stream_qos Command
--------------------------------

The &lt;stream_qos&gt; command (specify quality of service):

    &lt;stream_qos
        [ prefetch_size = "prefetch window in octets" ]
        [ prefetch_count = "prefetch window in messages" ]
        [ consume_rate = "transfer rate in octets/second" ]
        [ global = "apply to entire connection" ]
    /&gt;

This method requests a specific quality of service. The QoS can be     
specified for the current channel or for all channels on the           
connection. The particular properties and semantics of a qos method    
always depend on the content class semantics. Though the qos method    
could in principle apply to both peers, it is currently meaningful only
for the server.                                                        

The Stream.Qos method accepts the following arguments:
- prefetch_size (long) - prefetch window in octets. The client can     
  request that messages be sent in advance so that when the client     
  finishes processing a message, the following message is already held 
  locally, rather than needing to be sent down the channel. Prefetching
  gives a performance improvement. This field specifies the prefetch   
  window size in octets. May be set to zero, meaning "no specific      
  limit". Note that other prefetch limits may still apply.             
- prefetch_count (short) - prefetch window in messages. Specifies a    
  prefetch window in terms of whole messages. This field may be used in
  combination with the prefetch-size field; a message will only be sent
  in advance if both prefetch windows (and those at the channel and    
  connection level) allow it.                                          
- consume_rate (long) - transfer rate in octets/second. Specifies a  
  desired transfer rate in octets per second. This is usually        
  determined by the application that uses the streaming data. A value
  of zero means "no limit", i.e. as rapidly as possible.             
- global (bit) - apply to entire connection. By default the QoS    
  settings apply to the current channel only. If this field is set,
  they are applied to the entire connection.                       

The Stream_consume Command
--------------------------------

The &lt;stream_consume&gt; command (start a queue consumer):

    &lt;stream_consume
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ consumer_tag = "consumer tag" ]
        [ no_local = "do not deliver own messages" ]
        [ exclusive = "request exclusive access" ]
    /&gt;

This method asks the server to start a "consumer", which is a transient
request for messages from a specific queue. Consumers last as long as  
the channel they were created on, or until the client cancels them.    

The Stream.Consume method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- queue (shortstr) - queue name. Specifies the name of the queue to    
  consume from. If the queue name is null, refers to the current queue 
  for the channel, which is the last declared queue. The queue name    
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- consumer_tag (shortstr) - consumer tag. Specifies the identifier for 
  the consumer. The consumer tag is local to a connection, so two      
  clients can use the same consumer tags. If this field is empty the   
  server will generate a unique tag. Identifier for the consumer, valid
  within the current connection.                                       
- no_local (bit) - do not deliver own messages. If the no-local field  
  is set the server will not send messages to the client that published
  them.                                                                
- exclusive (bit) - request exclusive access. Request exclusive    
  consumer access, meaning only this consumer can access the queue.
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Stream_consume_nowait Command
--------------------------------

The &lt;stream_consume_nowait&gt; command (start a queue consumer):

    &lt;stream_consume_nowait
        [ ticket = "access ticket granted by server" ]
        [ queue = "queue name" ]
        [ consumer_tag = "consumer tag" ]
        [ no_local = "do not deliver own messages" ]
        [ exclusive = "request exclusive access" ]
    /&gt;

This method asks the server to start a "consumer", which is a transient
request for messages from a specific queue. Consumers last as long as  
the channel they were created on, or until the client cancels them.    

The Stream.Consume method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- queue (shortstr) - queue name. Specifies the name of the queue to    
  consume from. If the queue name is null, refers to the current queue 
  for the channel, which is the last declared queue. The queue name    
  identifies the queue within the vhost. Queue names may consist of any
  mixture of digits, letters, and underscores.                         
- consumer_tag (shortstr) - consumer tag. Specifies the identifier for 
  the consumer. The consumer tag is local to a connection, so two      
  clients can use the same consumer tags. If this field is empty the   
  server will generate a unique tag. Identifier for the consumer, valid
  within the current connection.                                       
- no_local (bit) - do not deliver own messages. If the no-local field  
  is set the server will not send messages to the client that published
  them.                                                                
- exclusive (bit) - request exclusive access. Request exclusive    
  consumer access, meaning only this consumer can access the queue.
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Stream_cancel Command
--------------------------------

The &lt;stream_cancel&gt; command (end a queue consumer):

    &lt;stream_cancel
        [ consumer_tag = "consumer tag" ]
    /&gt;

This method cancels a consumer. Since message delivery is asynchronous
the client may continue to receive messages for a short while after   
canceling a consumer. It may process or discard these as appropriate. 

The Stream.Cancel method accepts the following arguments:
- consumer_tag (shortstr) - consumer tag. Identifier for the consumer,
  valid within the current connection.                                
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Stream_cancel_nowait Command
--------------------------------

The &lt;stream_cancel_nowait&gt; command (end a queue consumer):

    &lt;stream_cancel_nowait
        [ consumer_tag = "consumer tag" ]
    /&gt;

This method cancels a consumer. Since message delivery is asynchronous
the client may continue to receive messages for a short while after   
canceling a consumer. It may process or discard these as appropriate. 

The Stream.Cancel method accepts the following arguments:
- consumer_tag (shortstr) - consumer tag. Identifier for the consumer,
  valid within the current connection.                                
- nowait (bit) - do not send a reply method. If set, the server will 
  not respond to the method. The client should not wait for a reply  
  method. If the server could not complete the method it will raise a
  channel or connection exception.                                   

The Stream_publish Command
--------------------------------

The &lt;stream_publish&gt; command (publish a message):

    &lt;stream_publish
        [ content = "content buffer to transfer" ]
        [ ticket = "access ticket granted by server" ]
        [ exchange = "exchange name" ]
        [ routing_key = "Message routing key" ]
        [ mandatory = "indicate mandatory routing" ]
        [ immediate = "request immediate delivery" ]
    /&gt;

This method publishes a message to a specific exchange. The message  
will be routed to queues as defined by the exchange configuration and
distributed to any active consumers as appropriate.                  

The Stream.Publish method accepts the following arguments:
- ticket (short) - access ticket granted by server. An access ticket
  granted by the server for a certain set of access rights within a 
  specific realm. Access tickets are valid within the channel where 
  they were created, and expire when the channel closes.            
- exchange (shortstr) - exchange name. Specifies the name of the     
  exchange to publish to. The exchange name can be empty, meaning the
  default exchange. If the exchange name is specified, and that      
  exchange does not exist, the server will raise a channel exception.
  The exchange name is a client-selected string that identifies the  
  exchange for publish methods. Exchange names may consist of any    
  mixture of digits, letters, and underscores. Exchange names are    
  scoped by the virtual host.                                        
- routing_key (shortstr) - Message routing key. Specifies the routing
  key for the message. The routing key is used for routing messages  
  depending on the exchange configuration.                           
- mandatory (bit) - indicate mandatory routing. This flag tells the    
  server how to react if the message cannot be routed to a queue. If   
  this flag is set, the server will return an unroutable message with a
  Return method. If this flag is zero, the server silently drops the   
  message.                                                             
- immediate (bit) - request immediate delivery. This flag tells the    
  server how to react if the message cannot be routed to a queue       
  consumer immediately. If this flag is set, the server will return an 
  undeliverable message with a Return method. If this flag is zero, the
  server will queue the message, but with no guarantee that it will    
  ever be consumed.                                                    

The Tx_select Command
--------------------------------

The &lt;tx_select&gt; command (select standard transaction mode):

    &lt;tx_select
    /&gt;

This method sets the channel to use standard transactions. The client  
must use this method at least once on a channel before using the Commit
or Rollback methods.                                                   

The Tx_commit Command
--------------------------------

The &lt;tx_commit&gt; command (commit the current transaction):

    &lt;tx_commit
    /&gt;

This method commits all messages published and acknowledged in the
current transaction. A new transaction starts immediately after a 
commit.                                                           

The Tx_rollback Command
--------------------------------

The &lt;tx_rollback&gt; command (abandon the current transaction):

    &lt;tx_rollback
    /&gt;

This method abandons all messages published and acknowledged in the
current transaction. A new transaction starts immediately after a  
rollback.                                                          

The Dtx_select Command
--------------------------------

The &lt;dtx_select&gt; command (select standard transaction mode):

    &lt;dtx_select
    /&gt;

This method sets the channel to use distributed transactions. The      
client must use this method at least once on a channel before using the
Start method.                                                          

The Dtx_start Command
--------------------------------

The &lt;dtx_start&gt; command (start a new distributed transaction):

    &lt;dtx_start
        [ dtx_identifier = "transaction identifier" ]
    /&gt;

This method starts a new distributed transaction. This must be the 
first method on a new channel that uses the distributed transaction
mode, before any methods that publish or consume messages.         

The Dtx.Start method accepts the following arguments:
- dtx_identifier (shortstr) - transaction identifier. The distributed
  transaction key. This identifies the transaction so that the AMQP  
  server can coordinate with the distributed transaction coordinator.

The Tunnel_request Command
--------------------------------

The &lt;tunnel_request&gt; command (sends a tunnelled method):

    &lt;tunnel_request
        [ content = "content buffer to transfer" ]
    /&gt;

This method tunnels a block of binary data, which can be an encoded  
AMQP method or other data. The binary data is sent as the content for
the Tunnel.Request method.                                           

The Tunnel.Request method accepts the following arguments:
- meta_data (table) - meta data for the tunnelled block. This field   
  table holds arbitrary meta-data that the sender needs to pass to the
  recipient.                                                          

PAL Implementations
*******************

The ANSI C PAL Implementation
=============================

Command-Line Arguments
----------------------

The standard C implementation creates a command-line program that accepts
these arguments:

    Syntax: program [options...]
    Options:
      -s server        Server:port to connect to (localhost)
      -t level         Set trace level (default = 0)
                       0=none, 1=low, 2=medium, 3=high
      -r count         Repeat script count times, 0=forever (1)
      -c               Clock the script (0)
      -a               Animate: show script commands
      -e               Execute in single-step mode (0)
      -q               Quiet mode: no messages
      -v               Show version information
      -h               Show summary of command-line options

    The order of arguments is not important. Switches and filenames
    are case sensitive. See documentation for detailed information.

Performance Measurements
------------------------

The -c option clocks the script and produces performance measurement
output.  Here is an example of a simple stress test script:

    &lt;?xml?&gt;
    &lt;pal
        name = "stress"
        script = "amq_pal_gen"
        &gt;
        This script sends a large number of messages to a queue and then
        reads them back.  The number of messages can be specified on the
        command-line.
        &lt;session exchange = "myexchange" queue = "myqueue" &gt;
            &lt;set name = "number-of-messages" cmdline = "N" value = "1000" /&gt;
            &lt;set name = "message-size" cmdline = "S" value = "1000" /&gt;
            &lt;exchange_declare type = "fanout" /&gt;
            &lt;queue_declare /&gt;
            &lt;queue_bind /&gt;
            &lt;repeat times = "$number-of-messages" counter = "index" progress = "100"&gt;
                &lt;basic_content size = "$message-size" message_id = "id-$index" /&gt;
                &lt;basic_publish routing_key = "myqueue" /&gt;
            &lt;/repeat&gt;
            &lt;while name = "arrived" test = "lt" value = "$number-of-messages" progress = "100"&gt;
                &lt;basic_get /&gt;
                &lt;basic_arrived&gt;
                    &lt;inc name = "arrived" /&gt;
                &lt;/basic_arrived&gt;
            &lt;/while&gt;
        &lt;/session&gt;
    &lt;/pal&gt;

Which produces this output (the figures are obviously just an example):

    ...........
    ...........
    16:41:26: I: elapsed time:781 msecs
    16:41:26: I: outgoing messages:1000 (976 Kbytes)
    16:41:26: I: incoming messages:1000 (976 Kbytes)
    16:41:26: I: total messages:2000 (1952 Kbytes) average:2560/sec (2499 Kbytes/sec)
    16:41:26: I: message latency min=280 max=410 mean=331 dev=37 msecs

Other Implementations
=====================

There are no other implementations of PAL at present.

PAL Internals
*************

Terminology
===========

ASL:
    Abstract Server Language - an iMatix technology for defining
    protocols and building clients and servers that implement such
    protocols.  ASL is a language, a set of protocol standards, and
    a set of tools. ASL is itself constructed using XNF.
XNF:
    XML Normal Form - an iMatix technology for defining XML grammars
    and building code generators that implement such grammars. XNF
    is a language, and a set of tools.  XNF is constructed using XNF.
    The key point of XNF is to generate a full validating and
    denormalising parser and to couple this with hand-written
    back-end code generators (aka "targets").
GSL:
    Generator Scripting Lanuage - an iMatix technology used to build
    code generators.  GSL is a scripting language designed to work
    with tree-structured data (usually XML) and inject this data into
    a template-driven code generation process.  All iMatix code
    generators are written in GSL, and most are complex enough to
    benefit from being constructed using XNF.
PAL:
    Protocol Automation Language - an iMatix technology for writing
    scripts to automate the client half of a discussion carried out
    in a protocol built with ASL.  PAL is a add-on to ASL.
Session:
    Another name for "channel".  We use "channel" at the protocol
    level and "session" at the API level, mainly because "session"
    maps to existing APIs like JMS, while "channel" is common usage
    for multiplexing networking protocols such as ours.

ASL Refresher
=============

iMatix ASL - the Abstract Server Language - is a protocol and
software-construction toolkit we built in order to help develop OpenAMQ.
The concept of ASL is loosely based on the concept of formal grammars
such as ASN.1, but in typical iMatix fashion is rather more aggressive
in aiming to generate high-quality code and documentation.

ASL is a formal language, a grammar.  It does not define the low-level
wire-protocol but rather the higher-level language that a protocol
carries.  We describe this language in terms of "methods", grouped
into "classes".  The specific technology used to carry these methods
depends on the specific implementation.  Thus, ASL is abstract.

ASL is an extensible framework - a single ASL grammar can be fed to any
number of different back-end "targets", each generating some different
output.  Today we have targets for:

 - A Standard C implementation of client and server layers.
 - A Java implementation of client layers.
 - Documentation in iMatix gurudoc format.

This diagram shows the overall ASL code generation process:

     .----------------.
     |  ASL grammar   |         ASL grammar written as XML files, using
     | for protocol P |         inheritence and other XNF techniques.
     `----------------'
             :
    +------------------+
    |  ASL front-end   |        GSL parser, generated from asl.xnf.
    |      parser      |        using the iMatix XNF toolkit.
    +------------------+
             : 
     .----------------.
     |  Denormalised, |         Data structure held in memory.
     | validated tree |
     `----------------'
             :
    +------------------+
    |     Specific     |        GSL code generator, written by hand.
    |  back-end target |
    +------------------+
             :
     .----------------.
     | Generated text |         Documentation or code as desired.
     |    outputs     |         
     `----------------'

We can summarise the approach that drives ASL:

  1. Define an abstract and high-level syntax capable of supporting the
     full functionality required by all possible protocols in our domain.

  2. Implement the code generators for this abstract syntax.

  3. Use the syntax to define our full protocol.
  
Note the major benefit of using ASL: writing a large and rich protocol
is very cheap, as 100% of the protocol support both at the client and
server side is generated, leaving only the functional implementation of
the protocol methods as work for the programmer.

Large-scale Testing
===================

By making it cheap to design and implement functionality on top of a
standard technical base, ASL also encourages very large and explicit
protocols. While a hand-built protocol might use a single method for
several purposes, ASL would encourage the definition of several
individual methods. This clarity is very pleasant for the application
developer, but it means that testing must also happen on a large scale.

This - cheap large-scale testing - is the problem that PAL solves.

The PAL Architecture
====================

These diagrams show how PAL fits into the toolchain. First, the process
of constructing a PAL generator for a particular protocol, 'P':

          .----------------.
          |  ASL grammar   |         ASL grammar written as XML files, using
          |    "p.asl"     |         inheritence and other XNF techniques.
          `----------------'
                  :
         +------------------+
         |  ASL front-end   |        GSL parser, generated from asl.xnf.
         |      parser      |        using the iMatix XNF toolkit.
         |  "asl_gen.gsl"   |
         +------------------+
                  : 
          .----------------.
          |  Denormalised, |         Data structure held in memory.
          | validated tree |
          `----------------'
                  :
         +------------------+
         |       PAL        |        GSL code generator, hand-made.
         |  back-end target |
         |   "asl_pal.gsl"  |        
         +------------------+
            :           :
    +-----------+   +-----------+
    |  PAL XNF  |   |  PAL stdc |    GSL code generators, hand-made
    |  driver   |   |   driver  |    
    +-----------+   +-----------+
          :               :
    .-----------.         :
    |   PAL/P   |         :          XNF grammar of PAL language
    |  grammar  |         :          specifically for protocol 'P'
    `-----------'         :         
          :               :
    .-----------.   .-----------.
    | front-end |   |   stdc    |    Components of a PAL generator
    | for PAL/P |   |  target   |    specifically for protocol 'P'
    `-----------'   `-----------'
    
To illustrate, these are the commands that would be used to perform the
above chain, for a protocol named 'P':

    gsl -target:pal p.asl
    gsl p_pal.xnf
        
Second, the process of turning a PAL script into executable code:

     .----------------.
     |  PAL/P script  |         PAL script written as XML files, using
     |  "example.pal" |         include and other XNF techniques.
     `----------------'
             :
    +------------------+
    |  PAL/P front-end |        GSL parser, generated from p.asl
    |      parser      |        (see previous diagram).
    | "p_pal_gen.gsl"  |        
    +------------------+
             : 
     .----------------.
     |  Denormalised, |         Data structure held in memory.
     | validated tree |
     `----------------'
             :
    +------------------+
    |       stdc       |        GSL code generator, generated from
    |  back-end target |        p.asl (see previous diagram).
    | "p_pal_stdc.gsl" |
    +------------------+
             :
     .----------------.
     |  Source code   |         Generated C test program.
     |  "example.c"   |
     `----------------'

To illustrate, these are the commands that would be used to perform the
above chain, for a script called "example":

    gsl example.pal

The resulting test program is compiled and linked as usual.

</content>
</page>
