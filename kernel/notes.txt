Potential write issues

References
    - object_new -> object ptr
    - object new r -> object
    - no way to get a ref from an object
    - object_ref_dup -> new ref, replaces link
    - object_ref_destroy -> destroy ref and/or object
    - object_ref_stop -> stop the object
    - object_destroy -> stop the object

patterns
    - simple use:
        handle = object_new ()
        object_destroy (&handle)

    - shared use:
        ref = object_ref_new ()
        async call
            possess:
                ref = object_ref_dup (ref)
            release:
                object_ref_destroy (&ref)
        ...
        object_ref_destroy (&ref)

toto
    - finish log disabling
        - always create log objects
        - open output
        
Changes 7/3
    - force reference to consumer->channel->connection
        - should move unlinks to free so they are always valid
        - double-check for linked objects
    - amq_console uses new object store format

Changes 2/3
    - show console amounts in Kb
    - console figures, format with suffix ("K") etc
    - bindings correctly cleaned-up when queues deleted
    - PAL extended to show interim timer values

Changes 28/2
    - setting the 'exclusive' flag always implies 'auto-delete'
    - changed binding create to use hash lookup (faster creation)
    - regexps are cached in method validation (performance)
    - changed amq_binding_list back to old model (iterator model nfg)

Changes 25/2
    - trace_queue,route,cluster -> debug_queue, etc.
    - changed user 'type' to 'group'
    - added 'super' user group, not restricted in server
    - log files cycled at end of day (before midnight LT)
    - added queue profiles in server.cfg
    - implemented queue limit features (warn/drop/trim implemented, not kill)
    - increased server listen queue size from 5 to 500 (clients were failing to connect)
    - fixed error in processing of immediate messages
    - discards/returns undeliverable messages if all consumers mismatch

Change requests
    - console default is read-only, need option to make writeable
    - add ipaddress rdns in console (ipr_net?)
    - console should use hash table to store objects, not array
    - better messages for each item, can/not be modified at runtime
    - get monitor and trace working dynamically from console

Protocol todo
    - remove prefetch max from asl_channel
    - remove vhost concept (?)
    - corrections vs. comments from Iona
    
Todo
    - server restart still failing
    - change monitor values still failing
    - set mem from config/cmdline
        - start with direct, load, throw-away & restart
    - split config options into basic, advanced
    - console rule on ip address -> amq_shell does RDNS

per_client
    - limit defined in config
    - current value held in connection
    - when message queued on exclusive queue
        - per_client is incremented
    - when message dequeued off exclusive queue
        - per_client is decremented
    -> when we destroy a queue, how do we know if the
        connection is still alive, linked?

logging
    - callback on log file
    - send alerts to system exchange
    - amq-shell mode to monitor all alerts
    
statistics to keep
    - traffic per exchange, per queue
        - in, out
        - throughput, using meters
    - 
    
- multilevel config
    - e.g. user names, groups
    - we can do this using objects...
    - amq_user, amq_group

amq_shell
- show queues by number of messages
    - general sort by option?
- show page by page, with more option
- config save, only items that are not default
- select item by name, 'vhost /' -> first matching prefix
- execute from command line

- broker
    - dropped messages

    structure properties?
    general
    traffic
    statistics
    


amq_shell could become sysman
    - stop cluster brokers
    - connect to them
    - wizard for cluster configuration
    - etc.
    - using virtual cmdline objects...


logging
    access
    error
    console
    discard
    log level
    log fields?


OpenAMQ Logging System
======================


icl_set_allocator
smt_set_max_os_thread
smt_set_action_allocator

amq_shell
    configurable
        - name/pass


openamq chip
    ... snapshot of openamq.org...
    
    - presentation
        - example use cases
        - functionality
        - technical design
        - main features
            - pub/sub
            - amq implementation
            - exchanges
            - limits
            - capacity
            - self-regulation
            - installation
            - configuration
            - remote administration
            - security
            - clustering
            - logging
            - reporting
                - log file analysis?
                - statistics collection
            - performance
                - tuning
            - portability
            - WireAPI
        - standards organisation
        - support organisation
        - partners & supported products
        - contact model
    - screenshots
        - web gui
        - server
        - shell
        - performance graphs
        - statistics

    - pdf whitepapers, reports
        - conformance test results
        - performance & tuning
        - technical implementation
    - binaries 1.0cn
        - win32, solaris, linux
        - packages with notes
    - source code
        - packages
        - howto build
    - sample applications
        - chat
        - file transfer
        - trivial application framework (taf)
    - documentation, html & pdf
        - WireAPI specs
        - PAL user guide
        - Clustering guide
        - Console technical specs
        - Server handbook
    - technical reference material
        


Fixes
    - Error in console caused server to abort (reference to destroyed object).
    - Console was not checking that client used reply-to - fixed.


AMQP USPs
    Wire level protocol
    Carries opaque binary packages
    Any size from 0 to 2e64 bytes
    Rapid binary protocol
    Powerful routing architecture
    Widely-backed standard
    Vendor, system neutral
    
    
OpenAMQ USPs
    WireAPIs in C, C++, Java, Perl, Python
    JMS, COM APIs
    Fast, robust server
    Excellent performance and scaling
    Portable to all platforms
    Zero-configuration server

Missing
    Secure authentication and transport
    Persistent messages
    
    




amq bridging
    - create server-to-server bridge
    - or cluster-to-cluster bridge
    - explicit in the protocol...
    - new Bridge method class
    - a bridge is an asynchronous link
    - bridges can auto-connect across WANs

    Mechanism:
        C: Bridge.Create host, exchange, routing_key, arguments
        S: Bridge.Create-Ok        

    Server looks for host, and opens proxy connection to host:
        - creates queue on host or uses named bridge queue
        - binds queue to exchange using specified arguments
        - creates consumer on that queue
        - expects and processes delivered messages
        - each incoming delivery is passed to own exchange with same name

    Alternative:
        - acts as proxy consumer on remote shared queue
        - not passed to own exchange but directly to application

    Details
        - a bridge is a logical layer, and many bridges can be opened
          at once, each for a specific subscription request.
        
    Optional functionality
        - durable bridges (recreated when servers restart)
        - configured bridges (idem)
        - async pull bridges (recreated when host comes online)
        
    Ideal for SA:
        - cluster in SA
        - bridged to cluster in London

    ... very close to clustering.
    ... but under application control.
    ... can we imagine cluster being constructed by applications?
    ... ? no.


********************************************************************

- build simple queued file transfer application
- gigabyte files
    -> undoable in activemq
    - transfer all files from folder
    - receive files into folder...
    - run script when receiving file

    -> can this be done in PAL?
    -> sample applications...
    -> also in C
    -> ascii conversion? ipr_write...?

- finish pal tests
- swig yes
- .net no
- server doc yes
- website yes
- sample apps yes (file transfer, work distribution)
- transactional storage
    - on memory, yes
    - external storage api
        - sqlite
- clustering yes
- queue declare properties
    - durability
    - persistence
    - max size
    - handle overflow
    - deadlettering


********************************************************************

The 'Watch' Method
------------------

The system exchange is responsible for monitoring watches.  It does
this by maintaining a list of watches and checking each one after
some regular interval - e.g. every 30 seconds.  It asks the watched
object to provide its properties ("inspect"), checks the properties
and if they hit the watch limit, sends an alert.

Once watch has provoked an alert, the system exchange will suppress
successive alerts unless there is significant variance - e.g. 5%.

In the OpenAMQ server, requests are handled by the standard system
exchange "amq.console". Responses are sent to a temporary reply queue
created by the console interface layer.

Asynchronous information - alerts - are sent to the amq.console.alert
exchange, and console interface layer(s) get these alerts using a
pub/sub model. Alerts are published with a topic-style routing key that
allows selective subscription to specific types of alert.


---- TEST HARNESS

    - proxy
        - asl agent
        - listens on specified port
        - can be disabled - port = 0
        - reconnects to main server port
        - logs traffic

    - standard ASL component
    - built-in to amq_server
    - runs on separate port
    - handles multiple simultaneous connections
    - record mode
        - opens local server port to main protocol
        - passes data to/from clients
        - records session (start to finish)
    - replay mode
        - replays session (start to finish)
        - maintains order of request response
            - write X bytes
            - expect Y bytes
            - etc.
    - tool to generate test clients
        - documentation at start, what is the test case?
        - ability to stop/start child processes
            - monitor crashes
            - exit status
---- TODO

    - consumer filters
        - act to divert messages to another queue
        - not copy, that would be done by binding to exchange
        - consume on queue X, with params...
            

    - durable definitions
        - exchanges, queues...
    - consumer windowing
        - part of transaction management

    - store content header without parsing
        - parse certain items
            - weight, size, class.
        - store content header in content without parsing it
        - replay from stored block
        - if needed for matching,
            - decode it
            - define methods to do this easily...
            - decode once -> content
            - then access content fields
            - headers -> field list
                -> decode automatically
                -> destroy at end...

    - define reply-to as URL:
        amqp://servername:port/exchange/destination

---- BASE

    - boom install history in $IBASE/install
        - allows uninstall
        - cummulative per project
    - gsl elastic spaces should compress down to 1, not 2 spaces
    - separate the ignorecase option into two options
        - a. to allow case-insensitive symbol names
        - b1. to mangle symbol values when names are UPPER or Mixed case
        - b2. to mangle symbol names in all cases
    - icl code generation has become really messy
        - blank lines
        - indentation
    - icl
        - coverage check for methods
        - run test cases, accumulate statistics
        - check against code
    - smt
        - socket output buffering and flushing
        - socket input buffering
        - can't group actions in grouped actions
        - loses/delays socket_error when heavily used
           - e.g. disconnection trapped only when next client connects
        - check multithreaded usage of objects
    

