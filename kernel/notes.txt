---- DONE


    Daisy-chaining exchanges

    e.g. combine topic plus header filter

    - top-level exchange is $topic
    - secondary exchange is $match
    - bind $match to $topic
        - using destination pattern
    - declare queue
        - scope = subscription
    - bind queue to $match
        - using header specification

    > destination pattern
    > header specification

    e.g. just topic (no header filter)

    - top-level exchange is $topic
    - declare queue
        - scope = subscription
    - bind queue to $topic
        - using destination pattern

    > destination pattern

    e.g. combine selector plus topics

    - top-level exchange is $topic
    - secondary exchange is $select
    - bind $select to $topic
        - using destination pattern
    - declare queue
        - scope = subscription
    - bind queue to $select
        - using selector string

    e.g. combine lossy with topic
    
    - top-level exchange is $topic
    - secondary exchange is $lossy
    - bind $lossy to $topic
        - using destination pattern
    - declare queue
        - scope = queue
    - bind queue to $lossy
        - using loss criteria



---- TODO

    - exclusive consumers
    
    - store content header without parsing
        - parse certain items
            - weight, size, class.
        - store content header in content without parsing it
        - replay from stored block
        - if needed for matching,
            - decode it
            - define methods to do this easily...
            - decode once -> content
            - then access content fields
            - headers -> field list
                -> decode automatically
                -> destroy at end...


    - unify queue domain and template concepts
        - domains are predefined
        - domains provide default properties
            - exchange to bind to
            - private, auto-delete, etc.
        - rename "auto-delete" to "temporary"?

    - define reply-to as URL:
        amqp://servername:port/exchange/destination

---- PROXY

    - standard ASL component
    - built-in to amq_server
    - runs on separate port
    - handles multiple simultaneous connections
    - record mode
        - opens local server port to main protocol
        - passes data to/from clients
        - records session (start to finish)
    - replay mode
        - replays session (start to finish)
        - maintains order of request response
            - write X bytes
            - expect Y bytes
            - etc.
    - tool to generate test clients
        - standard set of options for all test programs
        - define methods wanted as XML program
            - methods plus arguments
        - repetitions as loops
        - success/failure for each method?
        - documentation at start, what is the test case?
        - ability to stop/start child processes
            - monitor crashes
            - exit status
        - need server control facilities
            - STOP command
            - RESTART command
            - send to $system exchange...
            - server command line option to enable this...
        - wait
        - random
        ... fully abstract, no C code!
        ... generate test sets in Perl, C, etc.
        ... forms part of formal protocol specifications
    - part of asl...

---- FOR 1.0

    - routing information in contents
        - exchange (currently root, should be list)
        - destination
        - producer_id (for no_local, and bounces)
        - mandatory, immediate flags (currently as method options)

---- POST-1.0

    - clarify protocol for aborting single large message
        - send large message via dialog
        - read incoming data while sending outgoing
        - abort send with empty body, if Jms.Reject or Browse.Reject sent
            - can this be done in asl?

---- BUGS

    icl:
        2005/08/30
        - error in fat memory manager
        = FIXED
        
    smt:
        2005/08/30
        - if server dies while client is writing, client fails with assert
        
        2005/08/30
        - agent does not shutdown cleanly if interrupted during wait
            - result is leaking connections in server
            - if killed while waiting for client context timeout
            - (cannot kill connections at thread destruction, used to do that
               but it fails since channels are async objects.)
    

--- TEST CASES

    MESSAGES EN ROUTE
    - create queue
    - send messages to queue
    - consume one message
    - abort connection
    - stop server
        ... messages will have been queued for consumer, must be freed

    NO CANCEL FOR CONSUMER
    - create consumer
    - close connection


--- WORLDVIEW

    Reflected in the documentation and in the product.

    Automatic Mode
        - default virtual host
        - queue and topic exchanges
        - $system exchanges
        - auto-binding for queues
            - queue templates: normal, temporary, subscription
    Advanced Mode
        - custom virtual host
        - define own exchanges
        - header-based routing
        .etc

    Creating automode
        - can be hard-coded in server
            - create destinations
            - create queue templates
            + can't be broken
            - can't be modified
            - more costly to improve later
        - can be scripted
            - run start-up script to create vhosts, etc
            + harder to modify but still possible
        - can be configured
            - configuration is just set of durable objects
            + most generic
            - can be broken
            - would need "reset" functionality


Some ideas
    - create vhost dynamically, (copy existing vhost?)
        - predefined vhost = standard wiring
    - allow operations on vhost and all wiring
        - copy from
        - delete
        - reset / empty
        - save / restore
    - documentation should cover lifetime of objects
        - exchanges
        - queues
        - bindings
        - consumers
        - messages
    - purge/timeout auto-delete queues

----------------------------------------------------------------------------


- minimum required for GRM
    - JMS class
*        consume, consume-ok
*        cancel, cancel-ok
*        publish / immediate
*        deliver
    - exchange classes
*        topic
*        headers
    - queue:
*        jms messages, no priority, no persistence
    - queue templating
        basics only - queue max. size?
*    - fanout, queue, dest-wild, property exchanges
     - jms consumers
*        - preconfigured exchanges
        - queue, cbr

---- DOCUMENTATION

    - write/double-check test methods for all classes - icl, ipr, smt, asl, amq
    - add 'domain' concept to icl
    - redefine all context blocks using domains
    - define documentation domains (user, tech, etc.)
    - write/check documentation for all classes

---- BASE

    - boom install history in $IBASE/install
        - allows uninstall
        - cummulative per project
    - gsl elastic spaces should compress down to 1, not 2 spaces
    - separate the ignorecase option into two options
        - a. to allow case-insensitive symbol names
        - b1. to mangle symbol values when names are UPPER or Mixed case
        - b2. to mangle symbol names in all cases
    - icl code generation has become really messy
        - blank lines
        - indentation
    - icl
        - coverage check for methods
        - run test cases, accumulate statistics
        - check against code
    - smt
        - socket output buffering and flushing
        - socket input buffering
        - can't group actions in grouped actions
        - loses/delays socket_error when heavily used
           - e.g. disconnection trapped only when next client connects

---- SMT links HOWTO

    - if you get a reference from a container
        - either unlink it
        - or destroy it
        - or get a next reference
    - if you pass a reference via a call
        - synch call: do nothing
        - asynch call: link to it on behalf of called
        - called asynch method: unlink or destroy it
    - if you store a reference anywhere
        - link when storing the reference
        - unlink when finished with the reference
    - do not link to parent object
        - hierarchy of creation/destruction

---- HASH HOWTO

    - don't manipulate self->key
        - provide real key at insertion
        - don't use self->key after removal...
        - rename to _key?

---- CLUSTERS

    a. for resiliency (failure)
        - using master-slave model
        - possibly hierarchical model
    b. for load-balancing
        - using multi-master model
        - possibly hierarchical model
    c. for geographical distribution
        - using other means

    - client connects to server
    - server can kick client, with 'reconnect to different server'
    - server provides list of known alternative servers
        - masters and backups
    - client may try servers randomly/serially
        - this is for load-balancing
    - client can connect with 'please don't kick me'
        - if it was already working with that server

    master-slave:
        - agressive heartbeating allows slave to monitor master & vv
        - various strategies for replication
            - repeat all AMQP commands to slave
                - get confirmation before doing own processing thereof
            - repeat internal structures to slave
                - all created objects replicate themselves
            - repeat only stored data
                - messages, subscriptions

---- AUTOBUILD

    check bootstrap
    - download, build, install bootstrap packages
    >> every 4 hours

    check repository trunks
    - check out svn trunk into fresh tree
    - build each product and project
    - run project unit tests
    - run project coverage checks
    - run product/project regression tests
    - run performance tests & report results
    >> every hour, signal failure or recovery
    >> for multiple configurations
        - each with name and environment settings
        - e.g. st, mt, stat, etc.
            openamq_1.0b2_win32_mtd.exe

    build package
    - build source package (snapshot or release)
    - build binary packages
    - update web site for latest build
    - upload source package and web site
    >> automatic daily snapshot, manual planned release

    build bootstrap
    - build and upload bootstrap package
    >> when repository trunk build successful

    - write in Perl

---- PACKAGING

    - Unix
        -> source packages and configure/make
        - configure includes all build options
    - win32
        -> source packages and configure/make
        - configure includes all build options
        -> binary packages
            - using win32 installer
            - including configuration
            - control panel application
    - other
        -> debian packages?
        -> very version dependent...
