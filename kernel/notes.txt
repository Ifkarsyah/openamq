
Protocol documentation

1. Functional Requirements
    functional = what 
    everything we want to be able to do
    worked examples

2. Technical Requirements
    technical = how 
    performance
    portability
    longevity
    interoperability
    clarity
    extensibility

3. Proposed Architecture
    the functional layer
    routing exchange and queues
    the technical layer
    channels etc.

4. The Technical Layer 
    technical objects & lifecycle
    framing layers
    content encoding
    limitations
    how connections work
    negotiation
    multichannels
    tokenisation

5. The Functional Layer
    functional objects & lifecycle
    all functional commands
    regression tests
    

    

basic protocol rules
    - any property needed for interop is named & standard
    - anything else is allowed, extensible x-, X-
        - server warns but ignores unsupported non-standard properties
    - we aim to support full configuration & changeable
        via the protocol
        every entity and attribute of the vhost
    - watching the server is console's job

    - how to extend
        - write own exchange
        - send arbitrary messages to exchange
    



todo
    - need to review test sets
    - clarify and legible
        -> they are not readable at present
        -> work through with team
        -> explain how to make them readable
    - need smaller unit tests
        -> test number xxx does yyy
        -> index, well-defined functionality
        -> 100+ tests

AMQwg
    - active members
    - passive members
    - banks, vendors

Powerpointy stuff
    - vision of amqp becoming ubiquitous
    - easy examples in PAL
    - nice scenarios


General rule for handling issues

1. Bug process
    - describe the problem
    - localise the layer
        - platform dependent? (5%)
        - build dependent? (15%)
        - functional scenario? (85%)
    - reproduce it consistently
        - specific test case if needed
    - assign to the developer
        - on basis of test case
    - fix the problem
        - in vitro
    - confirm the fix
        - in vitro
        - in veritas

2. Change process
    - describe the requirement
        - _not_ the solution!
    - assign to the developer
    - document
        - confirm the requirement
        - propose a solution
        - argumentation and alternatives
        - cost and planning
    - confirm
        - silence means consent
    - develop
        - solution
        - test cases
    - confirm
        - in vitro
        - in veritas
    

Console Schema

    console                 -
        broker              *
            vhost           *
                exchange    *
                queue       *
            connection      -
                consumer    -
        config
        
amq console
    broker
       \
        connection (ipaddress)
            \
           consumer (->queue)

1. rename existing amq_server_connection
    - make it an async object?


The 'Watch' Method
------------------

The system exchange is responsible for monitoring watches.  It does
this by maintaining a list of watches and checking each one after
some regular interval - e.g. every 30 seconds.  It asks the watched
object to provide its properties ("inspect"), checks the properties
and if they hit the watch limit, sends an alert.

Once watch has provoked an alert, the system exchange will suppress
successive alerts unless there is significant variance - e.g. 5%.

In the OpenAMQ server, requests are handled by the standard system
exchange "amq.console". Responses are sent to a temporary reply queue
created by the console interface layer.

Asynchronous information - alerts - are sent to the amq.console.alert
exchange, and console interface layer(s) get these alerts using a
pub/sub model. Alerts are published with a topic-style routing key that
allows selective subscription to specific types of alert.



Before sending methods to the server, the client creates a temporary private
queue for replies:

 - Queue.Declare, no name, private = 1, auto-delete = 1.

It then binds this queue to the amq.direct exchange:

 - Queue.Bind, queue=<provided name>, exchange=amq.direct,
   routing_key=<provided name>.



Destination URLs
    - Reply-To = destination/url
    - Not required to be parsed by client API

    - JMS mapping to AMQP commands
    - standard API functionality
    
Format:

    Full URL:
    
        amqp://server[:port]/vhpath/exchange/object/?arguments

    - object is single name (no path)
    - exchange is single name (no path)
    - vhost is all preceding names
    - arguments are optional
    
    Relative URL:
    
        exchange/object/?arguments

    Publisher

        exchange/name

    Consumer
    
        queue to declare, or empty
        exchange to bind to
        binding arguments, if simple
        - binding complex arguments?
        - consume arguments

        -> should destination include topic specifier?
        -> what is the point of this?
        -> what _are_ consumer destinations?

    jms.publish ("topic/balsh")
    jms.consume ("topic/mysubscr?where=*.ibm")
    jms.consume ("topic?where=*.ibm")
    jms.consume ("queue/myqueue")

    macro:
        - create unnamed queue
        - bind to exchange using arguments name/value pairs
        - create consumer on queue

    variation 1:
        - if named queue exists
            - verify binding arguments are consistent
        - else
            - create named queue
            - bind to exchange using arguments
        - create consumer on queue






    - queue type (rather than scope)


consume from url
    - if queue name is specified
        - create queue if not present
            - bind as specified
        - else assert bindings are the same
    - if queue name is not specified
        - create temporary queue
            - bind as specified
    - create consumer on queue

    /vhost/exchange/queue?topic=balsh


    jms.consume ("/topic/subscr?name=*.ibm")
    jms.publish ("/topic?name=balsh")
    



   amqp://server:port/vhpath/servicetype/values

- 


---- TEST HARNESS

    - proxy
        - asl agent
        - listens on specified port
        - can be disabled - port = 0
        - reconnects to main server port
        - logs traffic

    - standard ASL component
    - built-in to amq_server
    - runs on separate port
    - handles multiple simultaneous connections
    - record mode
        - opens local server port to main protocol
        - passes data to/from clients
        - records session (start to finish)
    - replay mode
        - replays session (start to finish)
        - maintains order of request response
            - write X bytes
            - expect Y bytes
            - etc.
    - tool to generate test clients
        - documentation at start, what is the test case?
        - ability to stop/start child processes
            - monitor crashes
            - exit status



---- TODO

    - consumer filters
        - act to divert messages to another queue
        - not copy, that would be done by binding to exchange
        - consume on queue X, with params...
            

    - durable definitions
        - exchanges, queues...
    - consumer windowing
        - part of transaction management

    - store content header without parsing
        - parse certain items
            - weight, size, class.
        - store content header in content without parsing it
        - replay from stored block
        - if needed for matching,
            - decode it
            - define methods to do this easily...
            - decode once -> content
            - then access content fields
            - headers -> field list
                -> decode automatically
                -> destroy at end...

    - unify queue domain and template concepts
        - domains are predefined
        - domains provide default properties
            - exchange to bind to
            - private, auto-delete, etc.
        - rename "auto-delete" to "temporary"?

    - define reply-to as URL:
        amqp://servername:port/exchange/destination

---- FOR 1.0

    - routing information in contents
        - exchange (currently root, should be list)
        - destination
        - producer_id (for no_local, and bounces)
        - mandatory, immediate flags (currently as method options)

---- POST-1.0

---- BUGS

--- TEST CASES

    MESSAGES EN ROUTE
    - create queue
    - send messages to queue
    - consume one message
    - abort connection
    - stop server
        ... messages will have been queued for consumer, must be freed

    NO CANCEL FOR CONSUMER
    - create consumer
    - close connection

    ---
    Client A creates private queue
    Client B attempts to consume from it
    ---
    Client A creates private queue
    Client A closes connection
    Assert that queue is destroyed
    ---
    Client A creates exclusive consumer
    Client A attempts to create second consumer
    ---


--- WORLDVIEW

    Reflected in the documentation and in the product.

    Automatic Mode
        - default virtual host
        - queue and topic exchanges
        - $system exchanges
        - auto-binding for queues
            - queue templates: normal, temporary, subscription
    Advanced Mode
        - custom virtual host
        - define own exchanges
        - header-based routing
        .etc

    Creating automode
        - can be hard-coded in server
            - create destinations
            - create queue templates
            + can't be broken
            - can't be modified
            - more costly to improve later
        - can be scripted
            - run start-up script to create vhosts, etc
            + harder to modify but still possible
        - can be configured
            - configuration is just set of durable objects
            + most generic
            - can be broken
            - would need "reset" functionality


Some ideas
    - create vhost dynamically, (copy existing vhost?)
        - predefined vhost = standard wiring
    - allow operations on vhost and all wiring
        - copy from
        - delete
        - reset / empty
        - save / restore
    - documentation should cover lifetime of objects
        - exchanges
        - queues
        - bindings
        - consumers
        - messages
    - purge/timeout auto-delete queues

----------------------------------------------------------------------------


---- DOCUMENTATION

    - write/double-check test methods for all classes - icl, ipr, smt, asl, amq
    - add 'domain' concept to icl
    - redefine all context blocks using domains
    - define documentation domains (user, tech, etc.)
    - write/check documentation for all classes

---- BASE

    - boom install history in $IBASE/install
        - allows uninstall
        - cummulative per project
    - gsl elastic spaces should compress down to 1, not 2 spaces
    - separate the ignorecase option into two options
        - a. to allow case-insensitive symbol names
        - b1. to mangle symbol values when names are UPPER or Mixed case
        - b2. to mangle symbol names in all cases
    - icl code generation has become really messy
        - blank lines
        - indentation
    - icl
        - coverage check for methods
        - run test cases, accumulate statistics
        - check against code
    - smt
        - socket output buffering and flushing
        - socket input buffering
        - can't group actions in grouped actions
        - loses/delays socket_error when heavily used
           - e.g. disconnection trapped only when next client connects

---- SMT links HOWTO

    - if you get a reference from a container
        - either unlink it
        - or destroy it
        - or get a next reference
    - if you pass a reference via a call
        - synch call: do nothing
        - asynch call: link to it on behalf of called
        - called asynch method: unlink or destroy it
    - if you store a reference anywhere
        - link when storing the reference
        - unlink when finished with the reference
    - do not link to parent object
        - hierarchy of creation/destruction
    - looseref to objects
        - when using, check if zombied and then unlink

---- HASH HOWTO

    - don't manipulate self->key
        - provide real key at insertion
        - don't use self->key after removal...
        - rename to _key?

---- CLUSTERS

    a. for resiliency (failure)
        - using master-slave model
        - possibly hierarchical model
    b. for load-balancing
        - using multi-master model
        - possibly hierarchical model
    c. for geographical distribution
        - using other means

    - client connects to server
    - server can kick client, with 'reconnect to different server'
    - server provides list of known alternative servers
        - masters and backups
    - client may try servers randomly/serially
        - this is for load-balancing
    - client can connect with 'please don't kick me'
        - if it was already working with that server

    master-slave:
        - agressive heartbeating allows slave to monitor master & vv
        - various strategies for replication
            - repeat all AMQP commands to slave
                - get confirmation before doing own processing thereof
            - repeat internal structures to slave
                - all created objects replicate themselves
            - repeat only stored data
                - messages, subscriptions

---- AUTOBUILD

    check bootstrap
    - download, build, install bootstrap packages
    >> every 4 hours

    check repository trunks
    - check out svn trunk into fresh tree
    - build each product and project
    - run project unit tests
    - run project coverage checks
    - run product/project regression tests
    - run performance tests & report results
    >> every hour, signal failure or recovery
    >> for multiple configurations
        - each with name and environment settings
        - e.g. st, mt, stat, etc.
            openamq_1.0b2_win32_mtd.exe

    build package
    - build source package (snapshot or release)
    - build binary packages
    - update web site for latest build
    - upload source package and web site
    >> automatic daily snapshot, manual planned release

    build bootstrap
    - build and upload bootstrap package
    >> when repository trunk build successful

    - write in Perl

---- PACKAGING

    - Unix
        -> source packages and configure/make
        - configure includes all build options
    - win32
        -> source packages and configure/make
        - configure includes all build options
        -> binary packages
            - using win32 installer
            - including configuration
            - control panel application
    - other
        -> debian packages?
        -> very version dependent...


