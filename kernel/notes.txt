

Object Registry
---------------

The system exchange maintains a registry of all active operable objects.
This is a tree structure, held in memory, with each node consisting of:

 - A reference to the object.
 - A pointer to the parent node.
 - The object's ID value.
 - A linked list of child objects (mixed and unordered).
 - A pointer to a class descriptor.

The class descriptor defines a single object type, e.g. "queue", and has
these properties:

 - Short name of class, e.g. "queue".
 - Callback address of 'meta' method.
 - Callback address of 'inspect' method.
 - Callback address of 'modify' method.

Class descriptors are created automatically when a specific class is
initialised - i.e. used for the first time. They never change during the
lifetime of the server.

The registry can do a lookup from object ID to registry node, so object
ID forms a primary key for accessing objects in the registry.

The 'Meta' Method
-----------------

The system exchange decodes the method, looks up the object class,
and sends this class the meta method.

The 'Inspect' Method
--------------------


When the system exchange receives an inspect method, it decodes the
XML to give the object to inspect. It sends a method to this object and
waits for a reply. It formats a reply XML sends the reply back to the
client (using the mechanism explained previously).

For simplicity, we do all XML encoding and decoding in the system
exchange only.  Data is passed between the system exchange and objects
in the form of field tables (the asl_field_list class).

The 'Modify' Method
-------------------

A modify method can apply changes to several objects. The system
exchange decodes the XML, and sends a modify method to each affected
object. It constructs a reply and sends this back to the client.

The 'Watch' Method
------------------

The system exchange is responsible for monitoring watches.  It does
this by maintaining a list of watches and checking each one after
some regular interval - e.g. every 30 seconds.  It asks the watched
object to provide its properties ("inspect"), checks the properties
and if they hit the watch limit, sends an alert.

Once watch has provoked an alert, the system exchange will suppress
successive alerts unless there is significant variance - e.g. 5%.




In the OpenAMQ server, requests are handled by the standard system
exchange "amq.console". Responses are sent to a temporary reply queue
created by the console interface layer.

Asynchronous information - alerts - are sent to the amq.console.alert
exchange, and console interface layer(s) get these alerts using a
pub/sub model. Alerts are published with a topic-style routing key that
allows selective subscription to specific types of alert.



Before sending methods to the server, the client creates a temporary private
queue for replies:

 - Queue.Declare, no name, private = 1, auto-delete = 1.

It then binds this queue to the amq.direct exchange:

 - Queue.Bind, queue=<provided name>, exchange=amq.direct,
   routing_key=<provided name>.



Destination URLs
    - Reply-To = destination/url
    - Not required to be parsed by client API

    - JMS mapping to AMQP commands
    - standard API functionality
    
Format:

    Full URL:
    
        amqp://server[:port]/vhpath/exchange/object/?arguments

    - object is single name (no path)
    - exchange is single name (no path)
    - vhost is all preceding names
    - arguments are optional
    
    Relative URL:
    
        exchange/object/?arguments

    Publisher

        exchange/name

    Consumer
    
        queue to declare, or empty
        exchange to bind to
        binding arguments, if simple
        - binding complex arguments?
        - consume arguments

        -> should destination include topic specifier?
        -> what is the point of this?
        -> what _are_ consumer destinations?

    jms.publish ("topic/balsh")
    jms.consume ("topic/mysubscr?where=*.ibm")
    jms.consume ("topic?where=*.ibm")
    jms.consume ("queue/myqueue")

    macro:
        - create unnamed queue
        - bind to exchange using arguments name/value pairs
        - create consumer on queue

    variation 1:
        - if named queue exists
            - verify binding arguments are consistent
        - else
            - create named queue
            - bind to exchange using arguments
        - create consumer on queue






    - queue type (rather than scope)


consume from url
    - if queue name is specified
        - create queue if not present
            - bind as specified
        - else assert bindings are the same
    - if queue name is not specified
        - create temporary queue
            - bind as specified
    - create consumer on queue

    /vhost/exchange/queue?topic=balsh


    jms.consume ("/topic/subscr?name=*.ibm")
    jms.publish ("/topic?name=balsh")
    



   amqp://server:port/vhpath/servicetype/values

- 


---- TEST HARNESS

    - generate xnf from protocol
        - hide internal commands
        - add control commands
    - virtual machine:
        - control commands
        - protocol methods
        - wait on synchronous methods
        - deliver content and bounces


    demo.asl
        -> demo_cl.xnf
        

    - proxy
        - asl agent
        - listens on specified port
        - can be disabled - port = 0
        - reconnects to main server port
        - logs traffic
    - xml language
        - connection, session control
        - class.method (args)
        - client instance control
        - loops and counters
        - grammar, part of asl...
            - or separate scripting language?
            - will need access to asl methods & classes


    - options
        - command-line
        - explanation
        - type (bool, string, int)
    - inheritance
        - overall wrappers
        - add own stuff
    - skeleton has own options
        - animate, etc.
    
    - standard ASL component
    - built-in to amq_server
    - runs on separate port
    - handles multiple simultaneous connections
    - record mode
        - opens local server port to main protocol
        - passes data to/from clients
        - records session (start to finish)
    - replay mode
        - replays session (start to finish)
        - maintains order of request response
            - write X bytes
            - expect Y bytes
            - etc.
    - tool to generate test clients
        - standard set of options for all test programs
        - define methods wanted as XML program
            - methods plus arguments
        - repetitions as loops
        - success/failure for each method?
        - documentation at start, what is the test case?
        - ability to stop/start child processes
            - monitor crashes
            - exit status
        - need server control facilities
            - STOP command
            - RESTART command
            - send to $system exchange...
            - server command line option to enable this...
        - wait
        - random
        ... fully abstract, no C code!
        ... generate test sets in Perl, C, etc.
        ... forms part of formal protocol specifications
    - part of asl...



---- TODO

    - consumer filters
        - act to divert messages to another queue
        - not copy, that would be done by binding to exchange
        - consume on queue X, with params...
            
    - single bounce
        - deliver option: don't care, at least one, all
        - bounce message: include name of failed queue
        - queue options for no consumers
            - bounce, discard, hold, 
            - overrides delivery option
        -> part of queue template?
        -> queue creation option?
        -> template = another queue?

        ... all attributes required for interoperability must be exposed
            in protocol so that they can be implemented in a standard way.

        ... other attributes required for tuning and/or administration can
            be hard-coded, set via config files, or via admin interface.


    - durable definitions
        - exchanges, queues...
    - consumer windowing
        - part of transaction management

    - store content header without parsing
        - parse certain items
            - weight, size, class.
        - store content header in content without parsing it
        - replay from stored block
        - if needed for matching,
            - decode it
            - define methods to do this easily...
            - decode once -> content
            - then access content fields
            - headers -> field list
                -> decode automatically
                -> destroy at end...

    - unify queue domain and template concepts
        - domains are predefined
        - domains provide default properties
            - exchange to bind to
            - private, auto-delete, etc.
        - rename "auto-delete" to "temporary"?

    - define reply-to as URL:
        amqp://servername:port/exchange/destination

---- FOR 1.0

    - routing information in contents
        - exchange (currently root, should be list)
        - destination
        - producer_id (for no_local, and bounces)
        - mandatory, immediate flags (currently as method options)

---- POST-1.0

---- BUGS

--- TEST CASES

    MESSAGES EN ROUTE
    - create queue
    - send messages to queue
    - consume one message
    - abort connection
    - stop server
        ... messages will have been queued for consumer, must be freed

    NO CANCEL FOR CONSUMER
    - create consumer
    - close connection

    ---
    Client A creates private queue
    Client B attempts to consume from it
    ---
    Client A creates private queue
    Client A closes connection
    Assert that queue is destroyed
    ---
    Client A creates exclusive consumer
    Client A attempts to create second consumer
    ---


--- WORLDVIEW

    Reflected in the documentation and in the product.

    Automatic Mode
        - default virtual host
        - queue and topic exchanges
        - $system exchanges
        - auto-binding for queues
            - queue templates: normal, temporary, subscription
    Advanced Mode
        - custom virtual host
        - define own exchanges
        - header-based routing
        .etc

    Creating automode
        - can be hard-coded in server
            - create destinations
            - create queue templates
            + can't be broken
            - can't be modified
            - more costly to improve later
        - can be scripted
            - run start-up script to create vhosts, etc
            + harder to modify but still possible
        - can be configured
            - configuration is just set of durable objects
            + most generic
            - can be broken
            - would need "reset" functionality


Some ideas
    - create vhost dynamically, (copy existing vhost?)
        - predefined vhost = standard wiring
    - allow operations on vhost and all wiring
        - copy from
        - delete
        - reset / empty
        - save / restore
    - documentation should cover lifetime of objects
        - exchanges
        - queues
        - bindings
        - consumers
        - messages
    - purge/timeout auto-delete queues

----------------------------------------------------------------------------


---- DOCUMENTATION

    - write/double-check test methods for all classes - icl, ipr, smt, asl, amq
    - add 'domain' concept to icl
    - redefine all context blocks using domains
    - define documentation domains (user, tech, etc.)
    - write/check documentation for all classes

---- BASE

    - boom install history in $IBASE/install
        - allows uninstall
        - cummulative per project
    - gsl elastic spaces should compress down to 1, not 2 spaces
    - separate the ignorecase option into two options
        - a. to allow case-insensitive symbol names
        - b1. to mangle symbol values when names are UPPER or Mixed case
        - b2. to mangle symbol names in all cases
    - icl code generation has become really messy
        - blank lines
        - indentation
    - icl
        - coverage check for methods
        - run test cases, accumulate statistics
        - check against code
    - smt
        - socket output buffering and flushing
        - socket input buffering
        - can't group actions in grouped actions
        - loses/delays socket_error when heavily used
           - e.g. disconnection trapped only when next client connects

---- SMT links HOWTO

    - if you get a reference from a container
        - either unlink it
        - or destroy it
        - or get a next reference
    - if you pass a reference via a call
        - synch call: do nothing
        - asynch call: link to it on behalf of called
        - called asynch method: unlink or destroy it
    - if you store a reference anywhere
        - link when storing the reference
        - unlink when finished with the reference
    - do not link to parent object
        - hierarchy of creation/destruction
    - looseref to objects
        - when using, check if zombied and then unlink

---- HASH HOWTO

    - don't manipulate self->key
        - provide real key at insertion
        - don't use self->key after removal...
        - rename to _key?

---- CLUSTERS

    a. for resiliency (failure)
        - using master-slave model
        - possibly hierarchical model
    b. for load-balancing
        - using multi-master model
        - possibly hierarchical model
    c. for geographical distribution
        - using other means

    - client connects to server
    - server can kick client, with 'reconnect to different server'
    - server provides list of known alternative servers
        - masters and backups
    - client may try servers randomly/serially
        - this is for load-balancing
    - client can connect with 'please don't kick me'
        - if it was already working with that server

    master-slave:
        - agressive heartbeating allows slave to monitor master & vv
        - various strategies for replication
            - repeat all AMQP commands to slave
                - get confirmation before doing own processing thereof
            - repeat internal structures to slave
                - all created objects replicate themselves
            - repeat only stored data
                - messages, subscriptions

---- AUTOBUILD

    check bootstrap
    - download, build, install bootstrap packages
    >> every 4 hours

    check repository trunks
    - check out svn trunk into fresh tree
    - build each product and project
    - run project unit tests
    - run project coverage checks
    - run product/project regression tests
    - run performance tests & report results
    >> every hour, signal failure or recovery
    >> for multiple configurations
        - each with name and environment settings
        - e.g. st, mt, stat, etc.
            openamq_1.0b2_win32_mtd.exe

    build package
    - build source package (snapshot or release)
    - build binary packages
    - update web site for latest build
    - upload source package and web site
    >> automatic daily snapshot, manual planned release

    build bootstrap
    - build and upload bootstrap package
    >> when repository trunk build successful

    - write in Perl

---- PACKAGING

    - Unix
        -> source packages and configure/make
        - configure includes all build options
    - win32
        -> source packages and configure/make
        - configure includes all build options
        -> binary packages
            - using win32 installer
            - including configuration
            - control panel application
    - other
        -> debian packages?
        -> very version dependent...


