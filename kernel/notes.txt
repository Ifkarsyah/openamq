********************************************************************

Planning for 1.0 release

Date: 31 January 2005
    This is very brutal.
    And we will get there.

Functionality:

    - Persistence
        - using abstract storage system
    - Transactions
        - on single primary server
    - Clustering
        - for failover
        - for pub/sub
        - NOT for persistence/transactions
    - openamq.org
        - ready for 1.0
    - documentation
        - openamq server guide
        - stdc api guide
    - clients
        - swig
    - other
        - service-oriented API
        - service queue
        - topic pub/sub
        - period.

Who what:

 tim: pluggable modules
    - for exchange extensions, cbr, filtering examples
 ph: - spec the abstract storage system
 ph: - work on clustering
 mato: - swig api
 mato: - openamq.org updates
 mato: - openamq software handbooks
 ph: - find/design service-oriented api
 

- build simple queued file transfer application
- gigabyte files
    -> undoable in activemq
    - transfer all files from folder
    - receive files into folder...
    - run script when receiving file

    -> can this be done in PAL?
    -> sample applications...
    -> also in C
    -> ascii conversion? ipr_write...?

- finish pal tests
- swig yes
- .net maybe
- server doc yes
- website yes
- sample apps yes (file transfer, work distribution)
- transactional storage
    - on memory, yes
    - external storage api
        - sqlite
- clustering yes
- queue declare properties
    - durability
    - persistence
    - max size
    - handle overflow
    - deadlettering


********************************************************************

    basic protocol rules
    - any property needed for interop is named & standard
    - anything else is allowed, extensible x-, X-
        - server warns but ignores unsupported non-standard properties
    - we aim to support full configuration & changeable
        via the protocol
        every entity and attribute of the vhost
    - watching the server is console's job
    - how to extend
        - write own exchange
        - send arbitrary messages to exchange
    
AMQwg
    - active members
    - passive members
    - banks, vendors

Powerpointy stuff
    - vision of amqp becoming ubiquitous
    - easy examples in PAL
    - nice scenarios


General rule for handling issues

1. Bug process
    - describe the problem
    - localise the layer
        - platform dependent? (5%)
        - build dependent? (15%)
        - functional scenario? (85%)
    - reproduce it consistently
        - specific test case if needed
    - assign to the developer
        - on basis of test case
    - fix the problem
        - in vitro
    - confirm the fix
        - in vitro
        - in veritas

2. Change process
    - describe the requirement
        - _not_ the solution!
    - assign to the developer
    - document
        - confirm the requirement
        - propose a solution
        - argumentation and alternatives
        - cost and planning
    - confirm
        - silence means consent
    - develop
        - solution
        - test cases
    - confirm
        - in vitro
        - in veritas
    

The 'Watch' Method
------------------

The system exchange is responsible for monitoring watches.  It does
this by maintaining a list of watches and checking each one after
some regular interval - e.g. every 30 seconds.  It asks the watched
object to provide its properties ("inspect"), checks the properties
and if they hit the watch limit, sends an alert.

Once watch has provoked an alert, the system exchange will suppress
successive alerts unless there is significant variance - e.g. 5%.

In the OpenAMQ server, requests are handled by the standard system
exchange "amq.console". Responses are sent to a temporary reply queue
created by the console interface layer.

Asynchronous information - alerts - are sent to the amq.console.alert
exchange, and console interface layer(s) get these alerts using a
pub/sub model. Alerts are published with a topic-style routing key that
allows selective subscription to specific types of alert.


Format:


---- TEST HARNESS

    - proxy
        - asl agent
        - listens on specified port
        - can be disabled - port = 0
        - reconnects to main server port
        - logs traffic

    - standard ASL component
    - built-in to amq_server
    - runs on separate port
    - handles multiple simultaneous connections
    - record mode
        - opens local server port to main protocol
        - passes data to/from clients
        - records session (start to finish)
    - replay mode
        - replays session (start to finish)
        - maintains order of request response
            - write X bytes
            - expect Y bytes
            - etc.
    - tool to generate test clients
        - documentation at start, what is the test case?
        - ability to stop/start child processes
            - monitor crashes
            - exit status
---- TODO

    - consumer filters
        - act to divert messages to another queue
        - not copy, that would be done by binding to exchange
        - consume on queue X, with params...
            

    - durable definitions
        - exchanges, queues...
    - consumer windowing
        - part of transaction management

    - store content header without parsing
        - parse certain items
            - weight, size, class.
        - store content header in content without parsing it
        - replay from stored block
        - if needed for matching,
            - decode it
            - define methods to do this easily...
            - decode once -> content
            - then access content fields
            - headers -> field list
                -> decode automatically
                -> destroy at end...

    - define reply-to as URL:
        amqp://servername:port/exchange/destination

---- FOR 1.0

---- POST-1.0

---- BUGS

--- TEST CASES

--- WORLDVIEW

---- BASE

    - boom install history in $IBASE/install
        - allows uninstall
        - cummulative per project
    - gsl elastic spaces should compress down to 1, not 2 spaces
    - separate the ignorecase option into two options
        - a. to allow case-insensitive symbol names
        - b1. to mangle symbol values when names are UPPER or Mixed case
        - b2. to mangle symbol names in all cases
    - icl code generation has become really messy
        - blank lines
        - indentation
    - icl
        - coverage check for methods
        - run test cases, accumulate statistics
        - check against code
    - smt
        - socket output buffering and flushing
        - socket input buffering
        - can't group actions in grouped actions
        - loses/delays socket_error when heavily used
           - e.g. disconnection trapped only when next client connects
        - check multithreaded usage of objects
    
---- SMT links HOWTO

    - if you get a reference from a container
        - either unlink it
        - or destroy it
        - or get a next reference
    - if you pass a reference via a call
        - synch call: do nothing
        - asynch call: link to it on behalf of called
        - called asynch method: unlink or destroy it
    - if you store a reference anywhere
        - link when storing the reference
        - unlink when finished with the reference
    - do not link to parent object
        - hierarchy of creation/destruction
    - looseref to objects
        - when using, check if zombied and then unlink

---- HASH HOWTO

    - don't manipulate self->key
        - provide real key at insertion
        - don't use self->key after removal...
        - rename to _key?

---- PACKAGING

    - Unix
        -> source packages and configure/make
        - configure includes all build options
    - win32
        -> source packages and configure/make
        - configure includes all build options
        -> binary packages
            - using win32 installer
            - including configuration
            - control panel application
    - other
        -> debian packages?
        -> very version dependent...


Console
    - command line
        - inspect object
        - modify object
        - execute method
        - api is interpreted from schema
    - mato?
    - jonathan
        - logging agents
    - tim
        - swig clients
    - martin
        - persistence
    - guso
        - documentation
