Changes 2/3
    - console figures, format with suffix ("K") etc
    - bindings correctly cleaned-up when queues deleted
    - PAL extended to show interim timer values

Changes 28/2
    - setting the 'exclusive' flag always implies 'auto-delete'
    - changed binding create to use hash lookup (faster creation)
    - regexps are cached in method validation (performance)
    - changed amq_binding_list back to old model (iterator model nfg)

Changes 25/2
    - trace_queue,route,cluster -> debug_queue, etc.
    - changed user 'type' to 'group'
    - added 'super' user group, not restricted in server
    - log files cycled at end of day (before midnight LT)
    - added queue profiles in server.cfg
    - implemented queue limit features (warn/drop/trim implemented, not kill)
    - increased server listen queue size from 5 to 500 (clients were failing to connect)
    - fixed error in processing of immediate messages
    - discards/returns undeliverable messages if all consumers mismatch

Change requests
    - console default is read-only, need option to make writeable
    - show console amounts in kb
    - add ipaddress rdns in console (ipr_net?)
    - console should use hash table to store objects, not array

Protocol todo
    - remove prefetch max from asl_channel
    - remove vhost concept
    - corrections vs. comments
    
Todo
    - server restart still failing
    - change monitor values still failing
    - set mem from config/cmdline
        - start with direct, load, throw-away & restart
    - split config options into basic, advanced
    - console rule on ip address -> amq_shell does RDNS

per_client
    - limit defined in config
    - current value held in connection
    - when message queued on exclusive queue
        - per_client is incremented
    - when message dequeued off exclusive queue
        - per_client is decremented
    -> when we destroy a queue, how do we know if the
        connection is still alive, linked?

logging
    - callback on log file
    - send alerts to system exchange
    - amq-shell mode to monitor all alerts
    
statistics to keep
    - traffic per exchange, per queue
        - in, out
        - throughput, using meters
    - 
    
- multilevel config
    - e.g. user names, groups
    - we can do this using objects...
    - amq_user, amq_group

amq_shell
- show queues by number of messages
    - general sort by option?
- show page by page, with more option
- config save, only items that are not default
- select item by name, 'vhost /' -> first matching prefix
- execute from command line

- broker
    - dropped messages

    structure properties?
    general
    traffic
    statistics
    


amq_shell could become sysman
    - stop cluster brokers
    - connect to them
    - wizard for cluster configuration
    - etc.
    - using virtual cmdline objects...


logging
    access
    error
    console
    discard
    log level
    log fields?


OpenAMQ Logging System
======================


icl_set_allocator
smt_set_max_os_thread
smt_set_action_allocator

amq_shell
    configurable
        - name/pass


openamq chip
    ... snapshot of openamq.org...
    
    - presentation
        - example use cases
        - functionality
        - technical design
        - main features
            - pub/sub
            - amq implementation
            - exchanges
            - limits
            - capacity
            - self-regulation
            - installation
            - configuration
            - remote administration
            - security
            - clustering
            - logging
            - reporting
                - log file analysis?
                - statistics collection
            - performance
                - tuning
            - portability
            - WireAPI
        - standards organisation
        - support organisation
        - partners & supported products
        - contact model
    - screenshots
        - web gui
        - server
        - shell
        - performance graphs
        - statistics

    - pdf whitepapers, reports
        - conformance test results
        - performance & tuning
        - technical implementation
    - binaries 1.0cn
        - win32, solaris, linux
        - packages with notes
    - source code
        - packages
        - howto build
    - sample applications
        - chat
        - file transfer
        - trivial application framework (taf)
    - documentation, html & pdf
        - WireAPI specs
        - PAL user guide
        - Clustering guide
        - Console technical specs
        - Server handbook
    - technical reference material
        


Fixes
    - Error in console caused server to abort (reference to destroyed object).
    - Console was not checking that client used reply-to - fixed.


AMQP USPs
    Wire level protocol
    Carries opaque binary packages
    Any size from 0 to 2e64 bytes
    Rapid binary protocol
    Powerful routing architecture
    Widely-backed standard
    Vendor, system neutral
    
    
OpenAMQ USPs
    WireAPIs in C, C++, Java, Perl, Python
    JMS, COM APIs
    Fast, robust server
    Excellent performance and scaling
    Portable to all platforms
    Zero-configuration server

Missing
    Secure authentication and transport
    Persistent messages
    
    




amq bridging
    - create server-to-server bridge
    - or cluster-to-cluster bridge
    - explicit in the protocol...
    - new Bridge method class
    - a bridge is an asynchronous link
    - bridges can auto-connect across WANs

    Mechanism:
        C: Bridge.Create host, exchange, routing_key, arguments
        S: Bridge.Create-Ok        

    Server looks for host, and opens proxy connection to host:
        - creates queue on host or uses named bridge queue
        - binds queue to exchange using specified arguments
        - creates consumer on that queue
        - expects and processes delivered messages
        - each incoming delivery is passed to own exchange with same name

    Alternative:
        - acts as proxy consumer on remote shared queue
        - not passed to own exchange but directly to application

    Details
        - a bridge is a logical layer, and many bridges can be opened
          at once, each for a specific subscription request.
        
    Optional functionality
        - durable bridges (recreated when servers restart)
        - configured bridges (idem)
        - async pull bridges (recreated when host comes online)
        
    Ideal for SA:
        - cluster in SA
        - bridged to cluster in London

    ... very close to clustering.
    ... but under application control.
    ... can we imagine cluster being constructed by applications?
    ... ? no.




********************************************************************

Planning for 1.0 release

Date: 31 January 2005
    This is very brutal.

Functionality:

    - Persistence
        - using abstract storage system
        - MS in progress
    - Transactions
        - on single primary server
        - MS in progress
    - Clustering
        - for failover
        - for pub/sub
        - NOT for persistence/transactions
        - PH done RTT
    - openamq.org
        - ready for 1.0
        - PH in progress
    - documentation
        - openamq server guide
        - GS done RTT
        - stdc api guide
        - PH done
    - clients
        - swig
        - TE in progress
    - logging
        - PH in progress
    - console
        - PH in progress


Who what:

 tim: pluggable modules
    - for exchange extensions, cbr, filtering examples
 ph: - spec the abstract storage system
 ph: - work on clustering
 mato: - swig api
 mato: - openamq.org updates
 mato: - openamq software handbooks
 ph: - find/design service-oriented api
 

- build simple queued file transfer application
- gigabyte files
    -> undoable in activemq
    - transfer all files from folder
    - receive files into folder...
    - run script when receiving file

    -> can this be done in PAL?
    -> sample applications...
    -> also in C
    -> ascii conversion? ipr_write...?

- finish pal tests
- swig yes
- .net no
- server doc yes
- website yes
- sample apps yes (file transfer, work distribution)
- transactional storage
    - on memory, yes
    - external storage api
        - sqlite
- clustering yes
- queue declare properties
    - durability
    - persistence
    - max size
    - handle overflow
    - deadlettering


********************************************************************

basic protocol rules
    - any property needed for interop is named & standard
    - anything else is allowed, extensible x-, X-
        - server warns but ignores unsupported non-standard properties
    - we aim to support full configuration & changeable
        via the protocol
        every entity and attribute of the vhost
    - watching the server is console's job
    - how to extend
        - write own exchange
        - send arbitrary messages to exchange

Powerpointy stuff
    - vision of amqp becoming ubiquitous
    - easy examples in PAL
    - nice scenarios


General rule for handling issues

1. Bug process
    - describe the problem
    - localise the layer
        - platform dependent? (5%)
        - build dependent? (15%)
        - functional scenario? (85%)
    - reproduce it consistently
        - specific test case if needed
    - assign to the developer
        - on basis of test case
    - fix the problem
        - in vitro
    - confirm the fix
        - in vitro
        - in veritas

2. Change process
    - describe the requirement
        - _not_ the solution!
    - assign to the developer
    - document
        - confirm the requirement
        - propose a solution
        - argumentation and alternatives
        - cost and planning
    - confirm
        - silence means consent
    - develop
        - solution
        - test cases
    - confirm
        - in vitro
        - in veritas
    

The 'Watch' Method
------------------

The system exchange is responsible for monitoring watches.  It does
this by maintaining a list of watches and checking each one after
some regular interval - e.g. every 30 seconds.  It asks the watched
object to provide its properties ("inspect"), checks the properties
and if they hit the watch limit, sends an alert.

Once watch has provoked an alert, the system exchange will suppress
successive alerts unless there is significant variance - e.g. 5%.

In the OpenAMQ server, requests are handled by the standard system
exchange "amq.console". Responses are sent to a temporary reply queue
created by the console interface layer.

Asynchronous information - alerts - are sent to the amq.console.alert
exchange, and console interface layer(s) get these alerts using a
pub/sub model. Alerts are published with a topic-style routing key that
allows selective subscription to specific types of alert.


Format:


---- TEST HARNESS

    - proxy
        - asl agent
        - listens on specified port
        - can be disabled - port = 0
        - reconnects to main server port
        - logs traffic

    - standard ASL component
    - built-in to amq_server
    - runs on separate port
    - handles multiple simultaneous connections
    - record mode
        - opens local server port to main protocol
        - passes data to/from clients
        - records session (start to finish)
    - replay mode
        - replays session (start to finish)
        - maintains order of request response
            - write X bytes
            - expect Y bytes
            - etc.
    - tool to generate test clients
        - documentation at start, what is the test case?
        - ability to stop/start child processes
            - monitor crashes
            - exit status
---- TODO

    - consumer filters
        - act to divert messages to another queue
        - not copy, that would be done by binding to exchange
        - consume on queue X, with params...
            

    - durable definitions
        - exchanges, queues...
    - consumer windowing
        - part of transaction management

    - store content header without parsing
        - parse certain items
            - weight, size, class.
        - store content header in content without parsing it
        - replay from stored block
        - if needed for matching,
            - decode it
            - define methods to do this easily...
            - decode once -> content
            - then access content fields
            - headers -> field list
                -> decode automatically
                -> destroy at end...

    - define reply-to as URL:
        amqp://servername:port/exchange/destination

---- FOR 1.0

---- POST-1.0

---- BUGS

--- TEST CASES

--- WORLDVIEW

---- BASE

    - boom install history in $IBASE/install
        - allows uninstall
        - cummulative per project
    - gsl elastic spaces should compress down to 1, not 2 spaces
    - separate the ignorecase option into two options
        - a. to allow case-insensitive symbol names
        - b1. to mangle symbol values when names are UPPER or Mixed case
        - b2. to mangle symbol names in all cases
    - icl code generation has become really messy
        - blank lines
        - indentation
    - icl
        - coverage check for methods
        - run test cases, accumulate statistics
        - check against code
    - smt
        - socket output buffering and flushing
        - socket input buffering
        - can't group actions in grouped actions
        - loses/delays socket_error when heavily used
           - e.g. disconnection trapped only when next client connects
        - check multithreaded usage of objects
    
---- SMT links HOWTO

    - if you get a reference from a container
        - either unlink it
        - or destroy it
        - or get a next reference
    - if you pass a reference via a call
        - synch call: do nothing
        - asynch call: link to it on behalf of called
        - called asynch method: unlink or destroy it
    - if you store a reference anywhere
        - link when storing the reference
        - unlink when finished with the reference
    - do not link to parent object
        - hierarchy of creation/destruction
    - looseref to objects
        - when using, check if zombied and then unlink

---- HASH HOWTO

    - don't manipulate self->key
        - provide real key at insertion
        - don't use self->key after removal...
        - rename to _key?

---- PACKAGING

    - Unix
        -> source packages and configure/make
        - configure includes all build options
    - win32
        -> source packages and configure/make
        - configure includes all build options
        -> binary packages
            - using win32 installer
            - including configuration
            - control panel application
    - other
        -> debian packages?
        -> very version dependent...


Console
    - command line
        - inspect object
        - modify object
        - execute method
        - api is interpreted from schema
    - tim
        - swig clients
    - martin
        - persistence
    - guso
        - documentation
