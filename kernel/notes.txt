- reintroduce connection close handling
- server wait for client to send close-ok after sending close

---- IN PROGRESS

    0.8 matching
        - amq_match -> bitmap of corresponding subscriptions
            - _topic_re ()
                - convert topic specifier to regexp
            - _field_name ()
                - format field name into index
            - _field_value ()
                - format field value into index
        - amq_match_table -> maintain matching tables
            - also holds all known topics in array
            - held per vhost
            - _parse_topic()
                - take topic pattern, subscriber nbr
                - find all matching topics, set subscriber bit
            - _parse_fields ()
                - take field selector, subscriber nbr
                - find all matching field/value pairs, set subscriber bit
            - _check_topic ()
                - update match table bitmaps for new topics
        - amq_hitset -> do actual matching
            - _match ()
                - from message, build hitset of subscribers
            - _publish ()
                - from hitset, dispatch message to subscribers
        vhost
            amq_match_table, amq_topic_array
                amq_match, bits
            hitset

    0.9 matching
        - exchange = governing structure for routing
            - binding_index = structure that numbers bindings from 1 to n
            - binding_list = list of bindings
            - index_hash = table of active indices
            - index_array = array of active indices

        - binding = relationship between exchange and (queue or exchange)
            - (aka 0.8: amq_subscr)
            - queue_list = list of queues for binding
            - exchange_list = list of exchanges for binding
            - index_list = looseref list of indices for binding

        - index = search term
            - index_hash = lookup index by value
                - ->key index key
                - ->bitset of matching bindings
            - index_array = lookup index by number
                - index key

        - hitset = search results

        Algorithms

        1. Bind to exchange

            - look for binding that matches arguments
            - if not found, create new binding:
                - insert binding into exchange->binding_index
                    - gives binding->index
                - iterate through indices in exchange->index_array
                    - compare index to binding argument
                    - if index matches arguments, set bit in match bitmap
                        - get index from hash table
                        - set bit (binding->index) in bitset
                        - add looseref to index for binding
            - add to binding queue_list or exchange_list

        Notes:
            - for matching on destinations (topics), we have to compare the
              given topic pattern to all known destinations in order to know
              which match our pattern.

            - for matching on field value/presence, we do not need to compare
              all known indices; each argument specifies a field name and
              optional value, and can be mapped directly into a index lookup.

            - for matching on field value wildcards, we have to compare the
              given field patterns to all known field name/value pairs in
              order to know which match our pattern.

            - we can derive one generalised solution for all three of these
              cases but it will be slower than necessary for the second case.

            - this cost is in compiling bindings, and publishing messages with
              new content... the cost may be payable.

        2. Publish message

            - decode message into indices, for each index:
                - if new index:
                    - check each binding for exchange:
                        - if binding arguments match index
                            - update index->bitset for binding->index
                            - add index to binding index list
                    - save new index with bitset to index_hash
                    - add index to index_array
                - lookup index into index_hash
                - iterate through bits in bitset:
                    - update hit count in hitset table
            - for each valid hit in hitset:
                - publish message to binding

---- STAT

- 0.8 - 57k lines of C code (server + async client) -              0.8d10

---- TODO

    - unify queue domain and template concepts
        - domains are predefined
        - domains provide default properties
            - exchange to bind to
            - private, auto-delete, etc.
        - rename "auto-delete" to "temporary"?
            
    - define reply-to as URL:
        amqp://servername:port/exchange/destination

    - store content header without parsing
        - replay from stored block
        - parse only if needed for field matching

    - validate exchange name, queue name at declare time
        - review name syntax

    - clarify protocol for aborting single large message
        - close channel?
        - send end-of-message frame?

    - content routing information
        - exchange (currently root, should be list)
        - destination
        - producer_id (for no_local, and bounces)
        - mandatory, immediate flags (currently as method options)

    tool to generate test clients
        - standard set of options for all test programs
        - define methods wanted as XML program
            - methods plus arguments
        - repetitions as loops
        - success/failure for each method?
        - documentation at start, what is the test case?
        - ability to stop/start child processes
            - monitor crashes
            - exit status
        - need server control facilities
            - STOP command
            - RESTART command
            - send to $system exchange...
            - server command line option to enable this...
        - wait
        - random
        ... fully abstract, no C code!
        ... generate test sets in Perl, C, etc.
        ... forms part of formal protocol specifications
    - part of asl...



- proxy program
    - log methods
    - replay methods
    - print log for readability
- client and server should announce themselves
    - public names
    - virtual host descriptions


---- BUGS

    amp_client_session:
    - client hangs if trying to read

- unknown
    - when trying to synchronise client/server shutdown, get a freeze
        - client sends connection.close
        - client waits for method
        - server reads connection.close
        - server writes connection.close-ok
        - client never receives it...

--- TEST CASES

    MESSAGES EN ROUTE
    - create queue
    - send messages to queue
    - consume one message
    - abort connection
    - stop server
        ... messages will have been queued for consumer, must be freed

    NO CANCEL FOR CONSUMER
    - create consumer
    - close connection


--- WORLDVIEW

    Reflected in the documentation and in the product.

    Automatic Mode
        - default virtual host
        - queue and topic exchanges
        - $system exchanges
        - auto-binding for queues
            - queue templates: normal, temporary, subscription
    Advanced Mode
        - custom virtual host
        - define own exchanges
        - header-based routing
        .etc

    Creating automode
        - can be hard-coded in server
            - create destinations
            - create queue templates
            + can't be broken
            - can't be modified
            - more costly to improve later
        - can be scripted
            - run start-up script to create vhosts, etc
            + harder to modify but still possible
        - can be configured
            - configuration is just set of durable objects
            + most generic
            - can be broken
            - would need "reset" functionality


Some ideas
    - create vhost dynamically, (copy existing vhost?)
        - predefined vhost = standard wiring
    - allow operations on vhost and all wiring
        - copy from
        - delete
        - reset / empty
        - save / restore
    - documentation should cover lifetime of objects
        - exchanges
        - queues
        - bindings
        - consumers
        - messages
    - purge/timeout auto-delete queues

----------------------------------------------------------------------------


---- DONE

August
    1.0a3
    - implemented no-local flag on queue consumers
        - affects the way messages are distributed from a queue

    1.0a2
    --Done--------
    - client API is more SASL-compliant (pass auth_data block)
    - move destination field out of headers, into methods
    - generate protocol constants from ASL specifications
        - asl_constants.asl
        - can be inherited and extended
        - generates asl_constants.icl class

    1.0a1
    --Done--------
    - robust handling of exchange, queue tables filled
        - also increased from 255 to 64k per virtual host
    - connection recovery
        - server and client hand-shake after recovery
    - channel flow control
        - new consumers created according to channel state
        - flow on/off enables/disables consumers
        - queue dispatching works only with active consumers
        - enabling a consumer provokes queue dispatching
    - validate server port number <64k and >1024
    - allow server port to be specified on command line

July
    --Done--------
    - exchanges internal/external flag
    - exchange.bind to make multilevel exchanges
    - Basic consumers
        - consume/cancel works as for JMS class
    - asynchronous dispatching
        - i.e. consume from existing queue
    - extend client connection with own context
        - e.g. reply code, session key, etc.
    - extend client session with own context
        - e.g. reply code, consumer tag, etc.
    - consumer tagging
        - index of consumer per channel
        - cancel method
    - longstr, tables increased to 4Gb limit
    - frames redefined to remove all small limits
    - queue bounce messages
        - no routing in exchange (mandatory field)
        - no consumers in queue (immediate field)
    - undeliverable messages are bounced
        - Jms.Bounce, Basic.Bounce methods
        - provided to client in queues
    - exchange base class
        - list of bindings
            per binding, looseref list of queues & exchanges
    - detect & report abnormal client disconnect
    - generate context keys for new connections
    - handle connection reconnection

- minimum required for GRM
    - JMS class
*        consume, consume-ok
*        cancel, cancel-ok
*        publish / immediate
*        deliver
    - exchange classes
        dest-wild
        property
    - queue:
*        jms messages, no priority, no persistence
    - queue templating
        basics only - queue max. size?
*    - fanout, queue, dest-wild, property exchanges
     - jms consumers
        - preconfigured exchanges
        - queue, cbr

---- RANDOM
    - write/double-check test methods for all classes - icl, ipr, smt, asl, amq
    - add 'domain' concept to icl
    - redefine all context blocks using domains
    - define documentation domains (user, tech, etc.)
    - write/check documentation for all classes

---- BASE

    - boom install history in $IBASE/install
        - allows uninstall
        - cummulative per project
    - gsl elastic spaces should compress down to 1, not 2 spaces
    - separate the ignorecase option into two options
        - a. to allow case-insensitive symbol names
        - b1. to mangle symbol values when names are UPPER or Mixed case
        - b2. to mangle symbol names in all cases
    - icl code generation has become really messy
        - blank lines
        - indentation
    - icl "release" as opposite of "possess"?
    - icl/smt
        - <local> per sync and async
        - <local name = "async">
        - <header name = "async">.. etc.
        - <body name = "async">
    - smt
        - socket output buffering and flushing
        - socket input buffering
        - write bucket of zero size causes problems
        - can't group actions in grouped actions
        - loses/delays socket_error when heavily used
            - e.g. disconnection trapped only when next client connects

    --Done--------
    - ipr containers
        - _size property giving number of elements
    - smt
        - delay timers appear to kill thread
        - multithreading under win32
    - icl
        - icl.gsl is not a nice name, move stdc back into icl_stdc

---- SMT links HOWTO

    - if you get a reference from a container
        - either unlink it
        - or destroy it
        - or get a next reference
    - if you pass a reference via a call
        - synch call: do nothing
        - asynch call: link to it on behalf of called
        - called asynch method: unlink or destroy it
    - if you store a reference anywhere
        - link when storing the reference
        - unlink when finished with the reference
    - do not link to parent object
        - hierarchy of creation/destruction

---- HASH HOWTO

    - don't manipulate self->key
        - provide real key at insertion
        - don't use self->key after removal...
        - rename to _key?

---- CLUSTERS

    a. for resiliency (failure)
        - using master-slave model
        - possibly hierarchical model
    b. for load-balancing
        - using multi-master model
        - possibly hierarchical model
    c. for geographical distribution
        - using other means

    - client connects to server
    - server can kick client, with 'reconnect to different server'
    - server provides list of known alternative servers
        - masters and backups
    - client may try servers randomly/serially
        - this is for load-balancing
    - client can connect with 'please don't kick me'
        - if it was already working with that server

    master-slave:
        - agressive heartbeating allows slave to monitor master & vv
        - various strategies for replication
            - repeat all AMQP commands to slave
                - get confirmation before doing own processing thereof
            - repeat internal structures to slave
                - all created objects replicate themselves
            - repeat only stored data
                - messages, subscriptions

---- JIRA

    - should show summary of open issues as first view on project
    - modify workflow: pending, ready-to-test, rejected, cancelled states

---- PROXY

    - standard ASL component
    - built-in to amq_server
    - runs on separate port
    - handles multiple simultaneous connections
    - record mode
        - opens local server port to main protocol
        - passes data to/from clients
        - records session (start to finish)
    - replay mode
        - replays session (start to finish)
        - maintains order of request response
            - write X bytes
            - expect Y bytes
            - etc.
