

consumer_new
    - get new consumer index
        - look in vhost consumer set
        - get first free bit
    - dest_name-> list of criteria
        - match dest_name to all topics for vhost

consumer_destroy
    - clear vhost consumer bit
    - clear all terms that consumer uses

dest_new
    - if topic service
        - match to all existing consumers
            - possibly extend consumers criteria

dest_destroy
    - if topic service
        - remove criteria from database

amq_criteria
    - based on hash_str

    name            destname
    value           a.b.c...
    data            <consumer set>

amq_criteria

    add consumer

amq_criteria_list
    parse dest
        name
        name.name
        name.*.name
        name.*
        name.#
            etc.

handle send
    - destination name -> list of criteria?







---------------------------------------------------


mailbox concept
    open handle, create mailbox
    purge at open
    purge at disconnect
    private (take ownership)
    template (name)


temporary queues
    - explicit clear option
        - by any consumer
temporary subscriptions
    - explicit clear option
        - by consumer
persistent subscriptions
    - saved in db_dest
    - consumer must also be saved
    - and recompiled when server starts








consume -> update subscription set
    implementation 1 - quick&dirty:

    request object
        - topic name
        - subsc reference

    handle consume on topic
        - calculate full topic name
        - create request object
        - add to vhost list

    handle send
        - check all request objects
        - distribute messages to subscs
        - dispatch subscs

    implementation 2 - faster matching
    - kill request object

    handle consume on topic
        -


vhost->queues   accept, dispatch
     ->topics   accept
     ->subs     dispatch

    smessage-> topic, queue
    dispatch-> queue, sub


Stuff to fix

 - complain if config file is invalid (says nothing)
 - change temporary queue to "mailbox" concept
    - purge at open, optional
    - purge at close, optional
 - move to HUGE values for file/mesg sizes
    - or 64-bit values
 - way to cancel and/or purge a message being sent
    - HANDLE STOP / PURGE command

Queues
 - deleting - need to handle extent files as well...
    ... does not appear to create them?

restartability
    . refresh virtual hosts
    . create new queues & topics
    . leave connections alive

subscriptions
    . subscription table
    . persistent / non-persistent
    . each subscription is a queue

- amq_server object
    - replaces amq_global
    - runs on a specific port



- move argument parsing & copyright block to standard iPR function




Changes

    rfc006
    fragments
        - allow client to cancel messages using flow/cancel

    client failure
    - failover to secondary server
    - use heartbeat command to check server is alive

    clustering
    - n servers
    - queue + consumers on each server
    - if queue filled & no consumers, messages are forwarded
        - using inter-server MTA
    - if queue empties & consumers, messages are scraped
        - using inter-server MTA
    - separate mechanism for forwarding topics
    - client connection
        - list of ip addresses
        - serial or round robin
        - can be redirected by server
        - can tell server, "no redirect"
    - durable subscriptions
        - may be held on different server, use queue thunking
        - may be allowed for scalability

    multithreading
    - one for smt
    - one for bdb

    clients, priority
    * COM+ for demo
    * C thread-safe
    * Java
    - .NET
    * Perl


Durable Subscriptions
    When server starts up, creates consumer item for all
    durable subscriptions it finds...
        - these are destinations marked as SUBSCRIPTION


Clustering
    a. for resiliency (failure)
        - using master-slave model
        - possibly hierarchical model
    b. for load-balancing
        - using multi-master model
        - possibly hierarchical model
    c. for geographical distribution
        - using other means
        
    - client connects to server
    - server can kick client, with 'reconnect to different server'
    - server provides list of known alternative servers
        - masters and backups
    - client may try servers randomly/serially
        - this is for load-balancing
    - client can connect with 'please don't kick me'
        - if it was already working with that server

    master-slave:
        - agressive heartbeating allows slave to monitor master & vv
        - various strategies for replication
            - repeat all AMQP commands to slave
                - get confirmation before doing own processing thereof
            - repeat internal structures to slave
                - all created objects replicate themselves
            - repeat only stored data
                - messages, subscriptions
       
    
