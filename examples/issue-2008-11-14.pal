<?xml?>
<pal script = "amq_pal_gen" >
<!--
    This script proves issue:xx.
    Symptoms:
    - slow memory leak on consumers, depending how queues are destroyed
    - unreliable behaviour when explicit consumer tags used
    Internal analysis:
    - consumers were not properly deleted for auto_delete queue deletion
    - second Cancel tried to cancel first consumer but that consumer's
      queue no longer existed, so cancel failed, and does not return a
      Cancel-Ok response, causing application to hang for timeout
    - meanwhile second consumer was not canceled, causing memory leaks
    Cause:
    - error in amq_queue_base.icl, use of <action> block in destroy method
    - since used in synchronous object, action block was simply ignored
    Resolution:
    - correction to amq_queue_base.icl to properly destroy consumers.
  -->
    <session>
        <!-- Create auto_delete queue -->
        <queue_declare auto_delete="1" />
        <!-- Consume with an explicit tag -->
        <basic_consume queue="$queue" consumer_tag="test-tag" />
        <!-- Delete queue without canceling consumer -->
        <queue_delete queue="$queue" />

        <!-- Create second queue -->
        <queue_declare />
        <!-- Reuse consumer tag... -->
        <basic_consume queue="$queue" consumer_tag="test-tag" />
        <!-- Cancel the consumer, this now hangs -->
        <basic_cancel consumer_tag="test-tag" />
    </session>
</pal>

