#! /usr/bin/perl
#=============================================================================
#
#   autobuild.pl - iMatix autobuilder
#
#   Written:  2005/09/28  Martin Lucina
#
#   Skeleton generated by LIBERO 2.4 on 28 Sep, 2005, 18:48.
#=============================================================================

# TODO
# - upload to ftp/web
# - reports by email

use strict;
use warnings;
BEGIN {
    require 'autobuild.d';              #   Include dialog interpreter
    main_dialog->import ();
};

use IO::Handle;                         #   For logging
use IO::File;                           #   For logging
use POSIX qw(strftime uname);           #   For logging
use File::Copy;                         #   For uploading packages
use SVN::Client;                        #   Subversion client API
use SVN::Ra;                            #   Subversion remote access API
use Data::Dumper;                       #   For state save/restoreq
use LWP::UserAgent;                     #   For Wiki upload
use HTTP::Request::Common;              #   For Wiki upload
use Scalar::Util qw(weaken);            #   For weak references

our ($config);                          #   Configuration hash
our ($log_fh);                          #   File handle to log messages to
our ($build);                           #   Configuration we are building
our ($b_products);                      #   Products to (re)build
our ($b_product);                       #   Current product we are building
our ($want_rebuild) = 0;                #   Set if --rebuild on command line
our ($lwp_ua);                          #   LWP UserAgent for uploads
our ($svn_pool);                        #   Pool for SVN client

$exit_status = $EXIT_SUCCESS;           #   Main program feedback
&execute;                               #   Run dialog interpreter

##########################   INITIALISE THE PROGRAM   #########################

sub initialise_the_program
{
    $SIG{'TERM'} = \&signal_handler;
    $SIG{'INT'}  = \&signal_handler;
    $the_next_event = $ok_event;
}


sub signal_handler {   
    &log_message ("E: Interrupted");
    &raise_exception ($shutdown_event);
}


############################   GET EXTERNAL EVENT   ###########################

sub get_external_event
{
}


##########################   TERMINATE THE PROGRAM    #########################

sub terminate_the_program
{
    &log_stop ();
    $the_next_event = $terminate_event;
}


###########################   TERMINATE WITH ERROR   ##########################

sub terminate_with_error
{
    &log_stop ();
    $exit_status    = $EXIT_FAILURE;
    $the_next_event = $terminate_event;
}


#############################   LOAD CONFIG FILE   ############################

sub load_config_file
{
    #  Load configuration from an external file by asking Perl to parse it.
    eval {
        do 'autobuild.cfg';
    };

    #  Report any errors we got back from the above block.
    if ($@) {
        &log_message ("E: Unable to load configuration file: $@");
        &log_message ("E: Configuration error, exiting");
        &raise_exception ($config_error_event);
        return;
    }

    #  Check configuration for correctness.
    if (!exists $config->{build}    || !exists $config->{svn} ||
        !exists $config->{products} || !exists $config->{logging}) {
        &log_message ("E: Configuration file is incomplete.");
        &log_message ("E: Configuration error, exiting");
        &raise_exception ($config_error_event);
        return;
    }

    my ($c_builds)   = $config->{build};#  Alias
    my ($c_svn)      = $config->{svn};  #  Alias
    my ($c_products) = 
        $config->{products};            #  Alias
    weaken ($c_builds);
    weaken ($c_svn);
    weaken ($c_products);

    #  Check if the user asked for a full rebuild.
    if ((scalar @ARGV) && 
        ($ARGV[0] eq '--rebuild')) {
        shift (@ARGV);
        $want_rebuild = 1;
    }

    #  If the configuration file defines more than one build configuration
    #  and the user has not specified a configuration on the command line,
    #  print a list and exit.
    if ((scalar (keys %$c_builds) > 1) &&
        (scalar @ARGV != 1)) {
        &log_message ("E: Configuration file defines more than one build ",
            "configuration.");
        &log_message ("I: Known configurations:");
        for $build (sort keys %$c_builds) {
            &log_message ("I: ", $build, ": ", $c_builds->{$build}->{name});
        }
        &log_message ("I: Please specify the name of the desired build");
        &log_message ("I: configuration on the command line.");
        &raise_exception ($config_error_event);
        return;
    }

    #  Build the configuration specified on the command line, if any.
    if (scalar @ARGV == 1) {
        $build = shift @ARGV;
            if (!exists $c_builds->{$build}) {
                &log_message ("E: No such configuration: ", $build);
                &raise_exception ($config_error_event);
                return;
            }

    #  Else, build the only configuration defined in the configuration file.
    } else {
        $build = (keys (%$c_builds))[0];
    }
    $c_builds->{$build}->{_key} = $build;
    $build = $c_builds->{$build};

    #  Resolve all defined product URLs from <repos>:path to the full URL.
    for my $product (keys %$c_products) {
        my ($product_repos);
        my ($product_repos_path);

        ($product_repos, $product_repos_path) = 
            split (/:/, $c_products->{$product}->{url});
        if (!defined $product_repos || !defined $product_repos_path) {
            &log_message ("E: Error parsing URL of product '", $product, "'");
            &raise_exception ($config_error_event);
            return;
        }
        if (!exists $c_svn->{$product_repos}) {
            &log_message ("E: Repository '", $product_repos, 
                "' does not exist in definiton of product '", $product, "'");
            &raise_exception ($config_error_event);
            return;
        }
        $c_products->{$product}->{url}   = 
            $c_svn->{$product_repos} . $product_repos_path;
        $c_products->{$product}->{name}  = $product;
        $c_products->{$product}->{repos} = $product_repos;
    }
    
    #  Check that working directory exists.
    if (! -d $build->{workdir}) {
        &log_message ("E: ", $build->{workdir}, " does not exist");
        &raise_exception ($config_error_event);
        return;
    }
    $build->{state_file} = $build->{workdir} . '/autobuild.state';
    $build->{state}      = {};

    #  Resolve paths to checked out copies of products and check that they 
    #  exist.  Also save the list of repositories that this build is using
    #  in $build->{repositories}.
    my (%repositories) = ();
    for my $key (@{$build->{products}}) {
        $c_products->{$key}->{path} = $build->{workdir} . '/svn/' . 
            $c_products->{$key}->{name};
        if (! -d $c_products->{$key}->{path} ||
            ! -d $c_products->{$key}->{path} . '/.svn') {
            &log_message ("E: Product '$key': No checked out copy exists at '",
                $c_products->{$key}->{path}, "'");
            &raise_exception ($config_error_event);
            return;
        }
        $repositories{$c_products->{$key}->{repos}} = 1;
    }
    $build->{repositories} = [keys %repositories];

    #  If an upload-to-wiki configuration is present, initialise the LWP
    #  User Agent object and load credentials into it, if any.
    if (exists $config->{upload}) {
        my ($uri);

        $lwp_ua = new LWP::UserAgent;
        $uri    = new URI ($config->{upload}->{wiki_url});
        if (exists $config->{upload}->{username} && 
            exists $config->{upload}->{password}) {
            $lwp_ua->credentials ($uri->host_port(), '/',
                $config->{upload}->{username},
                $config->{upload}->{password});
        }
    }

    #  Start logging to file.
    &log_start ($config->{logging}->{log_file});
}


##########################   INITIALISE SVN CLIENT   ##########################

sub initialise_svn_client
{
    my ($c_svn) = $config->{svn};       #  Alias
    weaken ($c_svn);

    #  Create a SVN memory pool for the API to use
    $svn_pool = SVN::Pool->new_default;

    #  For each SVN repository that is defined, create auth, client and ra
    #  objects that we need to access it.  Stash the objects in $c_svn and
    #  test that we can actually access the repository.
    for my $key (keys %$c_svn) {
        my ($repos) = $c_svn->{$key};   #  Alias
        weaken ($repos);

        eval {
            $repos->{auth} = [
                SVN::Client::get_simple_provider (),
                SVN::Client::get_simple_prompt_provider (sub {
                    &init_auth_cb ($repos, @_) }, 0),
                SVN::Client::get_username_provider (),
                SVN::Client::get_ssl_server_trust_file_provider ()
                ];
        };
        if ($@) {
            &log_message ("E: Could not create SVN auth_baton for repository ",
                "'$key': ", $@);
            &raise_exception ($svn_error_event);
            return;
        }

        eval {
            $repos->{ctx} = 
                new SVN::Client (auth => $repos->{auth});
        };
        if ($@) {
            &log_message ("E: Could not create SVN::Client for repository ",
                "'$key': ", $@);
            &raise_exception ($svn_error_event);
            return;
        }

        eval {
            $repos->{ra}  = 
                new SVN::Ra (url  => $repos->{repos},
                             auth => $repos->{auth});
        };
        if ($@) {
            &log_message ("E: Could not create SVN::Ra for repository ",
                "'$key': ", $@);
            &raise_exception ($svn_error_event);
            return;
        }

        #  Test that we can access $repos.
        eval {
            $repos->{ra}->get_latest_revnum ();
        };
        if ($@) {
            &log_message ("E: Cannot access repository '$key': ", $@);
            &raise_exception ($config_error_event);
            return;
        }
    } 
    $the_next_event = $ok_event;
}


#  Authentication provider callback for SVN::Client::new ()
sub init_auth_cb {
    my ($repos,
        $cred,
        $realm,
        $default_username,
        $may_save,
        $pool) = @_;

    $cred->username ($repos->{username});
    $cred->password ($repos->{password});
    $cred->may_save (0);
}


################################   LOAD STATE   ###############################

sub load_state
{
    #  Read state of last build from working directory, if any.
    if (-f $build->{state_file}) {
        eval {
            do $build->{state_file};
        };
        if ($@) {
            &log_message ("E: Could not read state from '", 
                $build->{state_file}, "': $@");
            &raise_exception ($exception_event);
            return;
        }
        &log_message ("I: Last build id: ", $build->{state}->{last_id},
            " Status: ", $build->{state}->{last_state});

    #  No last build state, set defaults.
    } else {
        $build->{state}->{current_id}    = undef;
        $build->{state}->{current_state} = undef;
        $build->{state}->{last_id}       = undef;
        $build->{state}->{last_state}    = undef;
        $build->{state}->{products}      = {};
        $build->{state}->{svn}           = {};
        for my $key (keys %{$config->{svn}}) {
            $build->{state}->{svn}->{$key} = {};
            $build->{state}->{svn}->{$key}->{youngest_rev} = 0;
        }
        for my $key (keys %{$config->{products}}) {
            $build->{state}->{products}->{$key} = {};
            $build->{state}->{products}->{$key}->{state} = 'up_to_date';
        }
    }
}


################################   SAVE STATE   ###############################

sub save_state
{
    my ($state_fh);                     #  File handle for saving state
    
    #  Bump the build ID.
    $build->{state}->{last_id}    = $build->{state}->{current_id};
    $build->{state}->{last_state} = $build->{state}->{current_state};

    #  Dump build state to a file in the working directory.
    $state_fh = new IO::File ($build->{state_file}, 'a');
    if (!defined $state_fh) {
        &log_message ("E: Could not open  '", $build->{state_file}, "': ", $!);
        &raise_exception ($exception_event);
        return;
    }

    $state_fh->print (Data::Dumper->Dump ([$build->{state}], 
                                          [qw($build->{state})]));
    $state_fh->close ();
}


############################   CHECK BUILD STATE   ############################

sub check_build_state
{
    #  Determine the state of the last build.
    if (!defined $build->{state}->{last_state}) {
        #  Undefined means we were run for the first time.
        $the_next_event = $build_first_time_event;
    } elsif ($want_rebuild == 1) {
        #  The user asked for a full rebuild.
        $want_rebuild = 0;
        $the_next_event = $rebuild_event;
        &log_message ("I: Forcing full rebuild");
    } elsif ($build->{state}->{last_state} eq 'succeeded') {
        #  The last build succeeded.
        $the_next_event = $build_succeeded_event;
    } elsif ($build->{state}->{last_state} eq 'failed') {
        #  The last build failed.
        $the_next_event = $build_failed_event;
    } elsif ($build->{state}->{last_state} eq 'interrupted') {
        #  The last build was interrupted.
        $the_next_event = $build_interrupted_event;
    } else {
        &log_message ("E: unknown build state: ", 
            $build->{state}->{last_state});
        &raise_exception ($exception_event);
        return;
    }
}


#########################   CHECK IF SVN HAS CHANGED   ########################

sub check_if_svn_has_changed
{
    my ($c_svn) = $config->{svn};       #  Alias
    weaken ($c_svn);

    #  Create subpool for this poll
    my ($pool) = SVN::Pool->new_default_sub;

    #  Assume all repositories are up to date
    $the_next_event = $svn_has_not_changed_event;

    #  For each SVN repository that is used by this build:
    for my $key (@{ $build->{repositories} }) {
        my ($repos) = $c_svn->{$key};   #  Alias
        my ($r_state) = $build->{state}->{svn}->{$key}; #  Alias
        my ($youngest_rev);
        weaken ($repos);
        weaken ($r_state);

        #  Get the youngest revision in the repository.
        eval {
             $youngest_rev = $repos->{ra}->get_latest_revnum ();
        };
        if ($@) {
            &log_message ("E: Cannot get_latest_revnum for repository '", 
                  $key, "': ", $@);
            &raise_exception ($svn_error_event);
            return;
        }

        #  Check if it has changed since we last looked.
        if ($r_state->{youngest_rev} < $youngest_rev) {
            #  It changed, stash it and return $svn_not_up_to_date_event.
            $r_state->{youngest_rev} = $youngest_rev;
            &log_message ("I: New rev for repository '$key': ", 
                $r_state->{youngest_rev});
            $the_next_event = $svn_has_changed_event;
        } 
    }
}


# -----------------------------------------------------------------------------
# Function: $youngest_revs = &get_youngest_revs ()
#
# Returns the latest revisions used by this build formatted as a string.
# Example: "repo1:1234 repo2:4321".
# -----------------------------------------------------------------------------

sub get_youngest_revs {
    my ($youngest_revs) = '';

    for my $key (@{ $build->{repositories} }) {
        my ($r_state) = $build->{state}->{svn}->{$key}; #  Alias
        weaken ($r_state);
        $youngest_revs .= $key . ':' . $r_state->{youngest_rev} . ' ';
    }
    return $youngest_revs;
}


#############################   GET NEW BUILD ID   ############################

sub get_new_build_id
{
    my ($build_day,                     #  Day of year of this build
        $last_build_day,                #  Day of year of last build
        $last_build_no);                #  Number of last build

    #  Create an identifier for this build in the form DDD_XX, where DDD is
    #  the day of the year and XX is a build number incremented once for
    #  each build that day.
    $build_day = (localtime (time ()))[7] + 1;
    if (defined $build->{state}->{last_id}) {
        ($last_build_day, $last_build_no) = 
            split (/_/, $build->{state}->{last_id});
        if ($last_build_day != $build_day) {
            $last_build_no = 0;
        }
    } else {
        $last_build_day = $build_day;
        $last_build_no = 0;
    }
    $build->{state}->{current_id} = $build_day . '_' . ($last_build_no + 1);
}


###############################   START BUILD   ###############################

sub start_build
{
    #  Set list of products to rebuild to all products in this build that need
    #  a rebuild (product state is 'not_up_to_date' or 'dependency_changed').
    $b_products = [];
    undef $b_product;
    for my $product (@{$build->{products}}) {
        my ($s_product) = $build->{state}->{products}->{$product};
        weaken ($s_product);

        if ($s_product->{state} eq 'not_up_to_date') {
            push (@$b_products, $product);
        } elsif ($s_product->{state} eq 'dependency_changed') {
            push (@$b_products, $product);
        }
    }

    #  Setup environment variables for build.
    for my $key (keys %{$build->{environment}}) {
        $ENV{$key} = $build->{environment}->{$key};
    }

    #  Create output directory for build log and packages.
    $build->{output_dir} = $build->{workdir} . '/output';
    if (! -d $build->{output_dir}) {
        mkdir $build->{output_dir} 
            or do {
            &log_message ("E: Could not create directory ",
                "'$build->{output_dir}': $!");
            &raise_exception ($exception_event);
            return;
        };
    }
    $build->{output_dir} = $build->{output_dir} . '/' . 
        $build->{state}->{current_id};
    if (! -d $build->{output_dir}) {
        mkdir $build->{output_dir}
            or do {
            &log_message ("E: Could not create directory ",
                "'$build->{output_dir}': $!");
            &raise_exception ($exception_event);
            return;
        };
    }

    #  Create log file for build output.
    $build->{log_file} = $build->{output_dir} . '/build.log';
    $build->{log_fh} = new IO::File ($build->{log_file}, 'a');
    if (!defined $build->{log_fh}) {
        &log_message ("E: Could not create '", $build->{log_file}, "': ", $!);
        &raise_exception ($exception_event);
        return;
    }
    $build->{log_fh}->autoflush (1);

    #  Log interesting information about this build to log file.
    $build->{log_fh}->print ("I: Build ID: ", 
        $build->{state}->{current_id}, "\n");
    $build->{log_fh}->print ("I: Building configuration: '", 
        $build->{name}, "'\n");
    $build->{log_fh}->print ("I: Building products: ", 
        join (" ", @$b_products), "\n");
    $build->{log_fh}->print ("I: Building revisions: ",
        &get_youngest_revs (), "\n");
    $build->{log_fh}->print ("I: Working directory: ", 
        $build->{workdir}, "\n");
    $build->{log_fh}->print ("I: Output directory: ", 
        $build->{output_dir}, "\n");
    $build->{log_fh}->print ("I: Hostname: ", (uname ())[1], "\n");
    $build->{log_fh}->print ("I: System: ",   (uname ())[0],
        " ", (uname ())[2], "\n");
    $build->{log_fh}->print ("I: Platform: ", (uname ())[4], "\n");
    $build->{log_fh}->print ("I: Environment: \n");
    for my $key (keys %ENV) {
        $build->{log_fh}->print ("I: $key=$ENV{$key}\n");
    }
    $build->{log_fh}->print ("I: ----------------------------------------\n");

    #  Tell the user that we are starting a new build.
    &log_message ("I: New build: ", $build->{state}->{current_id});
    &log_message ("I: Output directory: ", $build->{output_dir});
    &log_message ("I: Products: ", join (" ", @$b_products));
}


#############################   GET NEXT PRODUCT   ############################

sub get_next_product
{
    #  Get next product to build from the list set by &start_build().
    $b_product = shift (@$b_products);
    if (defined ($b_product)) {
        $b_product = $config->{products}->{$b_product};
        $the_next_event = $product_event;
    } else {
        #  No more products to build.
        $the_next_event = $finished_event;
    }
}


#######################   MARK PRODUCTS AS OUT OF DATE   ######################

sub mark_products_as_out_of_date
{
    #  Mark all products in this build as out of date.  Run the first time we
    #  build, or if a build is interrupted.
    for my $key (@{ $build->{products} }) {
        $build->{state}->{products}->{$key}->{state} = 'not_up_to_date';
    }
}


#######################   MARK PRODUCTS AS UP TO DATE   #######################

sub mark_products_as_up_to_date
{
    #  Mark all products in this build as up to date.  Run after completing a
    #  build (successful or not).
    for my $key (@{ $build->{products} }) {
        $build->{state}->{products}->{$key}->{state} = 'up_to_date';
    }
}


#############################   UPDATE PRODUCTS   #############################

sub update_products
{
    my ($c_svn) = $config->{svn};       #  Alias
    weaken ($c_svn);
    my ($products) = 
        &deep_copy ($build->{products});#  Products in this build

    #  Create subpool for this update
    my ($pool) = SVN::Pool->new_default_sub;

    #  Assume products have not changed in SVN.
    $the_next_event = $products_have_not_changed_event;

    #  For all products used in this build:
    while (my $key = shift (@$products)) {
        my ($product)   = $config->{products}->{$key};
        my ($repos)     = $c_svn->{$product->{repos}};
        my ($s_repos)   = $build->{state}->{$repos};
        my ($s_product) = $build->{state}->{products}->{$key};
        weaken ($product);
        weaken ($repos);
        weaken ($s_repos);
        weaken ($s_product);

        #  Check if the product has changed in SVN.
        eval {
        $repos->{ctx}->status (
            $product->{path},               #  Path to working copy 
            $s_repos->{youngest_rev},       #  Rev to check against
            sub { &check_status_cb ($s_product, @_) },
            1,                              #  Recursive   
            0,                              #  Retrieve only interesting entries
            1,                              #  Ask server for up to date info
            0);                             #  Honour svn:ignore props
        };
        if ($@) {
            &log_message ("E: Error checking status of product '", 
                $product->{name}, "': ", $@);
            &raise_exception ($svn_error_event);
            return;
        }

        #  Product is/was up to date.
        if ($s_product->{state} eq 'up_to_date') {

        #  Product has changed in SVN, or was marked as out of date to force
        #  an update and rebuild.  (e.g. the previous build was interrupted)
        } elsif ($s_product->{state} eq 'not_up_to_date') {
            eval {
                $repos->{ctx}->update (
                    $product->{path},         #  Path to working copy  
                    $s_repos->{youngest_rev}, #  Rev to update to
                    1);                       #  Recursive
            };
            if ($@) {
                &log_message ("E: Error updating product '", 
                    $product->{name}, "': ", $@);
                &raise_exception ($svn_error_event);
                return;
            }

            #  Mark all dependent products as needing a rebuild.
            for my $key (@$products) {
                $build->{state}->{products}->{$key}->{state} 
                    = 'dependency_changed';
            }
            $the_next_event = $products_have_changed_event;

        #  A product that this product depends on has changed.  Force a rebuild.
        } elsif ($s_product->{state} eq 'dependency_changed') {
            $the_next_event = $products_have_changed_event;

        } else {
            &log_message ("E: Unknown state '", $s_product->{state}, 
                "' for product '", $product->{name}, "'");
            &raise_exception ($exception_event);
            return;
        }
    }

    if ($the_next_event == $products_have_not_changed_event) {
        &log_message ("I: Products have not changed in SVN, waiting");
    }

    undef $products;  # Force destruction
}


#  Callback called by SVN::Client::status for each 'interesting' WC item.
sub check_status_cb {
    my ($product, 
        $path,
        $wc_status) = @_;
    my ($wc_entry) = $wc_status->entry ();

    if (defined $wc_entry) {
        if ($wc_status->text_status () != $SVN::Wc::Status::normal) {
            &log_message ("W: ", $path, " has unknown status ", 
                $wc_status->text_status ());
        }
        $product->{state} = 'not_up_to_date';
    } else {
        #  Item not versioned, ignore.
    }
}


#############################   PREPARE PRODUCT   #############################

sub prepare_product
{
    my ($status);

    chdir ($b_product->{path});
    $status = &run_command ("boom clean", 1);
    if (!defined ($status) || $status) {
        &log_message ("E: Clean of product '", $b_product->{name}, "' failed");
        &raise_exception ($build_error_event);
        return;
    }
    $status = &run_command ("boom configure", 1);
    if (!defined ($status) || $status) {
        &log_message ("E: Configure of product '", $b_product->{name}, "' failed");
        &raise_exception ($build_error_event);
        return;
    }
}


##############################   BUILD PRODUCT   ##############################

sub build_product
{
    my ($status);

    chdir ($b_product->{path});
    $status = &run_command ("boom build", 1);
    if (!defined ($status) || $status) {
        &log_message ("E: Build of product '", $b_product->{name}, "' failed");
        &raise_exception ($build_error_event);
        return;
    }
}


#############################   INSTALL PRODUCT   #############################

sub install_product
{
    my ($status);

    chdir ($b_product->{path});
    $status = &run_command ("boom install", 1);
    if (!defined ($status) || $status) {
        &log_message ("E: Install of product '", $b_product->{name}, "' failed");
        &raise_exception ($build_error_event);
        return;
    }
}


###############################   TEST PRODUCT   ##############################

sub test_product
{
    my ($status);

    chdir ($b_product->{path});
    $status = &run_command ("boom test", 1);
    if (!defined ($status) || $status) {
        &log_message ("E: Tests for product '", $b_product->{name}, "' failed");
        &raise_exception ($build_error_event);
        return;
    }
}


#############################   PACKAGE PRODUCT   #############################

sub package_product
{
    my ($status);

    chdir ($b_product->{path});
    unlink (<*.tar.gz>);
    unlink (<*.zip>);
    $status = &run_command ("boom distrev", 1);
    if (!defined ($status) || $status) {
        &log_message ("E: Packaging of product '", $b_product->{name}, "' failed");
        &raise_exception ($build_error_event);
        return;
    }
}


##############################   UPLOAD PRODUCT   #############################

sub upload_product
{
    copy (<*.tar.gz>, $build->{output_dir})
        or do {
        &log_message ("E: Could not copy packages of product '", 
            $b_product->{name}, "' to '$build->{output_dir}'");
        &raise_exception ($build_error_event);
        return;
    };
    copy (<*.zip>, $build->{output_dir})
        or do {
        &log_message ("E: Could not copy packages of product '", 
            $b_product->{name}, "' to '$build->{output_dir}'");
        &raise_exception ($build_error_event);
        return;
    };

    &log_message ("I: Packages of product '$b_product->{name}' uploaded to ",
        "'$build->{output_dir}'");
}


#########################   MARK BUILD AS SUCCEEDED   #########################

sub mark_build_as_succeeded
{
    #  Set build state, inform user, close the build log file.
    $build->{state}->{current_state} = 'succeeded';
    &log_message ("I: Build ", $build->{state}->{current_id}, " succeeded");
    $build->{log_fh}->print ("I: Build succeeded\n");
    $build->{log_fh}->close ();
}


###########################   MARK BUILD AS FAILED   ##########################

sub mark_build_as_failed
{
    #  Set build state, inform user, close the build log file.
    $build->{state}->{current_state} = 'failed';
    &log_message ("I: Build ", $build->{state}->{current_id}, " FAILED");
    $build->{log_fh}->print ("I: Build failed\n");
    $build->{log_fh}->close ();
}

########################   MARK BUILD AS INTERRUPTED   ########################

sub mark_build_as_interrupted
{
    #  Set build state, inform user, close the build log file.
    $build->{state}->{build_state} = 'interrupted';
    &log_message ("I: Build ", $build->{state}->{current_id}, " interrupted");
    $build->{log_fh}->print ("I: Build interrupted\n");
    $build->{log_fh}->close ();
}


############################   SEND BUILD REPORT   ############################

sub send_build_report
{
    my ($report_text,
        $time_now,
        $youngest_revs);

    if (!defined $lwp_ua) {
        return;                         #  Upload not configured
    }
  
    if (exists $config->{upload}->{upload_status} &&
        defined $config->{upload}->{upload_status}) {
        $time_now      = &format_time ();
        $youngest_revs = &get_youngest_revs ();
        $report_text   = <<"EOT"
Configuration: $build->{name}

ID: $build->{state}->{current_id}
Status: $build->{state}->{current_state}

Date: $time_now
Revisions: $youngest_revs

[[Build log for $build->{_key}]]
EOT
    ;
        &wiki_upload ("Build status for $build->{_key}", $report_text);
    }
    if (exists $config->{upload}->{upload_log} &&
        defined $config->{upload}->{upload_log}) {
        &wiki_upload ("Build log for $build->{_key}", $build->{log_file}, 1);
    }
}


###############################   WAIT A WHILE   ##############################

sub wait_a_while
{
#    sleep 15;
}


# -----------------------------------------------------------------------------
# Function: $deep_copy_of_ref = &deep_copy ($ref)
#
# Returns a deep copy of $ref and all it's children (if any).
# -----------------------------------------------------------------------------


sub deep_copy {
    my $this = shift;
    if (not ref $this) {
        $this;
    } elsif (ref $this eq "ARRAY") {
        [map deep_copy($_), @$this];
    } elsif (ref $this eq "HASH") {
        +{map { $_ => deep_copy($this->{$_}) } keys %$this};
    } else { die "what type is $_?" }
}


# -----------------------------------------------------------------------------
# Function: &log_start ($filename)
#
# Start logging to the file $name.  Returns undef if there was an error.
# -----------------------------------------------------------------------------

sub log_start {
    my ($filename) = @_;                # Logfile name

    # Try to open log file.
    $log_fh = new IO::File ($filename, 'a');
    if (!defined $log_fh) {
        &log_message ("E: Could not open logfile '", $filename, "': ", $!);
        return (undef);
    }

    $log_fh->autoflush (1);

    &log_message ("I: Log begins");
    return (1);
}


# -----------------------------------------------------------------------------
# Function: &log_stop ()
#
# Finish logging to a log file.  Prints a "Log ends" message to the file and
# closes it.
# -----------------------------------------------------------------------------

sub log_stop {
    &log_message ("I: Log ends");
    $log_fh->close () if defined ($log_fh);
}


# -----------------------------------------------------------------------------
# Function: &log_message (@message)
#
# Logs a message to standard error or a log file, prefixed with the current
# local time.
# -----------------------------------------------------------------------------

sub log_message {
    # Use STDERR if no log file configured/open.
    if (!defined ($log_fh)) {
        $log_fh = new IO::Handle;
        $log_fh->fdopen (\*STDERR, 'w');
        $log_fh->autoflush (1);
    }

    # Write message to log.
    $log_fh->print (&format_time (), " autobuild ",  @_, "\n");
}


# -----------------------------------------------------------------------------
# Private Function: &format_time ()
#
# Returns the current local time, formatted as a string.
# -----------------------------------------------------------------------------

sub format_time {
    return strftime ("%Y-%m-%d %H:%M:%S", localtime (time ()));
}


# -----------------------------------------------------------------------------
# Function: &run_command ($command, $do_log)
#
# Run an external command and wait for it to complete.  Optionally append all 
# output to build log, if $do_log is set.  Returns undef if there was an error,
# the exit status of the external command if not.
# -----------------------------------------------------------------------------

sub run_command {
    my ($command,
        $do_log) = @_;
    my ($real_command) = $command;

    if ($do_log) {
        $real_command .= " >>$build->{log_file} 2>&1";
        $build->{log_fh}->print ("I: Executing: '$command'\n");
    }
    system ($real_command);
    if ($? == -1) {
        &log_message ("E: Failed to execute '$command': ", $!);
        return undef;
    }
    $build->{log_fh}->print ("I: ----------------------------------------\n")
        if ($do_log);
    return ($? >> 8);
}


# -----------------------------------------------------------------------------
# Function: &wiki_upload ($title, $content, $upload_as_file)
#
# Upload a page to the Wiki configured in $config.  The page title will be
# $title and the content will be $content.  If you set $upload_as_file, then
# $content should be a file name to upload.
# -----------------------------------------------------------------------------

sub wiki_upload {
    my ($title, 
        $content, 
        $upload_as_file) = @_;
    my ($request,                       #  HTTP::Request object
        $response);                     #  HTTP::Response object

    if (defined $upload_as_file) {
        $request =
            POST $config->{upload}->{wiki_url},
            Content_Type => 'multipart/form-data',
            Content      => [ title    => $title,
                              username => 'autobuild',
                              file     => [$content],
                            ];
    } else {
        $request =
            POST $config->{upload}->{wiki_url},
            Content => [ title    => $title,
                         username => 'autobuild',
                         text     => $content,
                       ];
    }
   
    $response = $lwp_ua->request ($request);
    if (!$response->is_success && $response->status_line !~ m/^3\d\d/) {
        &log_message ("E: Error uploading '$title' to Wiki: ", 
            $response->status_line);
    }
}


