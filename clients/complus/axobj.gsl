------------------------------------------------------------------------
-
-   axobj - ActiveX Server Object implementation
-
-   Written: 2000/01/18
-   Revised: 2004/12/09  Pieter Hintjens <pieter@imatix.com>
-
-   This module processes Object implementation in ActiveX server object.
-
-
------------------------------------------------------------------------
function CPP_PARAM (nb)
------------------------------------------------------------------------
    param = ""
    for argument
        param += "$(type:) $(name:)"
        if index (argument) < my.nb
           param += ", "
        endif
    endfor
    for return
        if string.length (param) > 0
            param += ", "
        endif
        param += "$(type:) *pVal"
    endfor
    if string.length (param) = 0
        param = "void"
    endif
endfunction

------------------------------------------------------------------------
-   Generates bodies for object methods
------------------------------------------------------------------------
.macro add_msg2lock (message2log)
{
  FILE *file;
  if ((file = fopen ("e:\\\\$(object.name:).log", "at")) != NULL) {
      fputs ("$(my.message2log?)\\r\\n", file);
      fflush (file);
      fclose (file);
  }  
}
.endmacro

.macro method_header (safe, is_cpp_object)
.   if debug ?= 1
    FILE
        *tracefile;
.   endif
.   if !my.safe
      GET_LOCK {
.#mutex_counter++;
.#last_mutex_func = "$(object.name:)::$(name:)";
.#      if (lock_function (10000) == TRUE) {
.   endif
.if my.is_cpp_object ?= 0
    __try {
.endif
.   if debug ?= 1
    tracefile = fopen ("c:\\\\axobj.log", "a");
    fprintf (tracefile, "Start C$(object.name:)::$(name:)\\n");
    fflush (tracefile);
    fclose (tracefile);
.   endif
.endmacro


.function method_body ()
    for local
        >$(local.:)
    endfor
    >USES_CONVERSION;
    >
    method_header (threadsafe?0, use_cpp_object?0)
    for return
        >    if (pVal == NULL)
        >        RETURN_AND_RELEASE (S_OK);
    endfor
    >$(.?'':)
    method_footer (threadsafe?0, use_cpp_object?0)
.endfunction

.macro method_footer (safe, is_cpp_object)
.   if debug ?= 1
    tracefile = fopen ("c:\\\\axobj.log", "a");
    fprintf (tracefile, "Exit C$(object.name:)::$(name:)\\n");
    fflush (tracefile);
    fclose (tracefile);
.   endif
.   if !my.safe
.#          unlock_function ();
            UNLOCK;
.endif
.if my.is_cpp_object ?= 0
    }
    __except (log2event ("Error in method C$(object.name:)::$(name:)"), 1) {
        UNLOCK;
    }
.endif
.   if !my.safe

      }
    else {
        char
            buffer [1024];
        sprintf (buffer, "Mutex error C$(object.name:)::$(name:):\\nmutex = %X\\nerror code: %ld",
                 m_mutex, GetLastError ());

        UNLOCK; 
        log2event (buffer);
        return (S_FALSE);
      }     
.   endif
.endmacro

------------------------------------------------------------------------
function get_c_type (type, pointer)
------------------------------------------------------------------------
    if my.type = "string"
        c_type = "char"
    elsif my.type = "bool"
        c_type = "BOOL"
    else
        c_type = my.type
    endif
    if my.pointer ?= "yes"
        c_type += " *"
    endif
endfunction
-
------------------------------------------------------------------------
function get_doc_type (type)
------------------------------------------------------------------------
    if my.type = "bstr" | my.type = "BSTR"
        doc_type = "String"
    elsif my.type = "bool" | my.type = "BOOL"
        doc_type = "Boolean"
    else
        doc_type = my.type
    endif
endfunction
.-
------------------------------------------------------------------------
function generate_idl
------------------------------------------------------------------------
echo "Create IDL file $(class.object_name)/$(class.name).idl..."
output "$(class.object_name)/$(class.name).idl"
>// $(class.name).idl : IDL source for $(class.name).dll
>//
>
>// This file will be processed by the MIDL tool to
>// produce the type library ($(class.name).tlb) and marshalling code.
>
>import "oaidl.idl";
>import "ocidl.idl";
for object
    method_id = 1
    echo "  Add object $(class.object_name)..."
>	[
>		object,
>		uuid($(uuid:)),
>		dual,
>		helpstring("$(name) Interface"),
>		pointer_default(unique)
>	]
> interface I$(class.object_name) : IDispatch
>	{
    for method
        param = ""
        for argument
            if optional ?= 1
               param += "[in, optional] "
            else
               param += "[in] "
            endif
            param += "$(type:) $(name:)"
            if index (argument) < count (method.argument)
               param += ", "
            endif
        endfor
        if type ?= "event"
>        HRESULT $(name:) ($(param:));
        else
>        [id($(method_id)), helpstring("method $(name:) $(param:)")] HRESULT $(name:) ($(param:));
            method_id = method_id + 1
        endif
    endfor
- the memory_snapshot method is implemented in script ! --> we add an entry for it
>        [id($(method_id)), helpstring("method memory_snapshot [in] VARIANT delay, [in, optional] VARIANT fullpath")] HRESULT memory_snapshot ([in] VARIANT delay, [in, optional] VARIANT fullpath);
    method_id = method_id + 1
    last_name = ""
    for property by name
        if last_name = ""
            last_name = name
        elsif name <> last_name
            last_name  = name
            method_id += 1
        endif
        param = ""
        for argument
            if optional ?= 1
                param += "[in, optional] "
            else
                param += "[in] "
            endif
            param += "$(type:) $(name:)"
            if index (argument) < count (property.argument)
               param += ", "
            endif
        endfor
        for return
            if string.length (param) > 0
                param += ", "
            endif
            define param += "[out, retval] $(type:) *pVal"
        endfor
        if count (return) > 0
>        [propget, id($(method_id)), helpstring("property $(name:) $(param:)")] HRESULT $(name:)($(param:));
        else
>        [propput, id($(method_id)), helpstring("property $(name:) $(param:)")] HRESULT $(name:)($(param:));
        endif
    endfor
>	};
>
endfor
>[
>	uuid($(class.uuid:)),
>	version($(class.version:)),
>   helpstring("$(class.description:) - $(Class.object_name)")
>]
>library $(CLASS.NAME)Lib
>{
>	importlib("stdole32.tlb");
>	importlib("stdole2.tlb");
for object
>	[
>		uuid($(class_uuid:)),
>   helpstring("$(class.object_name) Class")
>	]
> coclass $(class.object_name)
>	{
>   [default] interface I$(class.object_name);
>	};
endfor
>};
close
endfunction

------------------------------------------------------------------------
function generate_object
------------------------------------------------------------------------
for object
    echo "Create file $(class.object_name)/$(class.object_name:).h"
    output "$(class.object_name)/$(class.object_name:).h"
>// $(class.object_name).h : Declaration of the C$(class.object_name)
>
>#ifndef __$(CLASS.OBJECT_NAME)_H_
>#define __$(CLASS.OBJECT_NAME)_H_
>
>#include "resource.h"       // main symbols
>#include <mtx.h>
    for object.rule where name = "include_library"
>$(rule.:)
    endfor
>
>/////////////////////////////////////////////////////////////////////////////
>// C$(class.object_name)
>class ATL_NO_VTABLE C$(class.object_name) :
>	public CComObjectRootEx<CComSingleThreadModel>,
> public CComCoClass<C$(class.object_name), &CLSID_$(class.object_name)>,
>   public IObjectControl,
> public IDispatchImpl<I$(class.object_name), &IID_I$(class.object_name), &LIBID_$(CLASS.NAME)Lib>
>{
>public:
> C$(class.object_name)(void);
> ~C$(class.object_name)(void);
>
>DECLARE_REGISTRY_RESOURCEID(IDR_$(CLASS.OBJECT_NAME))
>
>DECLARE_PROTECT_FINAL_CONSTRUCT()
>
>DECLARE_NOT_AGGREGATABLE(C$(class.object_name))
>
>BEGIN_COM_MAP(C$(class.object_name))
>   COM_INTERFACE_ENTRY(I$(class.object_name))
>   COM_INTERFACE_ENTRY(IObjectControl)
>   COM_INTERFACE_ENTRY(IDispatch)
>END_COM_MAP()
>
>// IObjectControl
>public:
>    STDMETHOD(Activate)();
>    STDMETHOD_(BOOL, CanBePooled)();
>    STDMETHOD_(void, Deactivate)();
>
>    CComPtr<IObjectContext> m_spObjectContext;
>
>// I$(class.object_name)
>public:
    for method
       CPP_PARAM (count (method.argument))
> STDMETHOD($(name:))($(param:));
    endfor
    for property
       CPP_PARAM (count (property.argument))
       if count (property.return) > 0
           prop_type = "get_"
       else
           prop_type = "put_"
       endif
> STDMETHOD($(prop_type:)$(name:))($(param:));
    endfor
>
>public:
> STDMETHOD(memory_snapshot)(VARIANT delay, VARIANT fullpath);
>
>private:
    for function
        CPP_PARAM (count (function.argument))
        > void $(name:)($(param:));
        >
    endfor
>
>private:
>    BOOL        m_have_context;
    for context
        for field
            get_c_type (type, reference)
            >    $(c_type:)  m_$(name:);
        endfor
    endfor
>
> private:
>    static  UINT m_timer_id;
>    static  char * m_timer_filename;
>    static  void log2event (char *message);
>    HANDLE  m_mutex;
>    BOOLEAN m_use_mutex;
>    int     get_nb_processor (void);
> public:
>    static void mem_dump (void);
>
>};
>
>#endif //__$(CLASS.OBJECT_NAME)_H_
    close
    echo "Create file $(class.object_name)/$(class.object_name:).cpp"
    output "$(class.object_name:)/$(class.object_name).cpp"
>// $(class.object_name:).cpp : Implementation of C$(class.object_name:)
>#include "sfl.h"
>#include "sflunic.h"
for class.import
    >#include "$(import.class).h"
endfor
>#undef  ASSERT
>#define ASSERT(f) if (f); else { \\
>    coprintf ("Assertion failed: %s/%s", __FILE__, __LINE__); \\
>    sys_assert (__FILE__, __LINE__); }
>#include "stdafx.h"
>#include "$(class.name).h"
>#include <comdef.h>
>#include "$(class.object_name).h"

>#define UNLOCK if (m_mutex) { ReleaseMutex (m_mutex); CloseHandle (m_mutex); m_mutex = NULL;}
>#define GET_LOCK if (m_use_mutex) {UNLOCK;                     \\
>    m_mutex = CreateMutex (NULL, FALSE, "$(class.name)"); }\\
>                                                               \\
>    if (m_use_mutex == FALSE                                   \\
>    ||  (m_mutex != INVALID_HANDLE_VALUE                       \\
>    &&  m_mutex != NULL                                        \\
>    &&  WaitForSingleObject (m_mutex, 10000) == WAIT_OBJECT_0)) 
>
>#define RETURN_AND_RELEASE_PROP   { UNLOCK; return; }
>#define RETURN_AND_RELEASE(rc)    { UNLOCK; return (rc); }
>
>/* Get a char * from a variant value                                         */
>#define VARIANT2STRING(var, str) {                                           \\
>    VARIANT dest;                                                            \\
>    str = NULL;                                                              \\
>    if (var.vt != VT_ERROR                                                   \\
>    &&  var.vt != VT_EMPTY                                                   \\
>    &&  var.vt != VT_NULL)                                                   \\
>      {                                                                      \\
>        memset (&dest, 0, sizeof (VARIANT));                                 \\
>        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \\
>            str = OLE2T (dest.bstrVal);                                      \\
>      }                                                                      \\
>}
>
>#define VARIANT2BSTR(var, str) {                                             \\
>    VARIANT dest;                                                            \\
>    str = NULL;                                                              \\
>    if (var.vt != VT_ERROR                                                   \\
>    &&  var.vt != VT_EMPTY                                                   \\
>    &&  var.vt != VT_NULL)                                                   \\
>      {                                                                      \\
>        memset (&dest, 0, sizeof (VARIANT));                                 \\
>        if (::VariantChangeType (&dest, &var, 0, VT_BSTR) == S_OK)           \\
>            str = dest.bstrVal;                                              \\
>      }                                                                      \\
>}
>
>/* Get a Boolean from a variant value                                       */
>#define VARIANT2BOOL(var, str) {                                             \\
>    VARIANT dest;                                                            \\
>    str = FALSE;                                                             \\
>    if (var.vt != VT_ERROR                                                   \\
>    &&  var.vt != VT_EMPTY                                                   \\
>    &&  var.vt != VT_NULL)                                                   \\
>      {                                                                      \\
>        memset (&dest, 0, sizeof (VARIANT));                                 \\
>        if (::VariantChangeType (&dest, &var, 0, VT_BOOL) == S_OK)           \\
>            str = (BOOL)dest.boolVal;                                        \\
>      }                                                                      \\
>}
>
>#define VARIANT2LONG(var, str) {                                             \\
>    VARIANT dest;                                                            \\
>    str = 0L;                                                                \\
>    if (var.vt != VT_ERROR                                                   \\
>    &&  var.vt != VT_EMPTY                                                   \\
>    &&  var.vt != VT_NULL)                                                   \\
>      {                                                                      \\
>        memset (&dest, 0, sizeof (VARIANT));                                 \\
>        if (::VariantChangeType (&dest, &var, 0, VT_I4) == S_OK)             \\
>            str = dest.lVal;                                                 \\
>      }                                                                      \\
>}
>
>#define VARIANT2DOUBLE(var, str) {                                           \\
>    char                                                                     \\
>        *val;                                                                \\
>    str = 0;                                                                 \\
>    VARIANT2STRING (var, val);                                               \\
>    if (val)                                                                 \\
>        str = atof (val);                                                    \\
>}
>
    for object.rule where name = "include_definition"
        >$(rule.:)
    endfor
>
>
>UINT   C$(class.object_name)::m_timer_id = 0;
>char * C$(class.object_name)::m_timer_filename = NULL;
>
#>static long  mutex_counter   = 0;
#>static char *last_mutex_func = "";

>void CALLBACK memory_dump (UINT idTimer, UINT msg, DWORD dw1, DWORD dw2, DWORD dw3)
>{
>   C$(class.object_name)::mem_dump ();
>}
>
>
>int C$(class.object_name:)::get_nb_processor(void)
>{
>    static int
>        feedback = 0;
>    SYSTEM_INFO
>        si;
>    if (feedback == 0)
>      {
>        GetSystemInfo  (&si);
>        feedback = (int)si.dwNumberOfProcessors;
>      }
>    return (feedback);
>}
>
>/////////////////////////////////////////////////////////////////////////////
>// C$(class.object_name): constructor
>
>C$(class.object_name:)::C$(class.object_name:)(void)
>{
>
>    m_have_context = FALSE;
    for context
        for field
            if reference ?= "yes"
                >    m_$(name:) = NULL;
            elsif type = "bool"
                >    m_$(name:) = FALSE;
            elsif !defined (noinit)
                >    m_$(name:) = 0;
            endif
        endfor
    endfor
    >    m_mutex = NULL;
    >    m_use_mutex = (get_nb_processor () > 1)? TRUE: FALSE;
    for object.rule where name = "constructor"
        >$(rule.:)
    endfor
>}
>
>// C$(class.object_name:): Destructor
>
>C$(class.object_name:)::~C$(class.object_name:)(void)
>{
    for context
        for field
            if "$(reference?)" = "yes" & free ?= "yes"
                >    if (m_$(name:))
                >      {
                >        mem_free (m_$(name:));
                >        m_$(name:) = NULL;
                >      }
            endif
        endfor
    endfor
    for object.rule where name = "destructor"
        >$(rule.:)
    endfor
>   UNLOCK;
>}
>
>
>HRESULT C$(class.object_name:)::Activate()
>{
>    HRESULT hr = GetObjectContext (&m_spObjectContext);
>    if (SUCCEEDED (hr))
>      {
>        m_have_context = TRUE;
>		 return S_OK;
>      }
>	return hr;
>}
>
>BOOL C$(class.object_name:)::CanBePooled ()
>{
>	return (FALSE);
>}
>
>void C$(class.object_name:)::Deactivate ()
>{
    for rule where name = "deactivate"
        for local
            >$(local.:)
        endfor
        >$(rule.:)
    endfor
>    m_have_context = FALSE;
>    m_spObjectContext.Release ();
>}
>
    for function
        for rule
            rule.threadsafe = 1
        endfor
        CPP_PARAM (count (function.argument))
        descr = ""
        for doc
            descr = descr + doc
        endfor
>
>/*---------------------------------------------------------------------------
>  Function: $(name:)
>
>  $(descr:)
>  ---------------------------------------------------------------------------*/
>
>void C$(class.object_name:)::$(name:) ($(param:))
>{
    method_body ()
>}
    endfor

    for method
       CPP_PARAM (count (method.argument))
       descr = ""
       for doc
           descr += doc.
       endfor
>
>
>/*---------------------------------------------------------------------------
>  Method: $(name:)
>
>  $(descr:)
>  ---------------------------------------------------------------------------*/
>
>STDMETHODIMP C$(class.object_name:)::$(name:) ($(param:))
>{
    method_body ()
>    return (S_OK);
>}
    endfor
    for property by name
       CPP_PARAM (count (property.argument))
       descr = ""
       for doc
           descr += doc.
       endfor
       if count (property.return) > 0
           prop_type = "get_"
       else
           prop_type = "put_"
       endif
>
>
>/*---------------------------------------------------------------------------
>  Property: $(name:)
>
>  $(descr:)
>  ---------------------------------------------------------------------------*/
>
>STDMETHODIMP C$(class.object_name:)::$(prop_type:)$(name:) ($(param:))
>{
    method_body ()
>    return (S_OK);
>}
    endfor

>/*---------------------------------------------------------------------------
>  Property: memory_snapshot
>
>  Enables a snapshot of allocated memory to a file every 'delay'
>  seconds.  NULL arguments or zero delay disables snapshot
>  ---------------------------------------------------------------------------*/
>
> STDMETHODIMP C$(class.object_name:)::memory_snapshot (VARIANT delay, VARIANT fullpath)
>{
>    char
>        *delay_val,
>        *path_val;
>    UINT
>        ms_delay;
>    USES_CONVERSION;
>
>    GET_LOCK {    
>
>    if (m_timer_id != 0)
>      {
>        timeKillEvent (m_timer_id);
>        m_timer_id = 0;
>      }
>    if (m_timer_filename != NULL)
>      {
>        strfree (&m_timer_filename);
>        m_timer_filename = NULL;
>      }
>
>    VARIANT2STRING (delay, delay_val);
>    VARIANT2STRING (fullpath, path_val);
>
>    if ( (delay_val == NULL) || (path_val == NULL) )
>        RETURN_AND_RELEASE (S_OK)
>
>    ms_delay = atoi (delay_val) * 1000;
>
>    if (ms_delay > 0)
>        m_timer_id = timeSetEvent (ms_delay, 1000, memory_dump, 0, TIME_PERIODIC);
>
>    m_timer_filename = strdupl (path_val);
>
>    UNLOCK;
>    }
>    return (S_OK);
>}
>
>
>/* static function used by CALLBACK */
>void C$(class.object_name)::mem_dump (void)
>{
>    static char buffer[256];
>    FILE *fd = NULL;
>
>    if (C$(class.object_name)::m_timer_filename != NULL)
>       fd = file_open (C$(class.object_name)::m_timer_filename , 'a');
>
>    if (fd)
>      {
>        sprintf (buffer,
>                 "%s %s : %10s components - %10i allocated bytes",
>                 conv_date_pict (date_now(), "yy/mm/dd"),
>                 conv_time_pict (time_now(), "hh:mm:ss"),
>                 "$(CLASS.OBJECT_NAME)",
>                 mem_used () );
>        file_write  (fd, buffer);
>        file_close (fd);
>      }
>}
>
>
>void C$(class.object_name)::log2event (char *message)
>{
>    static char
>        *strings       [2],
>        message_buffer [LINE_MAX + 1];
>    HANDLE
>        event_source_handle;
>
>    /* Use event logging to log the error.                                   */
>    event_source_handle = RegisterEventSource (NULL, "AMQ_component_$(class.object_name)");
>
>    strcpy (message_buffer, "AMQ $(class.object_name) error");
>    strings [0] = message_buffer;
>    strings [1] = message;
>
>    if (event_source_handle)
>      {
>        ReportEvent (event_source_handle,/* handle of event source           */
>            EVENTLOG_ERROR_TYPE,         /* event type                       */
>            0,                           /* event category                   */
>            0,                           /* event ID                         */
>            NULL,                        /* current user's SID               */
>            2,                           /* strings in variable strings      */
>            0,                           /* no bytes of raw data             */
>            (const char **)strings,      /* array of error strings           */
>            NULL);                       /* no raw data                      */
>
>        DeregisterEventSource (event_source_handle);
>      }
>}

    close
endfor
endfunction

------------------------------------------------------------------------
function generate_doc
------------------------------------------------------------------------
for object
    echo "Create file $(class.object_name:).htm"
    output "$(class.object_name:).htm"
><html><head><title>
>$(class.object_name) documentation</title></head>
><style><!--
>th         {font: small    sans-serif; color:white}
>td         {font: x-small  sans-serif; color:black}
>a.index    {font:          sans-serif; color:green; text-decoration:none}
>a.navig    {font: bold x-small sans-serif; color:white; text-decoration:none}
>a:hover    {color:blue; text-decoration:underline; background-color:white;}
>--></style>
><body topmargin=0 leftmargin=0 rightmargin=0 bgcolor="#F7FFE7">
><H1><u>$(class.object_name) Component</u></h1><pre>
  descr = ""
  for doc
    descr = descr + doc.
  endfor
>$(descr:)
  descr = ""
></pre><a name="top"></a>
if count (object.method) > 0
><H3>Methods</H3><center><table border=0 cellpadding=2 cellspacing=0 width="90%">
><tr bgcolor=black><th colspan=2>Name&nbsp;</th><th>Description</th></tr>
    current_color = "#E0EEE0"
    for method by name
        descr = ""
        for doc
            descr = descr + doc.
        endfor
><tr bgcolor="$(current_color:)"><td colspan=2><a class="index" href="#$(name)"><b>$(name:)</b></a>&nbsp;</td><td>$(descr:)</td></tr>
        if current_color = "#E0EEE0"
            current_color = "#FFFFFF"
        else
            current_color = "#E0EEE0"
        endif
    endfor
></table></center>
endif
if count (object.property) > 0
><H3>Properties</H3><center><table border=0 cellpadding=2 cellspacing=0 width="90%">
><tr bgcolor=black><th colspan=2>Name&nbsp;</th><th>Description</th></tr>
    current_color = "#E0EEE0"
    last_name = ""
    for property by name
        descr = ""
        for doc
            descr = descr + doc.
        endfor
        if name <> last_name
><tr bgcolor="$(current_color:)"><td colspan=2><a class="index" href="#$(name)"><b>$(name:)</b></a>&nbsp;</td><td>$(descr:)</td></tr>
            if current_color = "#E0EEE0"
                current_color = "#FFFFFF"
            else
                current_color = "#E0EEE0"
            endif
            last_name = name
        endif
    endfor
></table></center>
endif
    for method by name
><center><hr width="30%"></center><a name="$(name)"></a>
        descr = ""
        for doc
            descr = descr + doc.
        endfor
><table width = "70%"><tr><td><h2>Method : $(name:)</h2></td>
><td align=right><a class="index" href="#top">Top</a></td></tr></table>
><pre>$(descr:)</pre>
    if (count (method.argument) > 0)
><p><center><table border="1" width = "50%">
><tr bgcolor=black><th width = "30%"><i>Parameters</i></td><th>Type</th><th>Required</th></tr>
      for argument
          if optional?0 = 1
              opt = "No"
          else
              opt = "Yes"
          endif
          get_doc_type (type)
  ><tr><td><b>&nbsp;$(name:)&nbsp;</b></td><td>$(doc_type:)</td><td>$(opt:)</td></tr>
      endfor
></table></center>
    endif
    endfor
    last_name = ""
    for property by name
        descr = ""
        for doc
            descr += doc.
        endfor
        if count (return) > 0
            prop_type = "Get"
        else
            prop_type = "Put"
        endif
        if last_name <> name
><center><hr width="30%"></center><a name="$(name)"></a>
><table width = "70%"><tr><td><h2>Property : $(name:)</h2></td>
><td align=right><a class="index" href="#top">Top</a></td></tr></table>
><pre>$(descr:)</pre>
            last_name = name
        endif
><h3><P>Property type: $(prop_type:)</h3>
    if (count (property.argument) > 0)
><p><center><table border="1" width = "50%">
><tr bgcolor=black><th width = "30%"><i>Parameters</i></td><th>Type</th><th>Required</th></tr>
      for argument
          if (optional?0) = 1
              opt = "No"
          else
              opt = "Yes"
          endif
          get_doc_type (type)
><tr><td><b>&nbsp;$(name:)&nbsp;</b></td><td>$(doc_type:)</td><td>$(opt:)</td></tr>
      endfor
></table></center>
    endif
      for return
          get_doc_type (type)
><h3>Returns a $(doc_type:) value</h3>
      endfor
      for sample
><pre>Sample: $(sample.:)</pre>
      endfor
    endfor
></body></html>
    close
endfor
endfunction

.macro generate_main_obj
.  echo ("Generating $(class.object_name)/$(class.name).cpp...")
.  output ("$(class.object_name)/$(class.name).cpp")
// $(class.name).cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for $(class.name).idl by adding
//      the following files to the Outputs.
//          $(class.name)_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f $(class.name)ps.mk in the project directory.

#include "sfl.h"
#include "sflunic.h"
.for class.import
#include "$(import.class).h"
.endfor
#undef  ASSERT
#define ASSERT(f) if (f); else { \\
    coprintf ("Assertion failed: %s/%s", __FILE__, __LINE__); \\
    sys_assert (__FILE__, __LINE__); }
#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "$(class.name).h"
#include "dlldatax.h"

#include "$(class.name)_i.c"
.for object
#include "$(class.object_name).h"
.endfor

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
.for object
OBJECT_ENTRY(CLSID_$(class.object_name), C$(class.object_name))
.endfor
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_$(NAME)Lib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}


void
main (void)
{
}
.  close
.  echo ("Generating $(class.object_name)/resource.h...")
.  output ("$(class.object_name)/resource.h")
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by $(class.name).rc
//

#define IDS_PROJNAME                    100
#define IDR_$(OBJECT_NAME)              101
.    index = 101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           $(index + 1)
#endif
#endif
.  close
.  echo ("Generating $(class.object_name)/$(class.name).rc...")
.  output ("$(class.object_name)/$(class.name).rc")
//Microsoft Developer Studio generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// French (France) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_FRA)
#ifdef _WIN32
LANGUAGE LANG_FRENCH, SUBLANG_FRENCH
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE DISCARDABLE
BEGIN
    "resource.h\\0"
END

2 TEXTINCLUDE DISCARDABLE
BEGIN
    "#include ""winres.h""\\r\\n"
    "\\0"
END

3 TEXTINCLUDE DISCARDABLE
BEGIN
    "1 TYPELIB ""$(class.name).tlb""\\r\\n"
    "\\0"
END

#endif    // APSTUDIO_INVOKED


#ifndef _MAC
/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "Comments", "\\0"
            VALUE "CompanyName", "iMatix Corporation\\0"
            VALUE "FileDescription", "$(class.name) Module\\0"
            VALUE "FileVersion", "1, 0, 0, 1\\0"
            VALUE "InternalName", "$(class.name)\\0"
            VALUE "LegalCopyright", "Copyright 2000\\0"
            VALUE "LegalTrademarks", "\\0"
            VALUE "OLESelfRegister", "\\0"
            VALUE "OriginalFilename", "$(class.name).dll\\0"
            VALUE "PrivateBuild", "\\0"
            VALUE "ProductName", "$(class.name) Module\\0"
            VALUE "ProductVersion", "1, 0, 0, 1\\0"
            VALUE "SpecialBuild", "\\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // !_MAC


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE DISCARDABLE
BEGIN
    IDS_PROJNAME            "$(class.name)"
END

#endif    // French (France) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// French (Belgium) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_FRB)
#ifdef _WIN32
LANGUAGE LANG_FRENCH, SUBLANG_FRENCH_BELGIAN
#pragma code_page(1252)
#endif //_WIN32

/////////////////////////////////////////////////////////////////////////////
//
// REGISTRY
//
IDR_$(OBJECT_NAME)             REGISTRY DISCARDABLE    "$(object_name).rgs"
#endif    // French (Belgium) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
1 TYPELIB "$(class.name).tlb"

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

.  close
.  for object
.      echo ("Generating $(class.object_name)/$(class.object_name).rgs...")
.      output ("$(class.object_name)/$(class.object_name).rgs")
HKCR
{
  amq.$(class.object_name).1 = s '$(class.object_name) Class'
	{
		CLSID = s '{$(class_uuid:)}'
	}
  amq.$(class.object_name) = s '$(class.object_name) Class'
	{
		CLSID = s '{$(class_uuid:)}'
    CurVer = s 'amq.$(class.object_name).1'
	}
	NoRemove CLSID
	{
    ForceRemove {$(class_uuid:)} = s '$(class.object_name) Class'
		{
      ProgID = s 'amq.$(class.object_name).1'
      VersionIndependentProgID = s 'amq.$(class.object_name)'
			ForceRemove 'Programmable'
			InprocServer32 = s '%MODULE%'
			{
				val ThreadingModel = s 'Both'
			}
			'TypeLib' = s '{$(class.uuid:)}'
		}
	}
}
.      close
.      endfor
.endmacro


.-----------------------------------------------------------------------
.macro generate_stdafx
.------------------------------------------------------------------------
.output "$(class.object_name)/stdafx.h"
.echo "Create file $(class.object_name)/stdafx.h"
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H_$(CLASS.OBJECT_NAME)_INCLUDED_)
#define AFX_STDAFX_H_$(CLASS.OBJECT_NAME)_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H_$(CLASS.OBJECT_NAME)_INCLUDED_)
.output "$(class.object_name)/stdafx.cpp"
.echo "Create file $(class.object_name)/stdafx.cpp"
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
.endmacro



.-----------------------------------------------------------------------
.macro generate_dlldatax
.-----------------------------------------------------------------------
.output "$(class.object_name)/dlldatax.h"
.echo "Create file $(class.object_name)/dlldatax.h"
#if !defined(AFX_DLLDATAX_H_$(CLASS.OBJECT_NAME)_INCLUDED_)
#define AFX_DLLDATAX_H_$(CLASS.OBJECT_NAME)_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C"
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason,
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H_$(CLASS.OBJECT_NAME)_INCLUDED_)
.output "$(class.object_name)/dlldatax.c"
.echo "Create file $(class.object_name)/dlldatax.c"
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "$(class.name)_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
.endmacro



.macro generate_def
.-----------------------------------------------------------------------
.output "$(class.object_name)/$(class.name).def"
.echo "Create file $(class.object_name)/$(class.name).def"
; $(class.name).def : Declares the module parameters.

LIBRARY      "$(class.name).DLL"

EXPORTS
    DllCanUnloadNow         @1 PRIVATE
    DllGetClassObject       @2 PRIVATE
    DllRegisterServer       @3 PRIVATE
    DllUnregisterServer     @4 PRIVATE
.output "$(class.object_name)/$(class.name)ps.def"
.echo "Create file $(class.object_name)/$(class.name)ps.def"

LIBRARY      "$(class.name)PS"

DESCRIPTION  'Proxy/Stub DLL'

EXPORTS
    DllGetClassObject       @1  PRIVATE
    DllCanUnloadNow         @2  PRIVATE
    GetProxyDllInfo         @3  PRIVATE
    DllRegisterServer       @4  PRIVATE
    DllUnregisterServer     @5  PRIVATE
.endmacro

.-----------------------------------------------------------------------
.macro generate_ax_dsp
.-----------------------------------------------------------------------
.   echo "Create Microsoft Developer Studio Project file for Active X component $(class.name)"
.   echo ("Generating $(class.object_name)/$(class.name).dsp...")
.   output "$(class.object_name)/$(class.name).dsp"
.
. root.additional_libraries = "..\\libamq.lib "
. for used_library
.   root.additional_libraries += '$\(LIBDIR)\\$(name).lib '
. endfor
# Microsoft Developer Studio Project File - Name="$(class.name)" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102

CFG=$(class.name) - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE
!MESSAGE NMAKE /f "$(class.name).mak".
!MESSAGE
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE
!MESSAGE NMAKE /f "$(class.name).mak" CFG="$(class.name) - Win32 Debug"
!MESSAGE
!MESSAGE Possible choices for configuration are:
!MESSAGE
!MESSAGE "$(class.name) - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE "$(class.name) - Win32 Release MinSize" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE "$(class.name) - Win32 Release MinDependency" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
MTL=midl.exe
RSC=rc.exe

!IF  "\$(CFG)" == "$(class.name) - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "$(class.name)\\Debug"
# PROP BASE Intermediate_Dir "$(class.name)\\Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "$(class.name)\\Debug"
# PROP Intermediate_Dir "$(class.name)\\Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /I $\(INCDIR) /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /FD /GZ /c
# SUBTRACT CPP /YX /Yc /Yu
# ADD BASE RSC /l 0x409 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib mtx.lib mtxguid.lib delayimp.lib winmm.lib $(root.additional_libraries:)/nologo /subsystem:windows /dll /debug /machine:I386 /out:"../$(class.name).dll" /pdbtype:sept /delayload:mtxex.dll
# Begin Custom Build - Performing registration
OutDir=.\\$(class.name)\\Debug
TargetPath=..\\$(class.name).dll
InputPath=..\\$(class.name).dll
SOURCE="\$(InputPath)"

"\$(OutDir)\\regsvr32.trg" : \$(SOURCE) "\$(INTDIR)" "\$(OUTDIR)"
    regsvr32 /s /c "\$(TargetPath)"
    echo regsvr32 exec. time > "\$(OutDir)\\regsvr32.trg"

# End Custom Build
# Begin Special Build Tool
SOURCE="\$(InputPath)"
.-PreLink_Cmds=net STOP "World Wide Web Publishing Service"
.-PostBuild_Cmds=net START "World Wide Web Publishing Service"
# End Special Build Tool

!ELSEIF  "\$(CFG)" == "$(class.name) - Win32 Release MinSize"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "$(class.name)\\ReleaseMinSize"
# PROP BASE Intermediate_Dir "$(class.name)\\ReleaseMinSize"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "$(class.name)\\ReleaseMinSize"
# PROP Intermediate_Dir "$(class.name)\\ReleaseMinSize"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MD /W3 /O1 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "_ATL_DLL" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /MD /W3 /O1 /I $\(INCDIR) /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "_ATL_DLL" /FD /c
# SUBTRACT CPP /YX /Yc /Yu
# ADD BASE RSC /l 0x409 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib mtx.lib mtxguid.lib delayimp.lib winmm.lib $(root.additional_libraries)/nologo /subsystem:windows /dll /machine:I386 /out:"../$(class.name).dll" /delayload:mtxex.dll
# Begin Custom Build - Performing registration
OutDir=.\\$(class.name)\\ReleaseMinSize
TargetPath=..\\$(class.name).dll
InputPath=..\\$(class.name).dll
SOURCE="\$(InputPath)"

# End Custom Build
# Begin Special Build Tool
SOURCE="\$(InputPath)"
.-PreLink_Cmds=net STOP "World Wide Web Publishing Service"
.-PostBuild_Cmds=net START "World Wide Web Publishing Service"
# End Special Build Tool

!ELSEIF  "\$(CFG)" == "$(class.name) - Win32 Release MinDependency"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "$(class.name)\\ReleaseMinDependency"
# PROP BASE Intermediate_Dir "$(class.name)\\ReleaseMinDependency"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "$(class.name)\\ReleaseMinDependency"
# PROP Intermediate_Dir "$(class.name)\\ReleaseMinDependency"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MD /W3 /O1 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "_ATL_STATIC_REGISTRY" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /MD /W3 /GX /O2 /I $\(INCDIR) /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "_ATL_STATIC_REGISTRY" /FD /c
# SUBTRACT CPP /Fr /YX /Yc /Yu
# ADD BASE RSC /l 0x409 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib mtx.lib mtxguid.lib delayimp.lib winmm.lib $(root.additional_libraries)/nologo /subsystem:windows /dll /machine:I386 /out:"../$(class.name).dll" /delayload:mtxex.dll
# Begin Custom Build - Performing registration
OutDir=.\\$(class.name)\\ReleaseMinDependency
TargetPath=..\\$(class.name).dll
InputPath=..\\$(class.name).dll
SOURCE="\$(InputPath)"

# End Custom Build
# Begin Special Build Tool
SOURCE="\$(InputPath)"
.-PreLink_Cmds=net STOP "World Wide Web Publishing Service"
.-PostBuild_Cmds=net START "World Wide Web Publishing Service"
# End Special Build Tool

!ENDIF

# Begin Target

# Name "$(class.name) - Win32 Debug"
# Name "$(class.name) - Win32 Release MinSize"
# Name "$(class.name) - Win32 Release MinDependency"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"

# Begin Source File
SOURCE=.\\dlldatax.c
# PROP Exclude_From_Scan -1
# PROP BASE Exclude_From_Build 1
# PROP Exclude_From_Build 1
# End Source File

# Begin Source File
SOURCE=.\\$(class.name).cpp
# End Source File

# Begin Source File
SOURCE=.\\$(class.name).def
# End Source File

# Begin Source File
SOURCE=.\\$(class.name).idl
# ADD MTL /tlb ".\\$(class.name).tlb" /h "$(class.name).h" /iid "$(class.name)_i.c" /Oicf
# End Source File

# Begin Source File
SOURCE=.\\$(class.name).rc
# End Source File

# Begin Source File
SOURCE=.\\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File

# Begin Source File
SOURCE=.\\$(class.object_name).cpp
# End Source File
.for additional_source

# Begin Source File
SOURCE=..\\sources\\$(file)
# End Source File
.endfor

# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\\dlldatax.h
# PROP Exclude_From_Scan -1
# PROP BASE Exclude_From_Build 1
# PROP Exclude_From_Build 1
# End Source File
# Begin Source File

SOURCE=.\\Resource.h
# End Source File
# Begin Source File

SOURCE=.\\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project
.endmacro

