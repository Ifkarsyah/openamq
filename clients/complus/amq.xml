<class
    name = "AMQ"
    libid = "B9EDF8A0-CAAF-11D3-B3AF-00EFA87EF001"
    version_major = "1"
    version_minor = "0"
    description = "OpenAMQ Client Components">

    <include name = "amq_bucket.h" local = "yes"/>
    <include name = "amq_message.h" local = "yes"/>
    <include name = "amq_sclient.h" local = "yes"/>
  
    <interface
        name = "IAMQConnection"
        source = "no"
        iid = "876FAFB0-AEF8-F2DF-AFBA-49AC41AEF001">
    
        <method name="Connect">
            <argument type = "BSTR" name = "server" />
            <argument type = "BSTR" name = "path" />
            <argument type = "BSTR" name = "login" />
            <argument type = "BSTR" name = "password" />
            <argument type = "BSTR" name = "identifier" />
            <doc>
        Open a connection to a local or remote AMQP server. Optionally
        specify a server name, plus an optional virtual path. You can
        specify a non-standard AMQP port by adding ':'
        and the port number to the server name.
            </doc>
        </method>

        <method name = "CreateProducer" type = "IDispatch*">
            <argument type = "BSTR" name = "destination" />
        </method>

        <method name = "CreateConsumer" type = "IDispatch*">
            <argument type = "BSTR" name = "destination" />
            <argument type = "long" name = "prefetch" />
            <argument type = "long" name = "noack" />
        </method>

        <method name = "CreateTemporaryQueue" type = "long">
            <argument type = "BSTR" name = "destination" />
            <argument type = "long" name = "prefetch" />
            <argument type = "long" name = "noack" />
        </method>

        <method name = "MessageAcknowledge">
        </method>

<!--
        <property name = "ReplyCode" type = "long" get="yes" put="no" />
        <property name = "ReplyText" type = "BSTR" get="yes" put="no" />
-->

    </interface>

    <interface
        name = "IAMQDestination"
        source = "no"
        iid = "10EB17E0-165E-4770-983B-32455B0C3D52">

        <method name = "MsgSend">
            <argument type = "BSTR" name = "content" />
            <argument type = "long" name = "persistent" />
            <argument type = "long" name = "priority" />
            <argument type = "long" name = "expiration" />
            <argument type = "BSTR" name = "mime_type" />
            <argument type = "BSTR" name = "encoding" />
            <argument type = "BSTR" name = "identifier" />
        </method>

        <method name = "MsgRead">
            <argument type = "long" name = "timeout" />
        </method>

        </interface>

        <interface
            name = "_IAMQDestinationEvents"
            source = "yes"
            iid = "4C8A1B9F-43C6-4bfb-8327-14C57DDAB22A">

            <method name = "MessageArrived">
                <argument type = "long" name = "msgnum" />
                <argument type = "BSTR" name = "sender" />
                <argument type = "BSTR" name = "content" />
                <argument type = "long" name = "persistent" />
                <argument type = "long" name = "priority" />
                <argument type = "long" name = "expiration" />
                <argument type = "BSTR" name = "mime_type" />
                <argument type = "BSTR" name = "encoding" />
                <argument type = "BSTR" name = "identifier" />
                <argument type = "long" name = "delivered" />
                <argument type = "long" name = "redelivered" />
            </method>

        </interface>

        <interface
            name = "IAMQControl"
            source = "no"
            iid = "FBF315E4-DE69-4569-8F69-7DCB291BE20E">

            <property name = "Period" type = "long" get = "yes" put = "yes" />
            <property name = "Source" type = "IDispatch*" get = "yes" put = "yes" />

        </interface>

        <object
            name = "AMQConnection"
            clsid = "876FAFB1-AEF8-F2DF-AFBA-49AC41AEF001"
            control = "no"
            creatable = "yes"
            threading_model = "Apartment"
            version = "1">

            <include name = "AMQDestination.h" local = "yes" location = "cpp" />

            <context>
                <field name = "amq_client"  type = "amq_sclient_t"  reference = "yes" />
            </context>
    
            <destructor>
    amq_sclient_destroy (&m_amq_client);
            </destructor>
    
            <implements interface = "IAMQConnection">
                <method name = "Connect">
    char *my_server;
    char *my_path;
    char *my_login;
    char *my_password;
    char *my_identifier;
    USES_CONVERSION;
        
    my_server = OLE2A(server);
    my_path = OLE2A (path);
    my_login = OLE2A (login);
    my_password = OLE2A (password);
    my_identifier = OLE2A (identifier);

    coprintf ("Connecting to %s using identity '%s'...", my_server, my_identifier);
    amq_sclient_destroy (&m_amq_client);
    m_amq_client = amq_sclient_new (my_identifier, my_login, my_password);
    long result = amq_sclient_connect (m_amq_client, my_server, my_path);
    if (result == 0) return E_FAIL;
    return S_OK;
                </method>

                <method name = "CreateProducer">
    USES_CONVERSION;
    char *my_destination;
    unsigned short handle;
    HRESULT hr;

    my_destination = OLE2A (destination);
    handle = amq_sclient_producer (m_amq_client, my_destination);
        
    CComObject &lt;CAMQDestination> *p;
    hr = CComObject &lt;CAMQDestination>::CreateInstance (&p);
    if (!SUCCEEDED(hr)) return hr;
    p->AddRef();

    p->m_connection = this;
    AddRef();
    p->m_handle = handle;

    if(pVal) *pVal = p;
    else p->Release();
        
    return S_OK;
                </method>

                <method name = "CreateConsumer">
    USES_CONVERSION;
    char *my_destination;
    unsigned short handle;
    HRESULT hr;

    my_destination = OLE2A (destination);
    handle = amq_sclient_consumer (m_amq_client, my_destination, prefetch, (Bool) noack);
        
    CComObject &lt;CAMQDestination> *p;
    hr = CComObject &lt;CAMQDestination>::CreateInstance (&p);
    if (!SUCCEEDED(hr)) return hr;
    p->AddRef();

    p->m_connection = this;
    AddRef();
    p->m_handle = handle;

    if(pVal) *pVal = p;
    else p->Release();
        
    return S_OK;
                </method>

                <method name = "CreateTemporaryQueue">
    USES_CONVERSION;
    char *my_destination;

    my_destination = OLE2A (destination);
    *pVal = amq_sclient_temporary (m_amq_client, my_destination, prefetch, (Bool) noack);
    return S_OK;
                </method>

                <method name = "MessageAcknowledge">
    long result = amq_sclient_msg_ack (m_amq_client);
    if (result == 0) return E_FAIL;
    return S_OK;
                </method>

<!--
                <property name = "ReplyCode">
                    <get>
    if(pVal) *pVal = m_amq_client? m_amq_client->reply_code: 0;
    return S_OK;
                    </get>
                </property>

                <property name = "ReplyText">
                    <get>
    USES_CONVERSION;
       
    if (pVal) *pVal = SysAllocString (T2OLE (m_amq_client? m_amq_client->reply_text: ""));
    return S_OK;
                    </get>
                </property>
-->

            </implements>

        </object>

    <object
        name = "AMQDestination"
        clsid = "E511636A-9B33-4ce7-8548-40F656452C13"
        control = "no"
        creatable = "no"
        threading_model = "Apartment"
        version = "1">

        <fires interface = "_IAMQDestinationEvents" />

        <include name = "AMQConnection.h" local = "yes" location ="h" />

        <destructor>
    amq_sclient_close (m_connection->m_amq_client, m_handle);
    if (m_connection) m_connection->Release();
        </destructor>

        <context>
            <field name = "connection"  type = "CAMQConnection"  reference = "yes" />
            <field name = "handle" type = "unsigned short" reference = "no" />
        </context>

        <implements interface = "IAMQDestination">

            <method name = "MsgSend">
    USES_CONVERSION;

    amq_message_t *msg = amq_message_new ();

    amq_message_set_persistent (msg, (Bool) persistent);
    amq_message_set_priority (msg, (byte) priority);
    amq_message_set_expiration (msg, (time_t) expiration);
    amq_message_set_mime_type (msg, OLE2A (mime_type) );
    amq_message_set_encoding (msg, OLE2A (encoding) );
    amq_message_set_identifier (msg, OLE2A (identifier) );

    int my_size = SysStringByteLen (content);
    byte *my_content = (byte *) icl_mem_alloc (my_size);        
    memcpy (my_content, content, my_size);
    amq_message_set_content (msg, my_content, my_size, icl_mem_free);
        
    amq_sclient_msg_send (m_connection->m_amq_client, m_handle, msg);
    return S_OK;
            </method>

            <method name = "MsgRead">
    while(true) {
        amq_message_t *msg;
        msg = amq_sclient_msg_read (m_connection->m_amq_client, timeout);
        if (!msg) break;
        Fire_MessageArrived(
            m_connection->m_amq_client->msg_number,
            CComBSTR (m_connection->m_amq_client->msg_sender),
            msg->content ? CComBSTR (msg->content->size, (char*) msg->content->data) : CComBSTR(L""),
            msg->persistent,
            msg->priority,
            msg->expiration,
            CComBSTR(msg->mime_type),
            CComBSTR(msg->encoding),
            CComBSTR(msg->identifier),
            m_connection->m_amq_client->msg_delivered,
            m_connection->m_amq_client->msg_redelivered);
        amq_message_destroy (&msg);
    }
    return S_OK;
            </method>

        </implements>

    </object>

    <object
        name = "AMQControl"
        clsid = "10BB5D68-4877-41cc-BC7B-289788AB4228"
        control = "yes"
        creatable = "yes"
        threading_model = "Apartment"
        version = "1">

        <fires interface = "_IAMQDestinationEvents" />

        <context>
            <field name = "period" type = "long" />
            <field name = "source" type = "CComPtr<IAMQDestination>" noinit = "" />
            <field name = "cookie" type = "DWORD" />
        </context>

        <constructor>
    m_bWindowOnly = TRUE;
        </constructor>

        <implements interface = "IAMQControl">

            <property name = "Period">
                <get>
    *pVal = m_period;
    return S_OK;
                </get>
                <put>
    m_period = newVal;
    SetTimer (1, m_period);
    return S_OK;
                </put>
            </property>

            <property name = "Source">
                <get>
    *pVal = m_source;
    m_source.p->AddRef();
    return S_OK;
                </get>
                <put>
    HRESULT hr;
    if (m_source) {
        hr = DispEventUnadvise (m_source);
        if (!SUCCEEDED (hr) ) return hr;
    }
    m_source.Release();
    hr = newVal->QueryInterface(__uuidof(IAMQDestination), (void**)&m_source);
    if (!SUCCEEDED (hr) ) return hr;
    return CAMQControlSink1::DispEventAdvise(m_source);
                </put>
            </property>
    
        </implements>

        <handler message = "WM_TIMER">
    if(m_source) m_source->MsgRead(100);        
    return 0;
        </handler>  

        <sink id = "1" interface = "_IAMQDestinationEvents">
            <event name="MessageArrived">
    Fire_MessageArrived (msgnum, sender, content, persistent, priority, expiration, mime_type, encoding, identifier, delivered, redelivered);
    return S_OK;
            </event>
        </sink>  

        <function name = "OnDraw" type = "HRESULT">
            <argument type = "ATL_DRAWINFO&" name = "di" />
    RECT& rc = *(RECT*)di.prcBounds;
    Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
    SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
    LPCTSTR pszText = _T("AMQ Control");
    TextOut(
        di.hdcDraw, 
        (rc.left + rc.right) / 2, 
        (rc.top + rc.bottom) / 2, 
        pszText, 
        lstrlen(pszText));
    return S_OK;
        </function>

    </object>
    
</class>

<library name = "libamq" target = "..\libamq.lib" debugtarget = "..\libamqd.lib" />

