<class
    name = "AMQ"
    libid = "B9EDF8A0-CAAF-11D3-B3AF-00EFA87EF001"
    version_major = "1"
    version_minor = "0"
    description = "OpenAMQ Client Components">

    <include name = "sfl.h" local = "yes" location = "cpp"/>
    <include name = "amq_bucket.h" local = "yes" location = "cpp"/>
    <include name = "amq_message.h" local = "yes" location = "cpp"/>
    <include name = "amq_sclient.h" local = "yes" location = "cpp"/>
  
    <interface
        name = "IAMQConnection"
        dual = "yes"
        source = "no"
        iid = "876FAFB0-AEF8-F2DF-AFBA-49AC41AEF001">
    
        <method name="Connect">
            <argument type = "BSTR" name = "server"/>
            <argument type = "BSTR" name = "path"/>
            <argument type = "BSTR" name = "login"/>
            <argument type = "BSTR" name = "password"/>
            <argument type = "BSTR" name = "identifier"/>
        </method>

        <method name = "CreateProducer" type = "IDispatch*">
            <argument type = "BSTR" name = "destination"/>
        </method>

        <method name = "CreateConsumer" type = "IDispatch*">
            <argument type = "BSTR" name = "destination"/>
            <argument type = "long" name = "prefetch"/>
            <argument type = "long" name = "noack"/>
        </method>

        <method name = "CreateTemporaryQueue" type = "IDispatch*">
            <argument type = "BSTR" name = "destination"/>
            <argument type = "long" name = "prefetch"/>
            <argument type = "long" name = "noack"/>
        </method>

        <method name = "MsgAcknowledge">
        </method>

    </interface>

    <interface
        name = "IAMQDestination"
        dual = "yes"
        source = "no"
        iid = "10EB17E0-165E-4770-983B-32455B0C3D52">

        <method name = "MsgSend">
            <argument type = "BSTR" name = "content"/>
            <argument type = "long" name = "persistent"/>
            <argument type = "long" name = "priority"/>
            <argument type = "long" name = "expiration"/>
            <argument type = "BSTR" name = "mime_type"/>
            <argument type = "BSTR" name = "encoding"/>
            <argument type = "BSTR" name = "identifier"/>
        </method>

        <method name = "MsgRead">
            <argument type = "long" name = "timeout"/>
        </method>

        </interface>

        <interface
            name = "_IAMQDestinationEvents"
            source = "yes"
            iid = "4C8A1B9F-43C6-4bfb-8327-14C57DDAB22A">

            <method name = "MessageArrived">
                <argument type = "long" name = "msgnum" />
                <argument type = "BSTR" name = "sender" />
                <argument type = "BSTR" name = "content" />
                <argument type = "long" name = "persistent" />
                <argument type = "long" name = "priority" />
                <argument type = "long" name = "expiration" />
                <argument type = "BSTR" name = "mime_type" />
                <argument type = "BSTR" name = "encoding" />
                <argument type = "BSTR" name = "identifier" />
                <argument type = "long" name = "delivered" />
                <argument type = "long" name = "redelivered" />
            </method>

        </interface>

        <interface
            name = "IAMQControl"
            dual = "yes"
            source = "no"
            iid = "FBF315E4-DE69-4569-8F69-7DCB291BE20E">

            <property name = "Period" type = "long" get = "yes" put = "yes" />
            <property name = "Source" type = "IDispatch*" get = "yes" put = "yes" />

        </interface>

        <custom location = "h">
#define REPORT_AMQ_ERROR(client, class_name, interface_name)\
    {\
        USES_CONVERSION;\
        wchar_t buffer[32];\
        CComBSTR errmsg (_itow (client->reply_code, buffer, 10) );\
        errmsg += L" : ";\
        errmsg += A2OLE (client->reply_text);\
        return AtlReportError (__uuidof (class_name), errmsg, __uuidof (interface_name), E_FAIL);\
    }
        </custom>

        <object
            name = "AMQConnection"
            clsid = "876FAFB1-AEF8-F2DF-AFBA-49AC41AEF001"
            control = "no"
            creatable = "yes"
            threading_model = "Apartment"
            version = "1">

            <include name = "AMQDestination.h" local = "yes" location = "cpp" />

            <context>
                <field name = "amq_client"  type = "amq_sclient_t*" />
                <field name = "log_file_name" type = "char*" />
            </context>
    
            <constructor>
    m_amq_client = NULL;
    m_log_file_name = NULL;
            </constructor>

            <destructor>
    if (m_amq_client) amq_sclient_destroy (&m_amq_client);
    if (m_log_file_name) free (m_log_file_name);
            </destructor>
    
            <implements interface = "IAMQConnection" errorinfo = "yes">

                <method name = "Connect">
    char *my_server;
    char *my_path;
    char *my_login;
    char *my_password;
    char *my_identifier;
    USES_CONVERSION;
        
    my_server = OLE2A(server);
    my_path = OLE2A (path);
    my_login = OLE2A (login);
    my_password = OLE2A (password);
    my_identifier = OLE2A (identifier);

    m_log_file_name = strdupl (file_where ('s', "TEMP", "amq_complus_client", "log"));
    console_capture (m_log_file_name, 'a');
    coprintf ("Connecting to %s using identity '%s'...", my_server, my_identifier);
    if (m_amq_client) amq_sclient_destroy (&m_amq_client);
    amq_sclient_trace (3);
    m_amq_client = amq_sclient_new (my_identifier, my_login, my_password);
    long result = amq_sclient_connect (m_amq_client, my_server, my_path);
    if (result == 0) REPORT_AMQ_ERROR (m_amq_client, AMQConnection, IAMQConnection);
    return S_OK;
                </method>

                <method name = "CreateProducer">
    USES_CONVERSION;
    char *my_destination;
    unsigned short handle;
    HRESULT hr;

    my_destination = OLE2A (destination);
    handle = amq_sclient_producer (m_amq_client, my_destination);
    if (handle == 0) REPORT_AMQ_ERROR (m_amq_client, AMQConnection, IAMQConnection);
        
    CComObject &lt;CAMQDestination> *p;
    hr = CComObject &lt;CAMQDestination>::CreateInstance (&p);
    if (!SUCCEEDED(hr) ) return AtlReportError (
        __uuidof(AMQConnection),
        L"Cannot open AMQDestination object",
        __uuidof(IAMQConnection),
        E_FAIL);
    p->AddRef();

    p->m_connection = this;
    AddRef();
    p->m_handle = handle;

    if(pVal) *pVal = p;
    else p->Release();
        
    return S_OK;
                </method>

                <method name = "CreateConsumer">
    USES_CONVERSION;
    char *my_destination;
    unsigned short handle;
    HRESULT hr;

    my_destination = OLE2A (destination);
    handle = amq_sclient_consumer (m_amq_client, my_destination, prefetch, (Bool) noack);
    if (handle == 0) REPORT_AMQ_ERROR (m_amq_client, AMQConnection, IAMQConnection);
        
    CComObject &lt;CAMQDestination> *p;
    hr = CComObject &lt;CAMQDestination>::CreateInstance (&p);
        if (!SUCCEEDED(hr) ) return AtlReportError (
        __uuidof(AMQConnection),
        L"Cannot open AMQDestination object",
        __uuidof(IAMQConnection),
        E_FAIL);
    p->AddRef();

    p->m_connection = this;
    AddRef();
    p->m_handle = handle;

    if(pVal) *pVal = p;
    else p->Release();
        
    return S_OK;
                </method>

                <method name = "CreateTemporaryQueue">
    USES_CONVERSION;
    char *my_destination;
    unsigned short handle;
    HRESULT hr;

    my_destination = OLE2A (destination);
    handle = amq_sclient_temporary (m_amq_client, my_destination, prefetch, (Bool) noack);
    if (handle == 0) REPORT_AMQ_ERROR (m_amq_client, AMQConnection, IAMQConnection);
        
    CComObject &lt;CAMQDestination> *p;
    hr = CComObject &lt;CAMQDestination>::CreateInstance (&p);
        if (!SUCCEEDED(hr) ) return AtlReportError (
        __uuidof(AMQConnection),
        L"Cannot open AMQDestination object",
        __uuidof(IAMQConnection),
        E_FAIL);
    p->AddRef();

    p->m_connection = this;
    AddRef();
    p->m_handle = handle;

    if(pVal) *pVal = p;
    else p->Release();
        
    return S_OK;
                </method>

                <method name = "MsgAcknowledge">
    long result = amq_sclient_msg_ack (m_amq_client);
    if (result == 0) REPORT_AMQ_ERROR (m_amq_client, AMQConnection, IAMQConnection);
    return S_OK;
                </method>

            </implements>

        </object>

    <object
        name = "AMQDestination"
        clsid = "E511636A-9B33-4ce7-8548-40F656452C13"
        control = "no"
        creatable = "no"
        threading_model = "Apartment"
        version = "1">

        <include name = "AMQConnection.h" local = "yes" location ="h" />

            <custom location = "cpp">
static void s_mem_free (void *p)
{
    icl_mem_free (p);
}
            </custom>

        <destructor>
    amq_sclient_close (m_connection->m_amq_client, m_handle);
    if (m_connection) m_connection->Release();
        </destructor>

        <context>
            <field name = "connection"  type = "CAMQConnection"  reference = "yes" />
            <field name = "handle" type = "unsigned short" reference = "no" />
        </context>

        <fires interface = "_IAMQDestinationEvents" />

        <implements interface = "IAMQDestination" errorinfo = "yes">

            <method name = "MsgSend">
    USES_CONVERSION;

    amq_message_t *msg = amq_message_new ();

    amq_message_set_persistent (msg, (Bool) persistent);
    amq_message_set_priority (msg, (byte) priority);
    amq_message_set_expiration (msg, (time_t) expiration);
    amq_message_set_mime_type (msg, OLE2A (mime_type) );
    amq_message_set_encoding (msg, OLE2A (encoding) );
    amq_message_set_identifier (msg, OLE2A (identifier) );

    int my_size = SysStringByteLen (content);
    byte *my_content = (byte *) icl_mem_alloc (my_size);        
    memcpy (my_content, content, my_size);
    amq_message_set_content (msg, my_content, my_size, s_mem_free);
        
    if (amq_sclient_msg_send (m_connection->m_amq_client, m_handle, msg) != 0)
        REPORT_AMQ_ERROR(m_connection->m_amq_client, AMQDestination, IAMQDestination);

    return S_OK;
            </method>

            <method name = "MsgRead">
    while(true) {
        amq_message_t *msg;
        msg = amq_sclient_msg_read (m_connection->m_amq_client, timeout);
        if (!msg) break;
        Fire_MessageArrived(
            m_connection->m_amq_client->msg_number,
            CComBSTR (m_connection->m_amq_client->msg_sender),
            msg->content ? CComBSTR (msg->content->size, (char*) msg->content->data) : CComBSTR(L""),
            msg->persistent,
            msg->priority,
            msg->expiration,
            CComBSTR(msg->mime_type),
            CComBSTR(msg->encoding),
            CComBSTR(msg->identifier),
            m_connection->m_amq_client->msg_delivered,
            m_connection->m_amq_client->msg_redelivered);
        amq_message_destroy (&msg);
    }
    return S_OK;
            </method>

        </implements>

    </object>

    <object
        name = "AMQControl"
        clsid = "10BB5D68-4877-41cc-BC7B-289788AB4228"
        control = "yes"
        creatable = "yes"
        threading_model = "Apartment"
        version = "1">

        <fires interface = "_IAMQDestinationEvents" />

        <context>
            <field name = "period" type = "long" />
            <field name = "source" type = "CComPtr<IAMQDestination>" noinit = "" />
            <field name = "cookie" type = "DWORD" />
        </context>

        <constructor>
    m_bWindowOnly = TRUE;
        </constructor>

        <implements interface = "IAMQControl" errorinfo = "yes">

            <property name = "Period">
                <get>
    *pVal = m_period;
    return S_OK;
                </get>
                <put>
    m_period = newVal;
    SetTimer (1, m_period);
    return S_OK;
                </put>
            </property>

            <property name = "Source">
                <get>
    *pVal = m_source;
    if (m_source) m_source.p->AddRef();
    return S_OK;
                </get>
                <put>
    HRESULT hr;
    if (m_source) {
        hr = DispEventUnadvise (m_source);
        if (!SUCCEEDED (hr) ) return hr;
        m_source.Release();
    }
    if (newVal) {
        hr = newVal->QueryInterface(__uuidof(IAMQDestination), (void**)&m_source);
        if (!SUCCEEDED (hr) ) return hr;
        return CAMQControlSink1::DispEventAdvise(m_source);
    }
    else {
        m_source = NULL;
        return S_OK;
    }
                </put>
            </property>
    
        </implements>

        <handler message = "WM_TIMER">
    if(m_source) m_source->MsgRead(100);        
    return 0;
        </handler>  

        <sink id = "1" interface = "_IAMQDestinationEvents">
            <event name="MessageArrived">
    Fire_MessageArrived (msgnum, sender, content, persistent, priority, expiration, mime_type, encoding, identifier, delivered, redelivered);
    return S_OK;
            </event>
        </sink>  

        <function name = "OnDraw" type = "HRESULT">
            <argument type = "ATL_DRAWINFO&" name = "di" />
    RECT& rc = *(RECT*)di.prcBounds;
    Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
    SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
    LPCTSTR pszText = _T("AMQ Control");
    TextOut(
        di.hdcDraw, 
        (rc.left + rc.right) / 2, 
        (rc.top + rc.bottom) / 2, 
        pszText, 
        lstrlen(pszText));
    return S_OK;
        </function>

    </object>
    
</class>

<library target = "libamq.lib" debugtarget = "libamq.lib" />
<library target = "libsmt.lib" debugtarget = "libsmt.lib" />
<library target = "libipr.lib" debugtarget = "libipr.lib" />
<library target = "libicl.lib" debugtarget = "libicl.lib" />
<library target = "libsfl.lib" debugtarget = "libsfl.lib" />
<library target = "libapr.lib" debugtarget = "libapr.lib" />
<library target = "ws2_32.lib" debugtarget = "ws2_32.lib" />
