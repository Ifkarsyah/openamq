.template 0
#! /usr/local/bin/gsl -a
#  ----------------------------------------------------------------------------
#   AMQ Frame Generator for Java
#
#   Frames are structures designed to be easily serialized for writing
#   to a socket or file.  Frames are described using an XML language.
#
#   This script generates frame structures and serialization code.
#
#   Copyright (c) 2005 JPMorgan
#   Copyright (c) 1991-2004 iMatix Corporation
#  ----------------------------------------------------------------------------

#  ------------------------------   Globals    --------------------------------

class_prefix = "AMQ"
AMQPFrameIOException = "$(class_prefix:)FramingIOException"
AMQPFrameException = "$(class_prefix:)FramingException"
AMQPFrameError = "$(class_prefix:)FramingError"
AMQPFramingFactory = "$(class_prefix:)FramingFactory"
AMQPFieldTable = "$(class_prefix:)FieldTable"
AMQPFramable = "$(class_prefix:)Framable"
AMQPFrame = "$(class_prefix:)Frame"
utilities = "
    // Utility functions from $(AMQPFramingFactory:)
    static String hexDump(byte[] bytes) {
        return $(AMQPFramingFactory:).hexDump(bytes);
    }
    
    static String bytes2String(byte[] bytes) {
        return $(AMQPFramingFactory:).bytes2String(bytes);
    }
     
    static byte[] string2Bytes(String string) {
        return $(AMQPFramingFactory:).string2Bytes(string);
    } 
    
    static void readBytes(InputStream dis, byte[] b, int off, int len) throws IOException {
        $(AMQPFramingFactory:).readBytes(dis, b, off, len);
    } 
    
    static void writeBytes(OutputStream dos, byte[] b, int off, int len) throws IOException {
        $(AMQPFramingFactory:).writeBytes(dos, b, off, len);
    } 
    
    static long u(int value) {
        return $(AMQPFramingFactory:).u(value);
    }
    
    static int s(long value) {
        return $(AMQPFramingFactory:).s(value);
    }
    
    static int u(short value) {
        return $(AMQPFramingFactory:).u(value);
    }
    
    static short s(int value) {
        return $(AMQPFramingFactory:).s(value);
    }
    
    static short u(byte value) {
        return $(AMQPFramingFactory:).u(value);
    }
    
    static byte s(short value) {
        return $(AMQPFramingFactory:).s(value);
    }"
error_handling ="
    // Error facilities from $(AMQPFramingFactory)
    static void warning(String _class, String method, String message) {
        $(AMQPFramingFactory:).warning(_class, method, message); 
    }
    
    static void exception(Exception e, String _class, String method, String message) throws $(AMQPFrameException:) {
        $(AMQPFramingFactory:).exception(e, _class, method, message); 
    }
    
    static void runtimeException(Exception e, String _class, String method, String message) throws RuntimeException {
        $(AMQPFramingFactory:).runtimeException(e, _class, method, message); 
    }"
imatix_openamq_dir = "com/imatix/openamq"
imatix_openamq_frames_dir = imatix_openamq_dir + "/framing"
imatix_openamq_frames_package = string.replace(imatix_openamq_frames_dir, "/|.")
type_type_last = undefined ? 
type_type = undefined ?
set_type = undefined ? 

#  ------------------------------   Functions  --------------------------------

function abort_xml_error ()
    abort xml.error
endfunction

#  ------------------------------   Name style --------------------------------

function c2java_class (name)
    return string.replace("$(my.name: Neat)", "_|")
endfunction

function c2java_name (name)
    my.name = string.replace("$(my.name: Neat)", "_|")
    my.name = "$(string.substr(my.name, 0, , 1):lower)" + "$(string.substr(my.name, 1, , ):)"
    return my.name
endfunction

#  ------------------------------   Class hierarchy ---------------------------

function generate_directories ()
-   Java code from Imatix's openamq project in here
    directory.create (imatix_openamq_dir)
-   Framing / Deframing code in here
    directory.create (imatix_openamq_frames_dir)
endfunction

#  ------------------------------   Helper functions -------------------------

function get_type_type()
    for field
        if (name = "type")
            if    type = "char"
                my.type = "char"
            elsif type = "bit"
                my.type = "boolean"
            elsif type = "octet"
                my.type = "byte"
            elsif type = "shortint"
                my.type = "short"
            elsif type = "longint"
                my.type = "int"
            elsif type = "shortstr"
                my.type = "String"
            elsif type = "longstr" | type = "table"
                my.type = "byte[]"
            endif
        endif
    endfor
    return my.type
endfunction

function get_type_value()
    for field
        if (name = "type")
            my.value = value
        endif
    endfor
    return my.value
endfunction

function parse_frames (frames)
    name   = "$(name:c)"
    prefix = "$(prefix:c)"
    for . where name() = "frame"
        if name = "frame"
            abort "'frame' is a reserved name, please change this"
        endif
        name = "$(name:c)"
        for field
            name = "$(c2java_name("$(name:c)"))"
        endfor
    endfor
endfunction

function build_frame_lists (frames, outertype, code)
 scope my.frames
   my.count = 0
   for frame where string.prefixed(name, my.outertype)
        my.frame_name = name
        my.current_inner = "$(string.substr (my.frame_name, string.length(my.outertype) + 1, , ))"
-       The consume message exception        
        if (my.code = 3)
            for field 
                my.count += 1
                if (my.count > 1)
                    echo ("java/$(script:): build_frame_lists: FATAL, code = 3 unexpected exception.")
                endif
                >        return new $(my.current_inner: Neat)(dis);
                last
            endfor
-       The create message exception        
        elsif (my.code = 5)
            for field 
                my.count += 1
                if (my.count > 1)
                    echo ("java/$(script:): build_frame_lists: FATAL, code = 5 unexpected exception.")
                endif
                >        return new $(my.current_inner: Neat)();
                last
            endfor
        else
            if (my.code = 1)
                my.type = get_type_type() ?
                if (my.count = 0 & defined (my.type))
                    >    // Frame-types
                    my.count = 1
                endif
            endif
            for field where name = "type"
-               Constants
                if (my.code = 1)
                    >    public final static $(my.type:) 
                    >        $(my.current_inner: UPPER) = $(value:);  /* $(my.current_inner: Neat) type   */
-               The frame consume cases
                elsif (my.code = 2)
                    >            case $(my.current_inner: UPPER): 
                    >                return new $(my.current_inner: Neat)(bucket);
                elsif (my.code = 4)
                    >            case $(my.current_inner: UPPER): 
                    >                return new $(my.current_inner: Neat)();
                endif
            endfor
        endif
    endfor
 endscope
endfunction

function build_if_lists (frames, outertype, AMQPFramingFactory, code)
 scope my.frames
    if (my.code = 1)      
        my.action = "consume"
        my.extra_indent = ""        
    elsif (my.code = 2)      
        my.action = "create"
        my.extra_indent = ""        
    endif        
    my.indent = ""        
    for frame
-      The function get_type_value is added just to allow the triggering of the empty value 
        type_value = "type " + get_type_value() ?
        my.new_outertype = string.prefix (name, "_")
        if (!defined(my.outertype) | my.new_outertype <> my.outertype)
            my.outertype = my.new_outertype
            if (defined (type_value))
                my.indent += "    "  
                if (my.code = 1)
                    >    $(my.extra_indent)$(my.indent)if ((frame = $(my.outertype: lower).$(my.action)Frame($(string.prefix(type_value, " "):), bucket)) == null)
                elsif (my.code = 2)
                    >    $(my.extra_indent)$(my.indent)if ((frame = $(my.outertype: lower).$(my.action)Frame($(string.prefix(type_value, " "):))) == null)
                endif
            endif
        endif
    endfor
    my.indent += "    "  
    if (my.code = 1)
    >    $(my.extra_indent)$(my.indent)exception(null, "$(AMQPFramingFactory:)", "$(my.action)Frame", "unrecognized frame");
    elsif (my.code = 2)
    >    $(my.extra_indent)$(my.indent)runtimeException(null, "$(AMQPFramingFactory:)", "$(my.action)Frame", "unrecognized frame");
    endif
 endscope
endfunction

function build_variables (frame, do_type)
    for field
        if    type = "char"
            my.type = "char"
        elsif type = "bit"
            my.type = "boolean"
        elsif type = "octet"
            my.type = "short"
        elsif type = "shortint"
            my.type = "int"
        elsif type = "longint"
            my.type = "long"
        elsif type = "shortstr"
            my.type = "String"
        elsif type = "longstr" | type = "table"
            my.type = "byte[]"
        endif
        if ((name = "type") & my.do_type)
            >        short
            >            $(name:) = -1;                       /*  $(.?:)                           */
        elsif ((name <> "type") & !my.do_type)
            >        public $(my.type:)
            >            $(name:);                            /*  $(.?:)                           */
        endif
    endfor
endfunction

function build_decoding (frame, is, inner)
    my.bit_count = 0
    for field
        if    type <> "bit" & my.bit_count > 0
-           Prepare for new bitfield blocks 
            my.bit_count = 0
        endif
        if (name <> "type") 
            if    type = "char"
                >                $(name:) = (char)u($(my.is).readByte());
            elsif type = "bit"
                if (my.bit_count = 0)
-                   Read the bitfield 
                    >                byte flags = $(my.is).readByte();
                endif
                >                $(name:) = (flags & (1 << $(my.bit_count))) > 0;
                my.bit_count += 1
            elsif type = "octet"
                >                $(name:) = u($(my.is).readByte());
            elsif type = "shortint"
                >                $(name:) = u($(my.is).readShort());
            elsif type = "longint"
                >                $(name:) = u($(my.is).readInt());
            elsif type = "shortstr"
                >                {byte[] bytes = new byte[u($(my.is).readByte())];
                >                 readBytes($(my.is), bytes, 0, bytes.length);
                >                 $(name:) = bytes2String(bytes);}
            elsif type = "longstr" | type = "table"
                >                $(name:) = new byte[u($(my.is).readShort())];
                >                readBytes($(my.is), $(name:), 0, $(name:).length);
            endif
        endif
    endfor
endfunction

function build_encoding (frame, os)
    my.bit_count = 0
    for field
        if    type <> "bit" & my.bit_count > 0
-           Write the bitfield 
            >                $(my.os).writeByte(flags);
-           Prepare for new bitfield blocks 
            my.bit_count = 0
        endif
        if    type = "char"
            >                $(my.os).writeByte(s((short)$(name:)));
        elsif type = "bit"
-           Compose the bitfield
            if (my.bit_count = 0)
                >                byte flags = 0;
            endif
            >                if ($(name:))
            >                   flags |= 1 << $(my.bit_count);        
            my.bit_count += 1
        elsif type = "octet"
            >                $(my.os).writeByte(s($(name:)));
        elsif type = "shortint"
            >                $(my.os).writeShort(s($(name:)));
        elsif type = "longint"
            >                $(my.os).writeInt(s($(name:)));
        elsif type = "shortstr"
            >                if ($(name:) != null) {
            >                    {byte[] bytes = string2Bytes($(name:));
            >                     $(my.os).writeByte(s((short)bytes.length));
            >                     writeBytes($(my.os), bytes, 0, bytes.length);}
            >                } else {
            >                    $(my.os).writeByte(0);
            >                }
        elsif type = "longstr" | type = "table"
            >                if ($(name:) != null) {
            >                    $(my.os).writeShort(s((int)$(name:).length));
            >                    writeBytes($(my.os), $(name:), 0, $(name:).length);
            >                } else {
            >                    $(my.os).writeShort(0);
            >                }
        endif
    endfor
    if    my.bit_count > 0
-       Write the bitfield 
        >                $(my.os).writeByte(flags);
    endif
endfunction

function build_dumping (frame, os)
    >            $(my.os:).print("I:");
    for field
        if    type = "char"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "bit"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "octet"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "shortint"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "longint"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "shortstr"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "longstr" | type = "table"
            >            $(my.os:).print(" $(name:) = ");
            >            if ($(name:) != null) 
            >                $(my.os:).print(hexDump($(name:)));
        endif
    endfor
    >            $(my.os:).println("");
endfunction

function build_framing (class, inner, AMQPFrameException)
    my.full_name = "$(my.class + "." + my.inner:)"
    my.full_name_comments = "$(my.class + " " + my.inner: lower)"
    if (defined (set_type)) 
        my.decode_type = "byte[]"
        my.decode_source = "bucket"
    else
        my.decode_type = "DataInputStream"
        my.decode_source = "dis"
    endif
-   Constructors        
    >        /**
    >         *
    >         * Default constructor for $(my.full_name:)
    >         *
    >         **/
    >        public $(my.inner:)() {$(set_type?:)}
    >
    >        /**
    >         *
    >         * Decoder constructor for $(my.full_name:)
    >         *
    >         **/
    >        public $(my.inner:)($(my.decode_type:) $(my.decode_source:)) throws $(AMQPFrameException:) {
    >            this();
    >            decode($(my.decode_source:));
    >        }
    >
-   Deframing        
    >        /**
    >         *
    >         * Frame decoder for $(my.full_name_comments:) frames
    >         *
    >         **/
    >        public void decode($(my.decode_type:) $(my.decode_source:)) throws $(AMQPFrameException:) {
    if (defined (set_type)) 
        >            // We decode from a byte array bucket
        >            ByteArrayInputStream 
        >                bais = new ByteArrayInputStream(bucket);   /* Frame stream                     */
        >            DataInputStream 
        >                dis = new DataInputStream(bais);           /* Frame data reader                */
        >
    endif
    >            try {
    build_decoding (., "dis", my.inner)
    if (defined(set_type))
    >                byte ce = dis.readByte();
    >                if (ce != AMQP_COMMAND_END) 
    >                    exception(null, "$(my.full_name:)", "decode", "frame command-end expected but got " + ce);
    endif
    >            } catch (IOException e) {
    if (defined (set_type))
    >                try {
    >                    dis.close();
    >                } catch (IOException f) {}
    >                runtimeException(e, "$(my.full_name:)", "decode", "cannot decode");
    else
    >                exception(e, "$(my.full_name:)", "decode", "cannot decode");
    endif
    >            }
    >        }
    >
-   Framing        
    >        /**
    >         *
    >         * Frame encoder for $(my.full_name_comments:) frames
    >         *
    >         **/
    >        public int encode() throws $(AMQPFrameException:) {
    >            return encode(null);
    >        }
    >
    >        /**
    >         *
    >         * Frame encoder for $(my.full_name_comments:) frames (transient bucket)
    >         *
    >         **/
    >        public int encode($(AMQPFramingFactory:) ff) throws $(AMQPFrameException:) {
    >            // We encode into a byte array bucket
    >            ByteArrayOutputStream 
    >                baos = new ByteArrayOutputStream();          /* Frame stream                     */
    >            DataOutputStream 
    >                dos = new DataOutputStream(baos);            /* Frame data writer                */
    >
    >            try {
    build_encoding (., "dos")
    if (defined(set_type))
    >                dos.writeByte(AMQP_COMMAND_END);
    endif
    >
    >                if (ff == null) {
    >                    // Allocate a bucket
    >                    bucket = baos.toByteArray();
    >                    dos.close();
    >                    return bucket.length;
    >                } else {
    >                    int size = baos.size();
    >
    if (defined(set_type))
    >                    // Write frame header with the passed ff
    >                    ff.produceFrameHeader(size);
    endif
    >                    // Write frame body with the passed ff
    >                    ff.produceData(baos);
    >                    dos.close();
    >                    return size;
    >                }
    >            } catch (IOException e) {
    >                try {
    >                    dos.close();
    >                } catch (IOException f) {}
    >                runtimeException(e, "$(my.full_name:)", "encode", "cannot encode");
    >                return -1;
    >            }
    >        }
    >
-   Dumping
    >        /**
    >         *
    >         * Frame dumper for $(my.full_name_comments:) frames
    >         *
    >         **/
    >        public void dump() {
    build_dumping (., "System.out")
    >        }
endfunction

#  ------------------------------   Output macro -----------------------------

.macro generate_frames (frames)
. scope my.frames
.-  Set the java output directory
.   directory.setcwd(imatix_openamq_frames_dir)
.-  outertype refers to one of connection, channel, handle or message
.-  Iterate through frames and generate .java files for outertypes (realted types must be together)
.   for frame
.-      Set some frame type variables
.       type_type = get_type_type() + " type" ?
.       type_type_comma = type_type + ", " ?
.       if (defined (type_type))
.           type_type_last = type_type
.       endif
.-      This takes the beginnings of frame names to generate new files
.       my.new_outertype = string.prefix (name, "_")
.       if (!defined (my.outertype))
.           my.outertype = my.new_outertype
.           my.outertype_break = 1
.       elsif (my.new_outertype <> my.outertype)
.           my.outertype = my.new_outertype
.           my.outertype_break = 2
.       else
.           my.outertype_break = 0
.       endif
.-      Write file headers only for new outertypes (connection, channel, handle, message)
.       if (my.outertype_break > 0)
.-          Close current class
.           if (my.outertype_break > 1)
$(utilities:)    
$(error_handling:)    
}
. close
.           endif
.-          The message type is not formally a frame type 
.           my.first_inner = string.substr (name, string.length(my.outertype) + 1, , )
.-          Command frames
.           if (defined (type_type))
.               my.frame_super = AMQPFrame
.-          The message head
.           else
.               my.frame_super = "$(my.first_inner : Neat)"
.           endif
.echo "Generating $(class_prefix:)$(my.outertype: Neat).java..."
. output "$(class_prefix:)$(my.outertype: Neat).java"
/**
 *  $(class_prefix:)$(my.outertype: Neat).java - AMQP $(my.outertype) frames.
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package:);

import java.io.InputStream;
import java.io.OutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
 
public class $(class_prefix:)$(my.outertype: Neat) {
    // Constants
    final static byte 
        AMQP_COMMAND_END = (byte)0xCE;           /* Frame last byte                  */
.           build_frame_lists (my.frames, my.outertype, 1)   
    
    /**
     *
     * $(my.outertype: Neat) default constructor
     *
     **/
    $(class_prefix:)$(my.outertype: Neat)() {
    } 
    
    /**
     *
     * $(my.outertype: Neat) frame consumer
     *
     **/
    $(my.frame_super:) consumeFrame($(type_type_comma + "byte[] bucket" ? "DataInputStream dis":)) throws $(AMQPFrameException:) {
.-          Not for message
.           if (defined (type_type))    
        switch (type) {
.       build_frame_lists (my.frames, my.outertype, 2)               
        }
        return null;
.           else           
.-          The message case
.       build_frame_lists (my.frames, my.outertype, 3)               
.           endif           
    } 
    
    /**
     *
     * $(my.outertype: Neat) frame creator
     *
     **/
    $(my.frame_super:) createFrame($(type_type ? "":)) throws $(AMQPFrameException:) {
.-          Not for message
.           if (defined (type_type))    
        switch (type) {
.       build_frame_lists (my.frames, my.outertype, 4)               
        }
        return null;
.           else        
.-          The message case
.       build_frame_lists (my.frames, my.outertype, 5)               
.           endif           
    } 

.-          Command frames
.           if (defined (type_type))
    /**
     *
     * $(my.outertype: Neat) frames superclass
     *
     **/
    abstract class $(AMQPFrame:) extends $(imatix_openamq_frames_package).$(AMQPFrame:) {
.           build_variables (., 1)
    }
.           endif    
.-      Finished with outertype methods
.       endif
.-  Write the frame types for this outertype
.       my.current_inner = string.substr (name, string.length(my.outertype) + 1, , )
.-      Command frames
.       if (defined (type_type))
.           set_type = "type = $(my.current_inner: UPPER);" ?
.-      The message head
.       else
.           set_type = undefined ?
.       endif

    /**
     *
     * $(my.current_inner: Neat) frame
     *
     **/
.-      Command frames
.       if (defined (type_type))
    public class $(my.current_inner: Neat) extends $(AMQPFrame:) {
.-      The message head
.       else
    public class $(my.current_inner: Neat) extends $(AMQPFramable:) {
.       endif
.       build_variables (., 0)

.       build_framing ("$(my.outertype: Neat)", "$(my.current_inner: Neat)", AMQPFrameException) 
    }    
.-  Finished with last class body
.   endfor
$(utilities:)    
$(error_handling:)    
}

.-  Close last class
. close
.- Frames and message header super class (AMQP network-serializable objects)
.echo "Generating $(AMQPFramable:).java..."
. output "$(AMQPFramable:).java"
/**
 *  $(AMQPFramable:).java - Super class for network-serializable objects.
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package:);

import java.io.DataInputStream;

public abstract class $(AMQPFramable:) {
    public byte[] bucket = null;                           /*  The frame bytes                  */

    /**
     * 
     * Default constructor 
     *
     **/
    public $(AMQPFramable:)() {}

    /**
     *
     * Decoder constructor 
     *
     **/
    public $(AMQPFramable:)(byte[] bucket) throws $(AMQPFrameException:) {}

    /**
     *
     * Encoder method
     *
     **/
    public int encode() throws $(AMQPFrameException:) {return 0;}
    
    /**
     *
     * Encoder method
     *
     **/
    public int encode($(AMQPFramingFactory) ff) throws $(AMQPFrameException:) {return 0;}
    
    /**
     *
     * Frame dumping method
     *
     **/
    public void dump() {}
}

. close
.- Regular frames super class (to follow a frame header generated by the AMQPFactory)
.echo "Generating $(AMQPFrame:).java..."
. output "$(AMQPFrame:).java"
/**
 *  $(AMQPFrame:).java - Regular frames super class.
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package:);

import java.io.DataInputStream;

public abstract class $(AMQPFrame:) extends $(AMQPFramable:) {
}

. close
.- Glues the frame types together onto this utility class
.echo "Generating $(AMQPFramingFactory:).java..."
. output "$(AMQPFramingFactory:).java"
/**
 *  $(AMQPFramingFactory:).java - Handles frames and related functionality.
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package:);

import java.io.InputStream;
import java.io.OutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FilterInputStream;
import java.io.FilterOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;

public class $(AMQPFramingFactory:) {
    // Constants
    final static String 
        STRING_ENC = "UTF-8";                              /* Prefered string encoding         */
    final static int 
        FRAME_LONG = 0xFFFF,                               /* Frames >= to this are long       */
        FRAME_MIN = 1024,                                  /* Minimum frameMax value accepted  */
        WRITE_IDLE = -1,                                   /* Writer thread is idle            */
        WRITE_FLUSH = 0,                                   /* Writer thread flush request      */
        WRITE_BYTES = 1,                                   /* Writer thread write request      */
        WRITE_BAOS = 2;                                    /* Write from ByteArrayOutputStream */
    
    // Variabes
    static int     
        readRetryLatency = 100;                            /* Wait this before retrying (ms)   */
    public boolean 
        verbose = false;                                   /* Verbose switch                   */
    public long        
        frameMax = 4096;                                   /* Initial maximum frame size       */
    $(AMQPFieldTable:)
        tuning = null;                                     /* Connection tune parameters       */
    int 
        priority = Thread.currentThread().getPriority();   /* Main thread priority             */
    // Network streams    
    DataInputStream 
        incoming;                                          /* Incoming stream                  */
    DataOutputStream 
        outgoing;                                          /* Outgoing stream                  */
    // Frame types instances
.   my.outertype = undefined ?
.   for frame
.       my.new_outertype = string.prefix (name, "_")
.       if (!defined(my.outertype) | my.new_outertype <> my.outertype)
.           my.outertype = my.new_outertype
    $(class_prefix:)$(my.outertype: Neat) 
        $(my.outertype: lower) = new $(class_prefix:)$(my.outertype: Neat)();\
                                                           /* $(my.outertype: Neat)            */
.       endif
.   endfor    
    // Write command
    int 
        writeCommand = -1,                                 /* Writer thread request            */
        writeOff,                                          /* Write offset parameter           */
        writeLen,                                          /* Writer length parameter          */
        timeout = 0;                                       /* Writer timeout (0 ms == block)   */
    byte[] 
        writeBytes;                                        /* Writer data command data array   */
    ByteArrayOutputStream 
        writeBaos;                                         /* Writer data baos source          */
    OutputStream 
        writeOs;                                           /* Writer data os target            */
    IOException 
        ioe = null;                                        /* Writer thread exception          */
    // This thread buffers and flushes outgoing data
    Thread 
        writer = new Thread() {                            /* Writer thread                    */
            public void run() {
                // Some VMs lower too much the priority of threads spawned from main
                setPriority(priority);
                synchronized(outgoing) {
                    while (outgoing != null) {
                        // Wait for write command
                        synchronized(writer) {
                            while (writeCommand == WRITE_IDLE) {
                                try {
                                    writer.wait();
                                } catch (InterruptedException e) {}
                            }
                        }
                        // Perform write command
                        try {
                            writeOs = (writeOs == null) ? outgoing : writeOs;
                            switch (writeCommand) {
                                case WRITE_BYTES:
                                    writeBytes(writeOs, writeBytes, writeOff, writeLen);
                                    break;
                                case WRITE_BAOS:
                                    writeBaos.writeTo(writeOs);
                                    break;
                                case WRITE_FLUSH:
                                    writeOs.flush();
                            }
                            writeOs = null;
                        } catch (IOException e) {
                            synchronized(writer) {
                                ioe = e;
                            }
                        }
                        // Finished write command
                        synchronized(writer) {
                            writeCommand = WRITE_IDLE;
                            writer.notify();
                        }
                    }
                }
            }
        };
    
    /**
     *
     * $(AMQPFramingFactory:) constructor
     *
     **/
    public $(AMQPFramingFactory:)(Socket socket) throws IOException {
        incoming = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
        outgoing = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));
        setup(socket);
    } 

    /**
     *
     * $(AMQPFramingFactory:) configurable buffer constructor
     *
     **/
    public $(AMQPFramingFactory:)(Socket socket, int readBuff, int writeBuff) throws IOException {
        incoming = new DataInputStream(new BufferedInputStream(socket.getInputStream(), readBuff));
        outgoing = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), writeBuff));
        setup(socket);
    } 
    
    /**
     *
     * Setup for constructors
     *
     **/
    void setup(Socket socket) throws SocketException {
        // Copy the output timeout from the provided socket
        timeout = socket.getSoTimeout();
        // Start the writer thread
        writer.start();
    }    
    
    /**
     *
     * Set the connection tune parameters
     *
     **/
    public void setTuneParameters($(class_prefix:)Connection.Tune tune) throws $(AMQPFrameException) {
        tuning = new $(AMQPFieldTable)(tune.options);
        // Set the frame size limit
        frameMax = tuning.getInteger("FRAME_MAX");
        if (frameMax < FRAME_MIN)
            exception(null, "$(AMQPFramingFactory:)", "setTuneParameters", "FRAME_MAX too small (" + frameMax + " bytes)");
    }    
    
    /**
     *
     * Set incoming retry latency
     *
     **/
    public void setIncomingRetryLatency(int latency) {
        readRetryLatency = latency;
    }
    
    /**
     *
     * Flush output buffer
     *
     **/
    public void flush() throws IOException {
        synchronized(writer) {
            // Check previous completion status
            if (writeCommand != WRITE_IDLE) {
                try {
                    writer.wait(timeout);
                } catch (InterruptedException e) {}
                if (writeCommand != WRITE_IDLE) 
                    throw new SocketTimeoutException("$(AMQPFramingFactory:): flush: EXCEPTION, timeout.");
            }    
            // Check previous outcome
            if (ioe != null) {
                IOException aux = ioe;
                    
                ioe = null;
                throw new $(AMQPFrameIOException)(aux.getMessage());
            }
            // Request flush
            writeCommand = WRITE_FLUSH;
            writer.notify();
        }
    }

    /**
     *
     * Data consumer method (allocates)
     *
     **/
    public byte[] consumeData(int len) throws IOException {
        byte[] 
            bytes = new byte[len];                    /* Data bucket                      */
            
        consumeData(bytes, 0, bytes.length);
        
        return bytes;
    }
    
    /**
     *
     * Data consumer method
     *
     **/
    public void consumeData(byte[] bytes) throws IOException {
        consumeData(bytes, 0, bytes.length);
    }
    
    /**
     *
     * Data consumer method (offset and length)
     *
     **/
    public void consumeData(byte[] bytes, int off, int len) throws IOException {
        consumeData(incoming, bytes, off, len);
    }
    
    /**
     *
     * Data consumer method (InputStream, offset and length)
     *
     **/
    public void consumeData(InputStream is, byte[] bytes, int off, int len) throws IOException {
        readBytes(is, bytes, off, len);
    }
    
    /**
     *
     * Data producer
     *
     **/
    public void produceData(byte[] bytes) throws IOException {
        produceData(bytes, 0, bytes.length);
    }
    
    /**
     *
     * Data producer (offset and length)
     *
     **/
    public void produceData(byte[] bytes, int off, int len) throws IOException {
        produceData(outgoing, bytes, 0, bytes.length);
    }
    
    /**
     *
     * Data producer (ByteArrayOutputStream)
     *
     **/
    public void produceData(ByteArrayOutputStream baos) throws IOException {
        produceData(baos, null, -1, -1);
    }
    
    /**
     *
     * Data producer (OutputStream, offset and length)
     *
     **/
    public void produceData(OutputStream os, byte[] bytes, int off, int len) throws IOException {
        writeTimeout(os, bytes, off, len, timeout);
        flush();
    }
    
    /**
     *
     * This returns an InputStream for reading a message body
     * The first handle notify and the head for this message must be supplied
     * If the passed input stream is null, in-band message consumption will take place 
     * Copies the destName variable in the last handle notify to the provided hnFirst
     *
     **/
    public InputStream getMessageBodyInputStream($(class_prefix:)Handle.Notify hnFirst, $(class_prefix:)Message.Head head, InputStream is, boolean prepared)\
    throws IOException {
        return new MessageBodyInputStream(hnFirst, head, is != null ? is : incoming, prepared);
    }
    
    /**
     *
     * This class processes handle notifies from the server, and provides the body of the message as an inputstream
     *
     **/
    public class MessageBodyInputStream extends FilterInputStream {
        $(class_prefix:)Handle.Notify 
            hnFirst,                                       /* Parameters of first fragment     */
            hnCurr;                                        /* Parameters of current fragment   */
        $(class_prefix:)Message.Head 
            head;                                          /* Header for the message           */            
        InputStream
            is;                                            /* Copy of the passed input stream  */            
        long
            mRead,                                         /* Message read so far              */
            fRead;                                         /* Fragment read so far             */
        boolean
            fNew,                                          /* Unread fragment ready            */
            empty = false;                                 /* End of stream                    */
    
        MessageBodyInputStream($(class_prefix:)Handle.Notify hnFirst, $(class_prefix:)Message.Head head, InputStream is, boolean prepared) throws IOException {
            super(is);

            try {
                this.hnFirst = hnCurr = hnFirst;
                this.head = head;
                this.is = is;
                mRead = 0; 
                fRead = prepared ? 0 : head.encode();
                fNew = fRead == 0;
            } catch ($(AMQPFrameException:) e) {
                // Encapsulate the exception as $(AMQPFrameIOException) to allow method overloading
                throw new $(AMQPFrameIOException)(e.getMessage());
            }
        }
        
        /**
         *
         * Return the number of bytes we can give from the buffer
         *
         */
        public int available() throws IOException {
            if (hnCurr.fragmentSize - fRead == 0 && !fNew)
                consumeHandleNotify();                
            // We will tell the current amount of available remaining fragment
            return (int)Math.min(Integer.MAX_VALUE, Math.min(super.available(), hnCurr.fragmentSize - fRead));
        }
        
        /**
         *
         * The underlying stream will NOT be closed
         *
         */
        public void close() throws IOException {
            try {
                // Test for some inconsistencies    
                if (mRead < head.bodySize)
                    exception(null, "MessageBodyInputStream", "close", "message body underflow");
                if (mRead > head.bodySize)
                    exception(null, "MessageBodyInputStream", "close", "message body overflow");
            } catch ($(AMQPFrameException:) e) {
                // Encapsulate the exception as $(AMQPFrameIOException) to allow method overloading
                throw new $(AMQPFrameIOException)(e.getMessage());
            }
        }
        
        /**
         *
         * This will read a byte from the message
         *
         */
        public int read() throws IOException {
            byte[]
                aByte = new byte[1];
                
            if (read(aByte, 0, aByte.length) != -1) 
                return aByte[0];
            else
                return -1;    
        }
        
        /**
         *
         * This will read some bytes from the message
         *
         */
        public int read(byte[] bytes) throws IOException {
            return read(bytes, 0, bytes.length);
        }
        
        /**
         *
         * This will read a specified amount of bytes from the message
         *
         */
        public int read(byte[] bytes, int off, int len) throws IOException {
            if (!empty) {
                long
                    available; 
                    
                available = hnCurr.fragmentSize - fRead;
                if (available >= len) {
                    // Read from current fragment
                    mRead += len;
                    fRead += len;
                    fNew = len == 0;
                    consumeData(is, bytes, off, len);
                    if (verbose) 
                        System.out.println("I: read " + len + " bytes from server (of fragment)");
                    if (mRead >= head.bodySize)    
                        empty = true;
                    return len;
                } else {
                    if (available > 0) {
                        // Read what is available from current fragment
                        consumeData(is, bytes, off, (int)available);
                        if (verbose) 
                            System.out.println("I: read " + available + " bytes from server (of fragment)");
                    }    
                    // We must get another handle notify
                    if (consumeHandleNotify() == -1)
                        empty = true;
                    return read(bytes, (int)(off + available), (int)(len - available));
                }
            } else {
                // The stream is empty
                return -1;
            }
        }
        
        int consumeHandleNotify() throws IOException {
            try {
                if (hnCurr.partial) {
                    $(class_prefix:)Frame frame = consumeFrame();
                    if (frame instanceof $(class_prefix:)Handle.Notify) {
                        fRead = 0;
                        fNew = true;
                        hnCurr = ($(class_prefix:)Handle.Notify)frame;
                        if (hnCurr.fragmentSize > frameMax)
                            exception(null, "MessageBodyInputStream", "consumeHandleNotify", "oversized fragment");
                        if (!hnCurr.partial) 
                            hnFirst.destName = hnCurr.destName;
                    } else {
                        frame.dump();
                        exception(null, "MessageBodyInputStream", "consumeHandleNotify", "unexpected frame");
                    }
                } else {    
                
                    return -1;
                }    
            } catch ($(AMQPFrameException:) e) {
                // Encapsulate the exception as $(AMQPFrameIOException) to allow method overloading
                throw new $(AMQPFrameIOException)(e.getMessage());
            }
            
            return 0;
        }
        
        /**
         *
         * Is mark/reset supported (no, no need for look-ahead due to the protocol nature)
         *
         */
        public boolean markSupported() {
            return false;
        }
        
        /**
         *
         * Throws a runtime exception
         *
         */
        public void mark(int limit) {
            runtimeException(null, "MessageBodyInputStream", "mark", "mark not supported");
        }
        
        /**
         *
         * Throws a runtime exception
         *
         */
        public void reset() throws IOException {
            runtimeException(null, "MessageBodyInputStream", "reset", "reset not supported");
        }
        
        /**
         *
         * Skip bytes on the underlying reader
         *
         */
        public long skip(long n) throws IOException {
            long
                skip = n;
            int
                kilo = 1024,
                kilos = 64 * kilo;
            byte[]
                aKilo = new byte[kilo], 
                someKilos = new byte[kilos]; 
        
            while (available() > 0 && n > 0) {    
               // Skip some kilobytes
               if (available() >= kilos) { 
                    read(someKilos, 0, kilos);
                    n -= kilos;
                    continue;
                }                
                
                // Skip kilobytes
                if (available() >= kilo) { 
                    read(aKilo, 0, kilo);
                    n -= kilo;
                    continue;
                }                
                
                // Skip remaining bytes
                while (available() >= 1) {  
                    read();
                    n --;
                }    
            } 
            
            return skip - n;   
        }
    }
    
    /**
     *
     * This returns an OutputStream for writing a message body
     * The first handle send and the head for this message must be supplied
     * If the passed output stream is null, in-band message production will take place 
     * Uses the destName variable from the provided hsFirst for the last handle send
     * Sends fragments of the size specified in hsFirst.fragmentSize 
     *
     */
    public OutputStream getMessageBodyOutputStream($(class_prefix:)Handle.Send hsFirst, $(class_prefix:)Message.Head head, OutputStream os, boolean prepared)\
    throws IOException {
        return new MessageBodyOutputStream(hsFirst, head, os != null ? os : outgoing, prepared);
    }
 
    /**
     *
     * This class fragments the message body generating handle sends as needed 
     *
     **/
    public class MessageBodyOutputStream extends FilterOutputStream {
        $(class_prefix:)Handle.Send 
            hsCurr;                                        /* Parameters for current fragment  */
        $(class_prefix:)Message.Head 
            head;                                          /* Header for the message           */            
        OutputStream
            os;                                            /* Copy of the passed output stream */
        String
            destName;                                      /* Destination name                 */
        long
            mWritten,                                      /* Message written so far           */
            fWritten,                                      /* Fragment written so far          */
            fragmentSize;                                  /* Target fragment size             */
        boolean
            full = false;                                  /* The message body was written     */
    
        MessageBodyOutputStream($(class_prefix:)Handle.Send hsFirst, $(class_prefix:)Message.Head head, OutputStream os, boolean prepared) throws IOException {
            super(os);
            try {
                if (hsFirst.fragmentSize > frameMax)
                    exception(null, "MessageBodyOutputStream", "MessageBodyOutputStream", "oversized fragment");
                destName = hsFirst.destName;
                if (!hsFirst.partial) {
                    if (head.encode() + head.bodySize > hsFirst.fragmentSize)
                        exception(null, "MessageBodyOutputStream", "MessageBodyOutputStream", "partial is false but message does not fit in fragment");
                } else {
                    hsFirst.destName = "";
                }    
                fragmentSize = hsFirst.fragmentSize;
                hsCurr = hsFirst;
                this.head = head;
                this.os = os;
                mWritten = 0;
                fWritten = prepared ? 0 : head.encode();
            } catch ($(AMQPFrameException:) e) {
                // Encapsulate the exception as $(AMQPFrameIOException) to allow method overloading
                throw new $(AMQPFrameIOException)(e.getMessage());
            }
        }
        
        /**
         *
         * The underlying stream will NOT be closed
         *
         */
        public void close() throws IOException {
            try {
                // Test for some inconsistencies    
                if (mWritten < head.bodySize)
                    exception(null, "MessageBodyOutputStream", "close", "message body underflow");
                if (mWritten > head.bodySize)
                    exception(null, "MessageBodyOutputStream", "close", "message body overflow");
            } catch ($(AMQPFrameException:) e) {
                // Encapsulate the exception as $(AMQPFrameIOException) to allow method overloading
                throw new $(AMQPFrameIOException)(e.getMessage());
            }
        }
        
        /**
         *
         * This writes a byte from the message
         *
         */
        public void write(int b) throws IOException {
            byte[]
                aByte = new byte[]{(byte)b};
                
            write(aByte, 0, aByte.length);
        }
        
        /**
         *
         * This will write some bytes from the message
         *
         */
        public void write(byte[] bytes) throws IOException {
            write(bytes, 0, bytes.length);
        }
        
        /**
         *
         * This will write a specified amount of bytes from the message
         *
         */
        public void write(byte[] bytes, int off, int len) throws IOException {
            if (!full) {
                long
                    available; 
                    
                available = hsCurr.fragmentSize - fWritten;
                if (available >= len) {
                    // Fill current fragment
                    mWritten += len;
                    fWritten += len;
                    produceData(os, bytes, off, len);
                    if (verbose) 
                        System.out.println("I: wrote " + len + " bytes to server (of fragment)");
                    if (mWritten > head.bodySize)
                        full = true;    
                } else {
                    if (available > 0) {
                        // Fill what is available from current fragment
                        produceData(os, bytes, off, (int)available);
                        if (verbose) 
                            System.out.println("I: wrote " + available + " bytes to server (of fragment)");
                    }    
                    // We must generate another handle send
                    if (produceHandleSend() == -1) 
                        full = true;
                    write(bytes, (int)(off + available), (int)(len - available));
                }
            }
        }
        
        /**
         *
         * This will prepare for sending the next message fragment
         *
         */
        int produceHandleSend() throws IOException {
            try {
                if (hsCurr.partial) {
                    long
                        mLeft = head.bodySize - mWritten;
                    if (mLeft <= fragmentSize) {
                        // This should be the last fragment
                        hsCurr.partial = false;
                        hsCurr.destName = destName;
                    }
                    hsCurr.fragmentSize = Math.min(fragmentSize, mLeft); 
                    fWritten = 0;
                    produceFrame(hsCurr);
                } else {
                    
                    return -1;
                }
            } catch ($(AMQPFrameException:) e) {
                // Encapsulate the exception as $(AMQPFrameIOException) to allow method overloading
                throw new $(AMQPFrameIOException)(e.getMessage());
            }
            
            return 0;
        }
    }
    
    /**
     *
     * Message head consumer method
     *
     **/
    public $(class_prefix:)Message.Head consumeMessageHead() throws $(AMQPFrameException:), IOException {
        $(class_prefix:)Message.Head head = null;
        
        // Read the message header
        head = ($(class_prefix:)Message.Head)message.consumeFrame(incoming);
        if (verbose) {
            System.out.println("I: read " + head.encode() + " bytes from server (message head)");
            head.dump();
        }
        
        return head;
    }
    
    /**
     *
     * Message head producer method
     *
     **/
    public void produceMessageHead($(class_prefix:)Message.Head head) throws $(AMQPFrameException:), IOException {
        int len = head.encode(this);
        if (verbose) 
            System.out.println("I: wrote " + len + " bytes to server (message head)");
    }
    
    /**
     *
     * Message head creator method
     *
     **/
    public $(class_prefix:)Message.Head createMessageHead() throws $(AMQPFrameException:) {
        return ($(class_prefix:)Message.Head)message.createFrame();
    }
    
    /**
     *
     * Frame consumer method
     *
     **/
    public $(AMQPFrame:) consumeFrame() throws $(AMQPFrameException:), IOException {
        $(AMQPFrame:) 
            frame = null;                                  /* Resulting frame                  */
        byte[] 
            bucket = null;                                 /* Raw frame bucket                 */
        int 
            frameSize;                                     /* The frame size                   */
        
        // Read the frame header
        frameSize = consumeFrameHeader();
        // Read frame type     
        $(type_type_last:) = incoming.readByte();
        // Read the rest of the frame
        bucket = new byte[frameSize - 1]; // Minus one byte we just read           
        readBytes(incoming, bucket, 0, bucket.length);
.   build_if_lists(my.frames, my.outertype, AMQPFramingFactory, 1)            
        if (verbose) {
            System.out.println("I: read " + (bucket.length + 1) + " bytes from server (frame)");
            frame.dump();
        }
        
        return frame;
    } 
    
    /**
     *
     * Frame producer method
     *
     **/
    public void produceFrame($(AMQPFrame:) frame) throws $(AMQPFrameException:), IOException {
        int len = frame.encode(this);
        if (verbose) {
            System.out.println("I: wrote " + len + " bytes to server (frame)");
            frame.dump();
        }
    } 
    
    /**
     *
     * Frame constructor method
     *
     **/
    public $(AMQPFrame:) createFrame($(type_type_last)) throws $(AMQPFrameException) {
        $(AMQPFrame:) frame = null;
        
.   build_if_lists(my.frames, my.outertype, AMQPFramingFactory, 2)            

        return frame;
    } 
    
    /**
     *
     * Frame header consumer
     *
     **/
    int consumeFrameHeader() throws $(AMQPFrameException), IOException {
        int 
            frameSize = incoming.readShort();              /* Frame size                       */
        
        if (frameSize == FRAME_LONG) {
            // The frame is long
            frameSize = incoming.readInt();
        }
        if (frameSize <= 0) 
            exception(null, "$(AMQPFramingFactory:)", "consumeFrameHeader", "zero-size frame rejected");
        else if (frameSize > frameMax) 
            exception(null, "$(AMQPFramingFactory:)", "consumeFrameHeader", "frame (" + frameSize + ") > frameMax (" + frameMax + " bytes) rejected");
            
        return frameSize;
    }
    
    /**
     *
     * Frame header producer
     *
     **/
    void produceFrameHeader(int frameSize) throws $(AMQPFrameException), IOException {
        ByteArrayOutputStream 
            baos = new ByteArrayOutputStream();            /* Frame header stream              */
        DataOutputStream 
            dos = new DataOutputStream(baos);              /* Frame header data writer         */
        byte[] 
            frameHeader;                                   /* Frame header ready for writer   */
        
        if (frameSize <= frameMax) {
            if (frameSize > 0) {
                if (frameSize >= FRAME_LONG) {
                    // Long frame
                    dos.writeShort(FRAME_LONG);
                    dos.writeInt(frameSize);
                } else {
                    // Short frame
                    dos.writeShort(frameSize);
                }
            
                frameHeader = baos.toByteArray();
                produceData(frameHeader);
                if (verbose) 
                    System.out.println("I: wrote " + frameHeader.length + " bytes to server (frame header)");
            } else {
                exception(null, "$(AMQPFramingFactory:)", "produceFrameHeader", "zero-size frame rejected");
            }
        } else {
            exception(null, "$(AMQPFramingFactory:)", "produceFrameHeader", "frame (" + frameSize + ") > frameMax (" + frameMax + " bytes) rejected");
        }
        dos.close();
    }
    
    /**
     *
     * Convert to unsigned int to long
     *
     **/
    final public static long u(int value) {
        if (value < 0)
            return value + ((long)1 << 32);
        else    
            return value;     
    }
    
    /**
     *
     * Convert to signed long to int
     *
     **/
    final public static int s(long value) {
        if (value > Integer.MAX_VALUE)
            return (int)(checkRange(value, 4) - ((long)1 << 32));
        else    
            return (int)value;     
    }
    
    /**
     *
     * Convert to unsigned short to int
     *
     **/
    final public static int u(short value) {
        if (value < 0)
            return value + (1 << 16);
        else    
            return value;     
    }
    
    /**
     *
     * Convert to signed int to short
     *
     **/
    final public static short s(int value) {
        if (value > Short.MAX_VALUE)
            return (short)(checkRange(value, 2) - (1 << 16));
        else    
            return (short)value;     
    }
    
    /**
     *
     * Convert to unsigned byte to short
     *
     **/
    final public static short u(byte value) {
        if (value < 0)
            return (short)(value + (1 << 8));
        else    
            return value;     
    }
    
    /**
     *
     * Convert to signed short to byte
     *
     **/
    final public static byte s(short value) {
        if (value > Byte.MAX_VALUE) 
            return (byte)(checkRange(value, 1) - (1 << 8));
        else   
            return (byte)value;     
    }
    
    /**
     *
     * Check if the given value is on the given range
     * Range can be 1 = byte, 2 = short, 4 = int
     *
     **/
    static int checkRange(long value, int range) {
        if (value < 0) 
            runtimeException(null, "$(AMQPFramingFactory:)", "checkRange", "value underflow");
    
        switch (range) {
            case 1:
                if (value > (1 << 8) - 1)
                    runtimeException(null, "$(AMQPFramingFactory:)", "checkRange", "byte overflow");
                break;
            case 2:
                if (value > (1 << 16) - 1)
                    runtimeException(null, "$(AMQPFramingFactory:)", "checkRange", "short overflow");
                break;    
            case 4:
                if (value > ((long)1 << 32) - 1)
                    runtimeException(null, "$(AMQPFramingFactory:)", "checkRange", "int overflow");
                break;    
        }
        
        return (int)value;
    }
    
    /**
     *
     * Return the hexadecimal representation of an array
     *
     **/
    public static String hexDump(byte[] bytes) {
        return baseDump(bytes, 16, 2);
    }
    
    /**
     *
     * Return the representation of an array in the requested base 
     *
     **/
    static String baseDump(byte[] bytes, int base, int size) {
        final String digits = "0123456789ABCDEF";
        String result = "";
        
        if (base > digits.length())
            runtimeException(null, "$(AMQPFramingFactory:)", "hexdump", "base to high");
        
        for (int i = 0; i < bytes.length; i++) {
            String a_byte_str = "";
            short a_byte = bytes[i];
            if (a_byte < 0)
                a_byte = (short)u(a_byte); 
            for (int j = 0; j < size; j++) { 
                a_byte_str = digits.charAt(a_byte % base) + a_byte_str;
                a_byte /= base;
            }
            
            result += a_byte_str + " ";    
        }
        
        return result;
    }
    
    /**
     *
     * Byte array to string translation
     *
     **/
    public static String bytes2String(byte[] bytes) {
        try {
            return new String(bytes, STRING_ENC);
        } catch (UnsupportedEncodingException e) {
            runtimeException(e, "$(AMQPFramingFactory:)", "bytes2String", "UnsupportedEncodingException");
            return null;
        }
    }
     
    /**
     *
     * String to byte array translation
     *
     **/
    public static byte[] string2Bytes(String string) {
        try {
            return string.getBytes(STRING_ENC);
        } catch (UnsupportedEncodingException e) {
            runtimeException(e, "$(AMQPFramingFactory:)", "string2Bytes", "UnsupportedEncodingException");
            return null;
        }
    }
    
    /**
     *
     * Read bytes
     *
     **/
    static void readBytes(InputStream is, byte[] b, int off, int len) throws IOException {
        while (len > 0) {
            int read = is.read(b, off, len);
            off += read;
            len -= read;
            if (len > 0) {
                try {
                    Thread.sleep(readRetryLatency);
                } catch (InterruptedException e) {}
            }
        }
    }
    
    /**
     *
     * Write bytes
     *
     **/
    static void writeBytes(OutputStream os, byte[] b, int off, int len) throws IOException {
        os.write(b, off, len);
    }
    
    /**
     *
     * Blocking-configurable bytes writing
     *
     **/
    void writeTimeout(OutputStream os, byte[] b, int off, int len, int timeout) throws IOException {
        synchronized(writer) {
            // Check previous completion status
            if (writeCommand != WRITE_IDLE) {
                try {
                    writer.wait(timeout);
                } catch (InterruptedException e) {}
                if (writeCommand != WRITE_IDLE) 
                    throw new SocketTimeoutException("$(AMQPFramingFactory:): writeBytes(timeout): EXCEPTION, timeout.");
            }    
            // Check previous outcome
            if (ioe != null) {
                IOException aux = ioe;
                    
                ioe = null;
                throw new $(AMQPFrameIOException)(aux.getMessage());
            }
            // Request write
            if (os instanceof ByteArrayOutputStream) {
                writeCommand = WRITE_BAOS;
                writeBaos = (ByteArrayOutputStream)os;
                writeOs = outgoing;
            } else {
                writeCommand = WRITE_BYTES;
                writeOs = os;
                writeBytes = b;
                writeOff = off;
                writeLen = len;
            }
            writer.notify();
        }
    }
    
    /**
     *
     * Warning handling
     *
     **/
    public static void warning(String message, String _class, String method) {
        try {
            exception(null, _class, method, "WARNING, " + message, 0); 
        } catch ($(AMQPFrameException:) e) {}
    }
    
    /**
     *
     * Exception handling
     *
     **/
    public static void exception(Exception e, String _class, String method, String message) throws $(AMQPFrameException:) {
        exception(e, _class, method, "Exception, " + message, 1); 
    }
    
    /**
     *
     * Runtime-exception handling
     *
     **/
    public static void runtimeException(Exception e, String _class, String method, String message) throws RuntimeException {
        try {
            exception(e, _class, method, "ERROR, " + message, 3); 
        } catch ($(AMQPFrameException:) f) {}
    }
    
    /**
     *
     * Exception handling
     *
     **/
    static void exception(Exception e, String _class, String method, String message, int type) throws $(AMQPFrameException:) {
        message = _class + ": " + method + ": " + message + ".";
        
        if (e != null) {
            e.printStackTrace();
            System.err.println("From java:");
            System.err.println(e.getMessage());
        }    
        System.err.println("E: " + message);
        switch (type) {
            case 1:
                throw new $(AMQPFrameException:)(message);
            case 2:
                throw new $(AMQPFrameError:)(message);
            case 3:
                throw new RuntimeException(message);
        }
    }
}

. close
.- Contains name/value pairs in a hashtable
.echo "Generating $(AMQPFieldTable:).java..."
. output "$(AMQPFieldTable:).java"
/**
 *  $(AMQPFieldTable:).java - Hashtable subclass for handling field tables
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package:);

import java.io.InputStream;
import java.io.OutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Hashtable;
import java.util.Date;
import java.util.Enumeration;

public class $(AMQPFieldTable:) extends Hashtable {
    DataInputStream
        dis;
    DataOutputStream
        dos;

    public $(AMQPFieldTable:)() {
    }
    
    public $(AMQPFieldTable:)(byte[] bucket) throws $(AMQPFrameException) {
        loadFromBucket(bucket);
    }
    
    public void loadFromBucket(byte[] bucket) throws $(AMQPFrameException) {
        try {
            dis = new DataInputStream(new ByteArrayInputStream(bucket));
            while (dis.available() > 0) {
                Object prev = null;
                String name = readName(dis);
                char type = readChar(dis);
                
                switch (type) {
                    case 'S': // Field string
                        prev = putString(name, readString(dis));
                        break;
                    case 'I': // Field integer
                        prev = putInteger(name, readInteger(dis));
                        break;
                    case 'D': // Field decimal
                        prev = putDecimal(name, readDecimal(dis));
                        break;
                    case 'T': // Field date/time
                        prev = putDateTime(name, readInteger(dis));
                        break;
                    default:
                        exception(null, "$(AMQPFieldTable:)", "loadFromBucket", "unrecognized field table type");
                }
                if (prev != null)
                    exception(null, "$(AMQPFieldTable:)", "loadFromBucket", "field redefined");
            }
            dis.close();
        } catch (IOException e) {
            try {
                dis.close();
            } catch (IOException f) {}
            runtimeException(e, "$(AMQPFieldTable:)", "loadFromBucket", "unable to load from bucket");
        }
    }
    
    public byte[] storeToBucket() {
        try {
            ByteArrayOutputStream
                baos = new ByteArrayOutputStream();
            Enumeration
                keys = keys();
            byte[]
                result;    
                
            dos = new DataOutputStream(baos);
            while (keys.hasMoreElements()) {
                String name = (String)keys.nextElement();
                Object value = get(name);
                
                writeName(dos, name);
                if (value instanceof byte[]) {
                    // Field string
                    writeChar(dos, 'S');
                    writeString(dos, (byte[])value);
                } else if (value instanceof Long) {
                    // Field integer
                    writeChar(dos, 'I');
                    writeInteger(dos, ((Long)value).longValue());
                } else if (value instanceof long[]) {
                    // Field decimal
                    writeChar(dos, 'D');
                    writeDecimal(dos, (long[])value);
                } else if (value instanceof Date) {
                    // Field date/time
                    writeChar(dos, 'T');
                    writeInteger(dos, ((Date)value).getTime());
                }    
            } 
            result = baos.toByteArray();
            dos.close();

            return result;            
        } catch (IOException e) {
            try {
                dos.close();
            } catch (IOException f) {}
            runtimeException(e, "$(AMQPFieldTable:)", "storeToBucket", "unable to write to bucket");
            return null;
        }
    }
    
    // Get/Put functions
    public byte[] getString(String name) {
        return (byte[])get(name);
    }
    
    public Object putString(String name, byte[] value) {
        return put(name, value);
    }
    
    public long getInteger(String name) {
        return ((Long)get(name)).longValue();
    }
    
    public Object putInteger(String name, long value) {
        return put(name, new Long(value));
    }
    
    public long[] getDecimal(String name) {
        return (long[])get(name);
    }
    
    public Object putDecimal(String name, long[] value) {
        return put(name, new long[]{value[0], value[1]});
    }
    
    public long getDateTime(String name) {
        return ((Date)get(name)).getTime();
    }
    
    public Object putDateTime(String name, long value) {
        return put(name, new Date(value));
    }

    // Read/write functions    
    static char readChar(DataInputStream dis) throws IOException {
        return (char)u(dis.readByte());
    }
    
    static void writeChar(DataOutputStream dos, char type) throws IOException {
        dos.writeByte(s((short)type));
    }
    
    public static String readName(DataInputStream dis) throws IOException {
        byte[] bytes = new byte[u(dis.readByte())];
        
        $(AMQPFramingFactory:).readBytes(dis, bytes, 0, bytes.length);
        
        return bytes2String(bytes);
    }
    
    public static void writeName(DataOutputStream dos, String name) throws IOException {
        byte[] bytes = string2Bytes(name);
        
        dos.writeByte(s((short)bytes.length));
        writeBytes(dos, bytes, 0, bytes.length);
    }
    
    public static byte[] readString(DataInputStream dis) throws IOException  {
        byte[] bytes = new byte[u(dis.readShort())];
        
        readBytes(dis, bytes, 0, bytes.length);
        
        return bytes;
    }
    
    public static void writeString(DataOutputStream dos, byte[] bytes) throws IOException {
        dos.writeShort(s((int)bytes.length));
        writeBytes(dos, bytes, 0, bytes.length);
    }
    
    static short readByte(DataInputStream dis) throws IOException  {
        return u(dis.readByte());
    }
    
    static void writeByte(DataOutputStream dos, short aByte) throws IOException  {
        dos.writeByte(s(aByte));
    }
    
    public static long readInteger(DataInputStream dis) throws IOException  {
        return u(dis.readInt());
    }
    
    public static void writeInteger(DataOutputStream dos, long aLong) throws IOException  {
        dos.writeInt(s(aLong));
    }
    
    public static long[] readDecimal(DataInputStream dis) throws IOException  {
       long decimals = readByte(dis);
       long integer = readInteger(dis);
       
       return new long[] {decimals, integer};
    }
    
    public static void writeDecimal(DataOutputStream dos, long[] decimal) throws IOException  {
        writeByte(dos, (short)decimal[0]);
        writeInteger(dos, decimal[1]);
    }
    
    $(utilities:)    
    $(error_handling:)  
}

. close
. endscope
.- Currently, this generates general exceptions. This can serve as the basis to generate more specialized exceptions.
.    my.current_exception = AMQPFrameException
.    my.current_extends = "Exception"
.    my.current_description = "General protocol exception"
.    my.current_with_cause = 1
.    my.current_import = undefined ?
.    while (defined(my.current_exception))
.        echo "Generating $(my.current_exception:).java..."
. output "$(my.current_exception:).java"
/**
 *  $(my.current_exception:).java - $(my.current_description)
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package);
 
.if (defined (my.current_import))
import $(my.current_import:)
 
.endif
public class $(my.current_exception:) extends $(my.current_extends:) {
    /**
     *
     * Default constructor
     *
     **/
    public $(my.current_exception:)() {
        super();
    }
    
    /**
     *
     * Message constructor
     *
     **/
    public $(my.current_exception:)(String message) {
        super(message);
    }
    
.if (my.current_with_cause)    
    /**
     *
     * Message and cause constructor
     *
     **/
    public $(my.current_exception:)(String message, Throwable cause) {
        super(message, cause);
    }
    
    /**
     *
     * Cause constructor
     *
     **/
    public $(my.current_exception:)(Throwable cause) {
        super(cause);
    }
.endif    
}

. close
.        if (my.current_exception = AMQPFrameException)
.            my.current_exception = AMQPFrameIOException
.            my.current_extends = "IOException"
.            my.current_description = "AMQP IOException"
.            my.current_with_cause = 0
.            my.current_import = "java.io.$(my.current_extends:);"
.        else
.            my.current_exception = undefined ?
.        endif
.    endwhile
.endmacro

#  ------------------------------   Main code  --------------------------------

if scope (frames)
    generate_directories ()
    parse_frames    (frames)
    generate_frames (frames)
endif 
.endtemplate
