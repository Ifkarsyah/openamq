.template 0
#! /usr/local/bin/gsl -a
#  ----------------------------------------------------------------------------
#   AMQ Frame Generator for Java
#
#   Frames are structures designed to be easily serialized for writing
#   to a socket or file.  Frames are described using an XML language.
#
#   This script generates frame structures and serialization code.
#
#   Copyright (c) 2005 JPMorgan
#   Copyright (c) 1991-2004 iMatix Corporation
#  ----------------------------------------------------------------------------

#  ------------------------------   Globals    --------------------------------

class_prefix = "AMQ"
FrugalByteArrayOutputStream = "FrugalByteArrayOutputStream"
AMQPTransport = "$(class_prefix:)Transport"
AMQPFramingFactory = "$(class_prefix:)FramingFactory"
AMQPFieldTable = "$(class_prefix:)FieldTable"
AMQPFramable = "$(class_prefix:)Framable"
AMQPFrame = "$(class_prefix:)Frame"
AMQPIOException = "$(class_prefix:)IOException"
AMQPException = "$(class_prefix:)Exception"
utilities = "
    // Utility functions from $(AMQPFramingFactory:)
    static String hexDump(byte[] bytes) {
        return $(AMQPTransport:).hexDump(bytes);
    }
    
    static String bytes2String(byte[] bytes) {
        return $(AMQPTransport:).bytes2String(bytes);
    }
     
    static byte[] string2Bytes(String string) {
        return $(AMQPTransport:).string2Bytes(string);
    } 
    
    static void readBytes(InputStream dis, byte[] b, int off, int len) throws IOException {
        $(AMQPTransport:).readBytes(dis, b, off, len);
    } 
    
    static void writeBytes(OutputStream dos, byte[] b, int off, int len) throws IOException {
        $(AMQPTransport:).writeBytes(dos, b, off, len);
    } 
    
    static long u(int value) {
        return $(AMQPTransport:).u(value);
    }
    
    static int s(long value) {
        return $(AMQPTransport:).s(value);
    }
    
    static int u(short value) {
        return $(AMQPTransport:).u(value);
    }
    
    static short s(int value) {
        return $(AMQPTransport:).s(value);
    }
    
    static short u(byte value) {
        return $(AMQPTransport:).u(value);
    }
    
    static byte s(short value) {
        return $(AMQPTransport:).s(value);
    }"
error_handling ="
    // Error facilities from $(AMQPFramingFactory)
    static void warning(String _class, String method, String message) {
        $(AMQPTransport:).warning(_class, method, message); 
    }
    
    static void exception(Exception e, String _class, String method, String message) throws $(AMQPException:) {
        $(AMQPTransport:).exception(e, _class, method, message); 
    }
    
    static void runtimeException(Exception e, String _class, String method, String message) throws RuntimeException {
        $(AMQPTransport:).runtimeException(e, _class, method, message); 
    }"
imatix_openamq_dir = "com/imatix/openamq"
imatix_openamq_package = string.replace(imatix_openamq_dir, "/|.")
imatix_openamq_frames_dir = imatix_openamq_dir + "/frames"
imatix_openamq_frames_package = string.replace(imatix_openamq_frames_dir, "/|.")
imatix_openamq_transport_dir = imatix_openamq_dir + "/transport"
imatix_openamq_transport_package = string.replace(imatix_openamq_transport_dir, "/|.")
type_type_last = undefined ? 
type_type = undefined ?
set_type = undefined ? 

#  ------------------------------   Functions  --------------------------------

function abort_xml_error ()
    abort xml.error
endfunction

#  ------------------------------   Name style --------------------------------

function c2java_class (name)
    return string.replace("$(my.name: Neat)", "_|")
endfunction

function c2java_name (name)
    my.name = string.replace("$(my.name: Neat)", "_|")
    my.name = "$(string.substr(my.name, 0, , 1):lower)" + "$(string.substr(my.name, 1, , ):)"
    return my.name
endfunction

#  ------------------------------   Class hierarchy ---------------------------

function generate_directories ()
-   Java API for Imatix's openamq project in here
    directory.create (imatix_openamq_dir)
-   Framing / Deframing code in here
    directory.create (imatix_openamq_frames_dir)
-   Transport code in here
    directory.create (imatix_openamq_transport_dir)
endfunction

#  ------------------------------   Helper functions -------------------------

function get_type_type()
    for field
        if (name = "type")
            if    type = "char"
                my.type = "char"
            elsif type = "bit"
                my.type = "boolean"
            elsif type = "octet"
                my.type = "short"
            elsif type = "shortint"
                my.type = "int"
            elsif type = "longint"
                my.type = "long"
            elsif type = "shortstr"
                my.type = "String"
            elsif type = "longstr" | type = "table"
                my.type = "byte[]"
            endif
        endif
    endfor
    return my.type
endfunction

function get_type_value()
    for field
        if (name = "type")
            my.value = value
        endif
    endfor
    return my.value
endfunction

function parse_frames (frames)
    name   = "$(name:c)"
    prefix = "$(prefix:c)"
    for . where name() = "frame"
        if name = "frame"
            abort "'frame' is a reserved name, please change this"
        endif
        name = "$(name:c)"
        for field
            name = "$(c2java_name("$(name:c)"))"
        endfor
    endfor
endfunction

function build_frame_lists (frames, outertype, code)
 scope my.frames
   my.count = 0
   for frame where string.prefixed(name, my.outertype)
        my.frame_name = name
        my.current_inner = "$(string.substr (my.frame_name, string.length(my.outertype) + 1, , ))"
-       The receive message exception        
        if (my.code = 3)
            for field 
                my.count += 1
                if (my.count > 1)
                    echo ("java/$(script:): build_frame_lists: FATAL, code = 3 unexpected exception.")
                endif
                >        return new $(my.current_inner: Neat)(dis);
                last
            endfor
-       The construct message exception        
        elsif (my.code = 5)
            for field 
                my.count += 1
                if (my.count > 1)
                    echo ("java/$(script:): build_frame_lists: FATAL, code = 5 unexpected exception.")
                endif
                >        return new $(my.current_inner: Neat)();
                last
            endfor
        else
            if (my.code = 1)
                my.type = get_type_type() ?
                if (my.count = 0 & defined (my.type))
                    >    // Frame-types
                    my.count = 1
                endif
            endif
            for field where name = "type"
-               Constants
                if (my.code = 1)
                    >    public final static $(my.type:) 
                    >        $(my.current_inner: UPPER) = $(value:);  /* $(my.current_inner: Neat) type   */
-               The frame receive cases
                elsif (my.code = 2)
                    >            case $(my.current_inner: UPPER): 
                    >                return new $(my.current_inner: Neat)(dis);
                elsif (my.code = 4)
                    >            case $(my.current_inner: UPPER): 
                    >                return new $(my.current_inner: Neat)();
                endif
            endfor
        endif
    endfor
 endscope
endfunction

function build_if_lists (frames, outertype, AMQPFramingFactory, code)
 scope my.frames
    if (my.code = 1)      
        my.action = "receive"
        my.extra_indent = ""        
    elsif (my.code = 2)      
        my.action = "construct"
        my.extra_indent = ""        
    endif        
    my.indent = ""        
    for frame
-      The function get_type_value is added just to allow the triggering of the empty value 
        type_value = "type " + get_type_value() ?
        my.new_outertype = string.prefix (name, "_")
        if (!defined(my.outertype) | my.new_outertype <> my.outertype)
            my.outertype = my.new_outertype
            if (defined (type_value))
                my.indent += "    "  
                if (my.code = 1)
                    >    $(my.extra_indent)$(my.indent)if ((frame = $(my.outertype: lower).$(my.action)Frame($(string.prefix(type_value, " "):), incoming())) == null)
                elsif (my.code = 2)
                    >    $(my.extra_indent)$(my.indent)if ((frame = $(my.outertype: lower).$(my.action)Frame($(string.prefix(type_value, " "):))) == null)
                endif
            endif
        endif
    endfor
    my.indent += "    "  
    if (my.code = 1)
    >    $(my.extra_indent)$(my.indent)exception(null, "$(AMQPFramingFactory:)", "$(my.action)Frame", "unrecognized frame");
    elsif (my.code = 2)
    >    $(my.extra_indent)$(my.indent)runtimeException(null, "$(AMQPFramingFactory:)", "$(my.action)Frame", "unrecognized frame");
    endif
 endscope
endfunction

function build_variables (frame, do_type)
    for field
        if    type = "char"
            my.type = "char"
        elsif type = "bit"
            my.type = "boolean"
        elsif type = "octet"
            my.type = "short"
        elsif type = "shortint"
            my.type = "int"
        elsif type = "longint"
            my.type = "long"
        elsif type = "shortstr"
            my.type = "String"
        elsif type = "longstr" | type = "table"
            my.type = "byte[]"
        endif
        if ((name = "type") & my.do_type)
            >    short
            >        $(name:) = -1;                       /*  $(.?:)                           */
        elsif ((name <> "type") & !my.do_type)
            >        public $(my.type:)
            >            $(name:);                            /*  $(.?:)                           */
        endif
    endfor
endfunction

function build_decoding (frame, is, inner)
    my.bit_count = 0
    for field
        if    type <> "bit" & my.bit_count > 0
-           Prepare for new bitfield
            my.bit_count = 0
        endif
        if (name <> "type") 
            if    type = "char"
                >                    $(name:) = (char)u($(my.is).readByte());
            elsif type = "bit"
                if (my.bit_count = 0)
-                   Read the bitfield 
                    >                    byte flags = $(my.is).readByte();
                endif
                >                    $(name:) = (flags & (1 << $(my.bit_count))) > 0;
                my.bit_count += 1
            elsif type = "octet"
                >                    $(name:) = u($(my.is).readByte());
            elsif type = "shortint"
                >                    $(name:) = u($(my.is).readShort());
            elsif type = "longint"
                >                    $(name:) = u($(my.is).readInt());
            elsif type = "shortstr"
                >                    {byte[] bytes = new byte[u($(my.is).readByte())];
                >                     readBytes($(my.is), bytes, 0, bytes.length);
                >                     $(name:) = bytes2String(bytes);}
            elsif type = "longstr" | type = "table"
                >                    $(name:) = new byte[u($(my.is).readShort())];
                >                    readBytes($(my.is), $(name:), 0, $(name:).length);
            endif
        endif
    endfor
endfunction

function build_encoding (frame, os)
    my.bit_count = 0
    for field
        if    type <> "bit" & my.bit_count > 0
-           Write the bitfield 
            >                    $(my.os).writeByte(flags);
-           Prepare for new bitfield
            my.bit_count = 0
        endif
        if    type = "char"
            >                    $(my.os).writeByte(s((short)$(name:)));
        elsif type = "bit"
-           Compose the bitfield
            if (my.bit_count = 0)
                >                    byte flags = 0;
            endif
            >                    if ($(name:))
            >                        flags |= 1 << $(my.bit_count);        
            my.bit_count += 1
        elsif type = "octet"
            >                    $(my.os).writeByte(s($(name:)));
        elsif type = "shortint"
            >                    $(my.os).writeShort(s($(name:)));
        elsif type = "longint"
            >                    $(my.os).writeInt(s($(name:)));
        elsif type = "shortstr"
            >                    if ($(name:) != null) {
            >                        {byte[] bytes = string2Bytes($(name:));
            >                         $(my.os).writeByte(s((short)bytes.length));
            >                         writeBytes($(my.os), bytes, 0, bytes.length);}
            >                    } else {
            >                        $(my.os).writeByte(0);
            >                    }
        elsif type = "longstr" | type = "table"
            >                    if ($(name:) != null) {
            >                        $(my.os).writeShort(s((int)$(name:).length));
            >                        writeBytes($(my.os), $(name:), 0, $(name:).length);
            >                    } else {
            >                        $(my.os).writeShort(0);
            >                    }
        endif
    endfor
    if    my.bit_count > 0
-       Write the bitfield 
        >                    $(my.os).writeByte(flags);
    endif
endfunction

function build_size (frame) 
    my.bit_count = 0
    for field
        if    type <> "bit" & my.bit_count > 0
-           Prepare for new bitfield
            my.bit_count = 0
        endif
        if    type = "char"
            >            // char
            >            size += 1;
        elsif type = "bit"
            if (my.bit_count = 0)
                >            // bits
                >            size += 1;
            endif    
            my.bit_count += 1
        elsif type = "octet"
            >            // octet
            >            size += 1;
        elsif type = "shortint"
            >            // shortint
            >            size += 2;
        elsif type = "longint"
            >            // longint
            >            size += 4;
        elsif type = "shortstr"
            >            // shortstr
            >            size += 1;
            >            if ($(name:) != null) 
            >                size += string2Bytes($(name:)).length;
        elsif type = "longstr" | type = "table"
            >            // table (longstr)
            >            size += 2;
            >            if ($(name:) != null) 
            >                size += $(name:).length;
        endif
    endfor
endfunction  
  
function build_copy (frame) 
    for field
       if (name <> "type") 
           >            this.$(name:) = that.$(name:);
       endif    
    endfor
endfunction    

function build_dumping (frame, os)
    >            $(my.os:).print("I:");
    for field
        if    type = "char"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "bit"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "octet"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "shortint"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "longint"
            >            $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "shortstr"
            >            if ($(name:) != null) 
            >                $(my.os:).print(" $(name:) = " + $(name:));
        elsif type = "longstr" | type = "table"
            >            $(my.os:).print(" $(name:) = ");
            >            if ($(name:) != null) 
            >                $(my.os:).print(hexDump($(name:)));
        endif
    endfor
    >            $(my.os:).println("");
endfunction

function build_framing (class, inner, AMQPException)
    my.full_name = "$(my.class + "." + my.inner:)"
    my.full_name_comments = "$(my.class + " " + my.inner: lower)"
-   Constructors        
    >        /**
    >         *
    >         * Default constructor for $(my.full_name:)
    >         *
    >         **/
    >        public $(my.inner:)() {$(set_type?:)}
    >
    >        /**
    >         *
    >         * Decoder constructor for $(my.full_name:)
    >         *
    >         **/
    >        public $(my.inner:)(DataInputStream dis) throws $(AMQPException:) {
    >            super(dis);
    >            $(set_type?:);
    >        }
    >
-   Deframing        
    >        /**
    >         *
    >         * Frame decoder for $(my.full_name_comments:) frames
    >         *
    >         **/
    >        public void decode(DataInputStream dis) throws $(AMQPException:) {
    >            // DataInputStream implementations are synchronized, we do not want to ask for the lock
    >            //    each time a field is processed.
    >            synchronized (dis) {
    >                try {
    build_decoding (., "dis", my.inner)
    if (defined(set_type))
    >                    byte ce = dis.readByte();
    >                    if (ce != AMQP_COMMAND_END) 
    >                        exception(null, "$(my.full_name:)", "decode", "frame command-end expected but got " + ce);
    endif
    >                } catch (IOException e) {
    >                    exception(e, "$(my.full_name:)", "decode", "cannot decode");
    >                }
    >            }
    >        }
    >
-   Framing        
    >        /**
    >         *
    >         * Frame encoder for $(my.full_name_comments:) frames
    >         *
    >         **/
    >        public long encode(DataOutputStream dos) {
    >            // DataInputStream implementations are synchronized, we do not want to ask for the lock
    >            //    each time a field is processed.
    >            synchronized (dos) {
    >                try {
    build_encoding (., "dos")
    if (defined(set_type))
    >                    dos.writeByte(AMQP_COMMAND_END);
    endif
    >                    return size();
    >                } catch (IOException e) {
    >                    runtimeException(e, "$(my.full_name:)", "encode", "cannot encode");
    >                    return -1;
    >                }
    >            }
    >        }
    >
-   Size
    >        /**
    >         *
    >         * Return frame size for $(my.full_name_comments:) frames
    >         *
    >         **/
    >        public long size() {
    >           long
    >               size = 0;
    >
    build_size (.)
    if (defined(set_type))
    >           // Command end
    >           size++;
    endif
    >
    >           return size;
    >        }
    >
-   Cloning
    >        /**
    >         *
    >         * Shallow copy from another $(my.full_name_comments:) frame
    >         *
    >         **/
    >        public void cloneFrom($(my.inner:) that) {
    build_copy (.)
    >        }
    >
-   Dumping
    >        /**
    >         *
    >         * Frame dumper for $(my.full_name_comments:) frames
    >         *
    >         **/
    >        public void dump() {
    build_dumping (., "System.out")
    >        }
endfunction

#  ------------------------------   Output macro -----------------------------

.macro generate_frames (frames)
. scope my.frames
.-///////////////////////////   F R A M E S   ///////////////////////////////////
.-  Set the frames output directory
.   directory.setcwd(imatix_openamq_frames_dir)
.-  outertype refers to one of connection, channel, handle or message
.-  Iterate through frames and generate .java files for outertypes (realted types must be together)
.   for frame
.-      Set some frame type variables
.       type_type = get_type_type() + " type" ?
.       type_type_comma = type_type + ", " ?
.       if (defined (type_type))
.           type_type_last = type_type
.       endif
.-      This takes the beginnings of frame names to generate new files
.       my.new_outertype = string.prefix (name, "_")
.       if (!defined (my.outertype))
.           my.outertype = my.new_outertype
.           my.outertype_break = 1
.       elsif (my.new_outertype <> my.outertype)
.           my.outertype = my.new_outertype
.           my.outertype_break = 2
.       else
.           my.outertype_break = 0
.       endif
.-      Write file headers only for new outertypes (connection, channel, handle, message)
.       if (my.outertype_break > 0)
.-          Close current class
.           if (my.outertype_break > 1)
$(utilities:)    
$(error_handling:)    
}
. close
.           endif
.-          The message type is not formally a frame type 
.           my.first_inner = string.substr (name, string.length(my.outertype) + 1, , )
.-          Command frames
.           if (defined (type_type))
.               my.frame_super = AMQPFrame
.-          The message head
.           else
.               my.frame_super = "$(my.first_inner : Neat)"
.           endif
.echo "Generating $(class_prefix:)$(my.outertype: Neat).java..."
. output "$(class_prefix:)$(my.outertype: Neat).java"
/**
 *  $(class_prefix:)$(my.outertype: Neat).java - AMQP $(my.outertype) frames.
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package:);

import java.io.InputStream;
import java.io.OutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import $(imatix_openamq_transport_package:).$(AMQPTransport:);
import $(imatix_openamq_package:).$(AMQPException:);
 
public class $(class_prefix:)$(my.outertype: Neat) {
    // Constants
    final static byte 
        AMQP_COMMAND_END = (byte)0xCE;           /* Frame last byte                  */
.           build_frame_lists (my.frames, my.outertype, 1)   
    
    /**
     *
     * $(my.outertype: Neat) default constructor
     *
     **/
    public $(class_prefix:)$(my.outertype: Neat)() {
    } 
    
    /**
     *
     * $(my.outertype: Neat) frame receiver
     *
     **/
    public $(my.frame_super:) receiveFrame($(type_type_comma ? "":)DataInputStream dis) throws $(AMQPException:) {
.-          Not for message
.           if (defined (type_type))    
        switch (type) {
.       build_frame_lists (my.frames, my.outertype, 2)               
        }
        return null;
.           else           
.-          The message case
.       build_frame_lists (my.frames, my.outertype, 3)               
.           endif           
    } 
    
    /**
     *
     * $(my.outertype: Neat) frame constructor
     *
     **/
.-          Not for message
.           if (defined (type_type))    
    public $(my.frame_super:) constructFrame($(type_type ? "":)) throws $(AMQPException:) {
        switch (type) {
.       build_frame_lists (my.frames, my.outertype, 4)               
        }
        return null;
.           else        
.-          The message case
    public $(my.frame_super:) constructFrame($(type_type ? "":)) {
.       build_frame_lists (my.frames, my.outertype, 5)               
.           endif           
    } 

.-          Command frames
.           if (defined (type_type))
    /**
     *
     * $(my.outertype: Neat) frames superclass
     *
     **/
    abstract class Frame extends $(AMQPFrame:) {
        /**
         *
         * Default constructor
         *
         **/
        public Frame() {super();}
    
        /**
         *
         * Decoder constructor
         *
         **/
        public Frame(DataInputStream dis) throws $(AMQPException:) {
            super(dis);
        }
    }
.           endif    
.-      Finished with outertype methods
.       endif
.-  Write the frame types for this outertype
.       my.current_inner = string.substr (name, string.length(my.outertype) + 1, , )
.-      Command frames
.       if (defined (type_type))
.           set_type = "type = $(my.current_inner: UPPER);" ?
.-      The message head
.       else
.           set_type = undefined ?
.       endif

    /**
     *
     * $(my.current_inner: Neat) frame
     *
     **/
.-      Command frames
.       if (defined (type_type))
    public class $(my.current_inner: Neat) extends Frame {
.-      The message head
.       else
    public class $(my.current_inner: Neat) extends $(AMQPFramable:) {
.       endif
.       build_variables (., 0)

.       build_framing ("$(my.outertype: Neat)", "$(my.current_inner: Neat)", AMQPException) 
    }    
.-  Finished with last class body
.   endfor
$(utilities:)    
$(error_handling:)    
}

.-  Close last class
. close
.- Frames and message header super class (AMQP network-serializable objects)
.echo "Generating $(AMQPFramable:).java..."
. output "$(AMQPFramable:).java"
/**
 *  $(AMQPFramable:).java - Super class for network-serializable objects.
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package:);

import java.io.DataInputStream;
import java.io.DataOutputStream;
import $(imatix_openamq_package:).$(AMQPException:);

public abstract class $(AMQPFramable:) {

    /**
     *
     * Default constructor
     *
     **/
    public $(AMQPFramable:)() {
    }
    
    /**
     *
     * Decoder constructor
     *
     **/
    public $(AMQPFramable:)(DataInputStream dis) throws $(AMQPException:) {
        decode(dis);
    }
    
    /**
     *
     * Encoder method
     *
     **/
    abstract public long encode(DataOutputStream os);
    
    /**
     *
     * Decoder method
     *
     **/
    abstract public void decode(DataInputStream dis) throws $(AMQPException);
    
    /**
     *
     * Frame size method
     *
     **/
    abstract public long size();
    
    /**
     *
     * Frame dumping method
     *
     **/
    abstract public void dump();
}

. close
.- Regular frames super class (to follow a frame header generated by the AMQPFactory)
.echo "Generating $(AMQPFrame:).java..."
. output "$(AMQPFrame:).java"
/**
 *  $(AMQPFrame:).java - Regular frames super class.
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package:);

import java.io.DataInputStream;
import $(imatix_openamq_package:).$(AMQPException:);

public abstract class $(AMQPFrame:) extends $(AMQPFramable:) {
.   for frame
.       build_variables (., 1)
.       last
.   endfor

    /**
     *
     * Default constructor
     *
     **/
    public $(AMQPFrame:)() {
        type = -1;
    }
    
    /**
     *
     * Decoder constructor
     *
     **/
    public $(AMQPFrame:)(DataInputStream dis) throws $(AMQPException:) {
        decode(dis);
    }
    
}

. close
.- Contains name/value pairs in a hashtable
.echo "Generating $(AMQPFieldTable:).java..."
. output "$(AMQPFieldTable:).java"
/**
 *  $(AMQPFieldTable:).java - Hashtable subclass for handling field tables
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package:);

import java.io.InputStream;
import java.io.OutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Hashtable;
import java.util.Date;
import java.util.Enumeration;
import $(imatix_openamq_frames_package:).$(FrugalByteArrayOutputStream:);
import $(imatix_openamq_transport_package:).$(AMQPTransport:);
import $(imatix_openamq_package:).$(AMQPException:);

public class $(AMQPFieldTable:) extends Hashtable {
    /**
     *
     * Default constructor
     *
     **/
    public $(AMQPFieldTable:)() {
    }
    
    /**
     *
     * Bucket constructor
     *
     **/
    public $(AMQPFieldTable:)(byte[] bucket) throws $(AMQPException) {
        loadFromBucket(bucket);
    }
    
    /**
     *
     * Load name/value pairs from a bucket
     *
     **/
    public void loadFromBucket(byte[] bucket) throws $(AMQPException) {
        try {
            DataInputStream 
                dis = new DataInputStream(new ByteArrayInputStream(bucket));
            
            while (dis.available() > 0) {
                Object prev = null;
                String name = readName(dis);
                char type = readChar(dis);
                
                switch (type) {
                    case 'S': // Field string
                        prev = putString(name, readString(dis));
                        break;
                    case 'I': // Field integer
                        prev = putInteger(name, readInteger(dis));
                        break;
                    case 'D': // Field decimal
                        prev = putDecimal(name, readDecimal(dis));
                        break;
                    case 'T': // Field date/time
                        prev = putDateTime(name, readInteger(dis));
                        break;
                    default:
                        exception(null, "$(AMQPFieldTable:)", "loadFromBucket", "unrecognized field table type");
                }
                if (prev != null) {
                    // Keep the first value 
                    put(name, prev);
                    warning("$(AMQPFieldTable:)", "loadFromBucket", "field redefined");
                }    
            }
        } catch (IOException e) {
            exception(e, "$(AMQPFieldTable:)", "loadFromBucket", "unable to load from bucket");
        }
    }
    
    /**
     *
     * Write name/value pairs to a bucket
     *
     **/
    public byte[] storeToBucket() {
        return storeToBucket(null);
    }
    
    /**
     *
     * Write name/value pairs to a bucket (pass bucket)
     *
     **/
    public byte[] storeToBucket(byte[] bucket) {
        try {
            FrugalByteArrayOutputStream
                fbaos = null;
            ByteArrayOutputStream
                baos = null;
            DataOutputStream
                dos;
            Enumeration
                keys = keys();
            byte[]
                result;
            
            if (bucket != null) {
                fbaos = new FrugalByteArrayOutputStream(bucket);                    
                dos = new DataOutputStream(fbaos);
            } else {
                baos = new ByteArrayOutputStream();                    
                dos = new DataOutputStream(baos);
            }
                
            while (keys.hasMoreElements()) {
                String name = (String)keys.nextElement();
                Object value = get(name);
                
                writeName(dos, name);
                if (value instanceof byte[]) {
                    // Field string
                    writeChar(dos, 'S');
                    writeString(dos, (byte[])value);
                } else if (value instanceof Long) {
                    // Field integer
                    writeChar(dos, 'I');
                    writeInteger(dos, ((Long)value).longValue());
                } else if (value instanceof long[]) {
                    // Field decimal
                    writeChar(dos, 'D');
                    writeDecimal(dos, (long[])value);
                } else if (value instanceof Date) {
                    // Field date/time
                    writeChar(dos, 'T');
                    writeInteger(dos, ((Date)value).getTime());
                }    
            } 
            
            if (bucket != null) 
                result = fbaos.toByteArray();
            else    
                result = baos.toByteArray();

            return result;            
        } catch (IOException e) {
            runtimeException(e, "$(AMQPFieldTable:)", "storeToBucket", "unable to write to bucket");
            return null;
        }
    }
    
    // Get/Put functions
    
    /**
     *
     * Get a string value
     *
     **/
    public byte[] getString(String name) {
        return (byte[])get(name);
    }
    
    /**
     *
     * Put a string value
     *
     **/
    public Object putString(String name, byte[] value) {
        return put(name, value);
    }
    
    /**
     *
     * Get an integer value
     *
     **/
    public long getInteger(String name) {
        return ((Long)get(name)).longValue();
    }
    
    /**
     *
     * Put an integer value
     *
     **/
    public Object putInteger(String name, long value) {
        return put(name, new Long(value));
    }
    
    /**
     *
     * Get a decimal value
     *
     **/
    public long[] getDecimal(String name) {
        return (long[])get(name);
    }
    
    /**
     *
     * Put a decimal value
     *
     **/
    public Object putDecimal(String name, long[] value) {
        return put(name, new long[]{value[0], value[1]});
    }
    
    /**
     *
     * Get a date/time value
     *
     **/
    public long getDateTime(String name) {
        return ((Date)get(name)).getTime() / 1000;
    }
    
    /**
     *
     * Put a date/time value
     *
     **/
    public Object putDateTime(String name, long value) {
        return put(name, new Date(value * 1000));
    }

    // Read/write functions    
    
    /**
     *
     * Read a field name
     *
     **/
    static String readName(DataInputStream dis) throws IOException {
        byte[] bytes = new byte[u(dis.readByte())];
        
        readBytes(dis, bytes, 0, bytes.length);
        
        return bytes2String(bytes);
    }
    
    /**
     *
     * Write a field name
     *
     **/
    static void writeName(DataOutputStream dos, String name) throws IOException {
        byte[] bytes = string2Bytes(name);
        
        dos.writeByte(s((short)bytes.length));
        writeBytes(dos, bytes, 0, bytes.length);
    }
    
    /**
     *
     * Read string field data
     *
     **/
    static byte[] readString(DataInputStream dis) throws IOException  {
        byte[] bytes = new byte[u(dis.readShort())];
        
        readBytes(dis, bytes, 0, bytes.length);
        
        return bytes;
    }
    
    /**
     *
     * Write string field data
     *
     **/
    static void writeString(DataOutputStream dos, byte[] bytes) throws IOException {
        dos.writeShort(s((int)bytes.length));
        writeBytes(dos, bytes, 0, bytes.length);
    }
    
    /**
     *
     * Read an integer field value
     *
     **/
    static long readInteger(DataInputStream dis) throws IOException  {
        return u(dis.readInt());
    }
    
    /**
     *
     * Write an integer field value
     *
     **/
    static void writeInteger(DataOutputStream dos, long aLong) throws IOException  {
        dos.writeInt(s(aLong));
    }
    
    /**
     *
     * Read decimal field value
     *
     **/
    static long[] readDecimal(DataInputStream dis) throws IOException  {
       long decimals = readByte(dis);
       long integer = readInteger(dis);
       
       return new long[] {decimals, integer};
    }
    
    /**
     *
     * Write decimal field value
     *
     **/
    static void writeDecimal(DataOutputStream dos, long[] decimal) throws IOException  {
        writeByte(dos, (short)decimal[0]);
        writeInteger(dos, decimal[1]);
    }
    
    /**
     *
     * Read field type specification
     *
     **/
    char readChar(DataInputStream dis) throws IOException {
        return (char)u(dis.readByte());
    }
    
    /**
     *
     * Write field type specification
     *
     **/
    void writeChar(DataOutputStream dos, char type) throws IOException {
        dos.writeByte(s((short)type));
    }
    
    /**
     *
     * Read a byte value
     *
     **/
    static short readByte(DataInputStream dis) throws IOException  {
        return u(dis.readByte());
    }
    
    /**
     *
     * Write a byte value
     *
     **/
    static void writeByte(DataOutputStream dos, short aByte) throws IOException  {
        dos.writeByte(s(aByte));
    }
    $(utilities:)    
    $(error_handling:)  
}

. close
.- Frugal replacement for ByteArrayOutputStream
.echo "Generating $(FrugalByteArrayOutputStream:).java..."
. output "$(FrugalByteArrayOutputStream:).java"
/**
 *  $(FrugalByteArrayOutputStream:).java - Frugal replacement for ByteArrayOutputStream.
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_frames_package:);

import java.io.OutputStream;
import java.io.IOException;
import $(imatix_openamq_transport_package:).$(AMQPTransport:);
import $(imatix_openamq_package:).$(AMQPException:);

public class $(FrugalByteArrayOutputStream:) extends OutputStream {
    byte[] bytes;
    
    int count;
    
    public $(FrugalByteArrayOutputStream:)(byte[] bytes) {
        this.bytes = bytes;
        reset();
    }
    
    public synchronized void reset() {
        count = 0;
    }
    
    public int size() {
        return count;
    }
    
    public byte[] toByteArray() {
        return bytes;
    }
    
    public final void write(int aByte) {
        if (this.bytes.length - count >= 1) 
            bytes[count++] = (byte)aByte;
        else 
            runtimeException(null, "$(FrugalByteArrayOutputStream:)", "write(int)", "overflow");
    }
    
    public void write(byte[] bytes, int off, int len) {
        if (this.bytes.length - count >= len) {
            System.arraycopy(bytes, off, this.bytes, count, len);
            count += len;
        } else {
            runtimeException(null, "$(FrugalByteArrayOutputStream:)", "write(byte[], int, int)", "overflow");
        }
    }
    
    public void writeTo(OutputStream out) throws IOException {
        out.write(bytes, 0, count);
    }
    $(error_handling:)    
}

. close
.-///////////////////////////   T R A N S P O R T ///////////////////////////////
.-  Set the transport output directory
.   directory.setcwd("../../../..")
.   directory.setcwd(imatix_openamq_transport_dir)
.- Handles low-evel connection issues
.echo "Generating $(AMQPTransport:).java..."
. output "$(AMQPTransport:).java"
/**
 *  $(AMQPTransport:).java - Handles low-evel connection issues.
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_transport_package:);

import java.io.InputStream;
import java.io.OutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import $(imatix_openamq_frames_package:).$(AMQPFramable:);
import $(imatix_openamq_package:).$(AMQPIOException:);
import $(imatix_openamq_package:).$(AMQPException:);

public class $(AMQPTransport:) {
    // Constants
    public final static String 
        VERSION = "OpenAMQ Java/0.5a2";                    /* API version                      */
    final static String 
        STRING_ENC = "UTF-8";                              /* Prefered string encoding         */
    final static int 
        WRITE_IDLE = -1,                                   /* Writer thread is idle            */
        WRITE_FLUSH = 0,                                   /* Writer thread flush request      */
        WRITE_BYTES = 1,                                   /* Writer thread write request      */
        WRITE_FRAMABLE = 2;                                /* Writer thread write request      */
    
    // Network streams    
    DataInputStream 
        incoming;                                          /* Incoming stream                  */
    DataOutputStream 
        outgoing;                                          /* Outgoing stream                  */
    // Read retry latency    
    static int     
        readRetryLatency = 100;                            /* Wait this before retrying (ms)   */
    // Write command
    int 
        writeCommand = -1,                                 /* Writer thread request            */
        writeOff,                                          /* Write offset parameter           */
        writeLen,                                          /* Writer length parameter          */
        timeout = 0;                                       /* Writer timeout (0 ms == block)   */
    $(AMQPFramable:)
        writeFramable;                                     /* Writer frame to serialize        */
    byte[] 
        writeBytes,                                        /* Writer data command data array   */
        uBuff = new byte[4],                               /* Buffer for unsigned integers     */
        uwBuff = new byte[4];                              /* Buffer for unsigned integers     */
    int    
        priority = Thread.currentThread().getPriority();   /* Main thread priority             */
    OutputStream 
        writeOs;                                           /* Writer data os target            */
    IOException 
        ioe = null;                                        /* Writer thread exception          */
    // This thread buffers and flushes outgoing data
    Thread 
        writer = new Thread() {                            /* Writer thread                    */
            public void run() {
                // Some VMs lower too much the priority of threads spawned from main
                setPriority(priority + 1);
                synchronized(outgoing) {
                    while (outgoing != null) {
                        // Wait for write command
                        synchronized(writer) {
                            while (writeCommand == WRITE_IDLE) {
                                try {
                                    writer.notify();
                                    writer.wait();
                                } catch (InterruptedException e) {}
                            }
                        }
                        // Perform write command
                        try {
                            writeOs = (writeOs == null) ? outgoing : writeOs;
                            switch (writeCommand) {
                                case WRITE_FRAMABLE:
                                    writeFramable.encode((DataOutputStream)writeOs);
                                    break;
                                case WRITE_BYTES:
                                    writeBytes(writeOs, writeBytes, writeOff, writeLen);
                                    break;
                                case WRITE_FLUSH:
                                    writeOs.flush();
                            }
                            writeOs = null;
                        } catch (IOException e) {
                            synchronized(writer) {
                                ioe = e;
                            }
                        }
                        // Finished write command
                        synchronized(writer) {
                            writeCommand = WRITE_IDLE;
                            writer.notify();
                        }
                    }
                }
            }
        };
        
    /**
     *
     * $(AMQPTransport:) constructor
     *
     **/
    public $(AMQPTransport:)(InputStream is, OutputStream os) throws IOException {
        incoming = new DataInputStream(new BufferedInputStream(is));
        outgoing = new DataOutputStream(new BufferedOutputStream(os));
        // Start the writer thread
        writer.start();
    } 

    /**
     *
     * $(AMQPTransport:) configurable buffer constructor
     *
     **/
    public $(AMQPTransport:)(InputStream is, OutputStream os, int readBuff, int writeBuff) throws IOException {
        incoming = new DataInputStream(new BufferedInputStream(is, readBuff));
        outgoing = new DataOutputStream(new BufferedOutputStream(os, writeBuff));
        // Start the writer thread
        writer.start();
    } 
    
    /**
     *
     * Set incoming retry latency
     *
     **/
    public void setIncomingRetryLatency(int latency) {
        readRetryLatency = latency;
    }
    
    /**
     *
     * Set outgoing timeout
     *
     **/
    public void setOutgoingTimeout(int timeout) {
        this.timeout = timeout;
    }
    
    /**
     *
     * Send the protocol ID and version (to the server)
     *
     **/
    public void sendConnectionInitiation(short id, short version) throws $(AMQPException:) {
        try {
            // Send initiation
            writeUnsignedByte(id);
            writeUnsignedByte(version);
            flush(outgoing);
        } catch (IOException e) {
            exception(e, "$(AMQPTransport:)", "sendConnectionInitiation", "unable to connect");
        }
    }
    
    /**
     *
     * Get the incoming stream
     *
     **/
    public DataInputStream incoming() {
        return incoming;
    }
    
    /**
     *
     * Get the outgoing stream
     *
     **/
    public DataOutputStream outgoing() {
        return outgoing;
    }
    
    // Unsigned reading/writing
    
    /**
     *
     * Unsigned int reader
     *
     **/
    public long readUnsignedInt() throws IOException {
        receiveData(uBuff, 0, 4);
        return u(((uBuff[0] & 0xff) << 24) | ((uBuff[1] & 0xff) << 16) | ((uBuff[2] & 0xff) << 8) | (uBuff[3] & 0xff));
    }
    
    /**
     *
     * Unsigned int writer
     *
     **/
    public void writeUnsignedInt(long value) throws IOException {
        int 
            sv = s(value);
            
        synchronized (writer) {
            checkWrite();
            uwBuff[0] = (byte)(0xff & (sv >> 24));
            uwBuff[1] = (byte)(0xff & (sv >> 16));
            uwBuff[2] = (byte)(0xff & (sv >> 8));
            uwBuff[3] = (byte)(0xff & sv);            
            sendData(uwBuff, 0, 4);
        }
    }

    /**
     *
     * Unsigned short reader
     *
     **/
    public int readUnsignedShort() throws IOException {
        receiveData(uBuff, 0, 2);
        return u((short)(((uBuff[0] & 0xff) << 8) | (uBuff[1] & 0xff)));
    }
    
    /**
     *
     * Unsigned short writer
     *
     **/
    public void writeUnsignedShort(int value) throws IOException {
        short 
            sv = s(value);
            
        synchronized (writer) {
            checkWrite();
            uwBuff[0] = (byte)(0xff & (sv >> 8));
            uwBuff[1] = (byte)(0xff & sv);            
            sendData(uwBuff, 0, 2);
        }
    }
    
    /**
     *
     * Unsigned byte reader
     *
     **/
    public short readUnsignedByte() throws IOException {
        receiveData(uBuff, 0, 1);
        return u(uBuff[0]);
    }
    
    /**
     *
     * Unsigned byte writer
     *
     **/
    public void writeUnsignedByte(short value) throws IOException {
        synchronized (writer) {
            checkWrite();
            uwBuff[0] = s(value);
            sendData(uwBuff, 0, 1);
        }
    }
    
    // Short/long string encoding/decoding
    
    /**
     *
     * Byte array to string translation
     *
     **/
    public static String bytes2String(byte[] bytes) {
        try {
            return new String(bytes, STRING_ENC);
        } catch (UnsupportedEncodingException e) {
            runtimeException(e, "$(AMQPTransport:)", "bytes2String", "UnsupportedEncodingException");
            return null;
        }
    }
     
    /**
     *
     * String to byte array translation
     *
     **/
    public static byte[] string2Bytes(String string) {
        try {
            return string.getBytes(STRING_ENC);
        } catch (UnsupportedEncodingException e) {
            runtimeException(e, "$(AMQPTransport:)", "string2Bytes", "UnsupportedEncodingException");
            return null;
        }
    }
    
    // Byte array conversion
    
    /**
     *
     * Return the hexadecimal representation of an array
     *
     **/
    public static String hexDump(byte[] bytes) {
        return baseDump(bytes, 16, 2);
    }
    
    /**
     *
     * Return the representation of an array in the requested base 
     *
     **/
    static String baseDump(byte[] bytes, int base, int size) {
        final String digits = "0123456789ABCDEF";
        String result = "";
        
        if (base > digits.length())
            runtimeException(null, "$(AMQPTransport:)", "hexdump", "base to high");
        
        for (int i = 0; i < bytes.length; i++) {
            String aByte_str = "";
            short aByte = bytes[i];
            if (aByte < 0)
                aByte = (short)u(aByte); 
            for (int j = 0; j < size; j++) { 
                if (aByte > 0) {
                    aByte_str = digits.charAt(aByte % base) + aByte_str;
                    aByte /= base;
                } else {
                    aByte_str = "0" + aByte_str;
                }
            }
            
            result += aByte_str + " ";    
        }
        
        return result;
    }
    
    // Raw data reading/writing
    
    /**
     *
     * Data receiver method
     *
     **/
    public void receiveData(byte[] bytes) throws IOException {
        receiveData(bytes, 0, bytes.length);
    }
    
    /**
     *
     * Data receiver method (offset and length)
     *
     **/
    public void receiveData(byte[] bytes, int off, int len) throws IOException {
        receiveData(incoming, bytes, off, len);
    }
    
    /**
     *
     * Data receiver method (InputStream, offset and length)
     *
     **/
    public void receiveData(InputStream is, byte[] bytes, int off, int len) throws IOException {
        readBytes(is, bytes, off, len);
    }
    
    /**
     *
     * Data sender
     *
     **/
    public void sendData(byte[] bytes) throws IOException {
        sendData(bytes, 0, bytes.length);
    }
    
    /**
     *
     * Data sender (offset and length)
     *
     **/
    public void sendData(byte[] bytes, int off, int len) throws IOException {
        sendData(outgoing, bytes, off, len);
    }
    
    /**
     *
     * Data sender (OutputStream, offset and length)
     *
     **/
    public void sendData(OutputStream os, byte[] bytes, int off, int len) throws IOException {
        writeTimeout(os, bytes, off, len);
    }
    
    // Signed/unsigned conversion (final to hint optimization to the compiler)
    
    /**
     *
     * Convert to unsigned (int to long)
     *
     **/
    final public static long u(int value) {
        return value & 0xFFFFFFFFl;
    }
    
    /**
     *
     * Check to signed (long to int)
     *
     **/
    final public static int s(long value) {
        checkRange(value);
        return (int)value;
    }
    
    /**
     *
     * Convert to unsigned (short to int)
     *
     **/
    final public static int u(short value) {
        return value & 0xFFFF;
    }
    
    /**
     *
     * Check to signed (int to short)
     *
     **/
    final public static short s(int value) {
        checkRange(value);
        return (short)value;
    }
    
    /**
     *
     * Convert to unsigned (byte to short)
     *
     **/
    final public static short u(byte value) {
        return (short)(value & 0xFF);
    }
    
    /**
     *
     * Check to signed (short to byte)
     *
     **/
    final public static byte s(short value) {
        checkRange(value);
        return (byte)value;
    }
    
    /**
     *
     * Check if the given long can be converted to an unsigned int
     *
     **/
    final static void checkRange(long value) {
        if (value < 0) 
            runtimeException(null, "$(AMQPTransport:)", "checkRange", "unsigned integer underflow (" + value + ")");
    
        if (value > 0xFFFFFFFFl)
            runtimeException(null, "$(AMQPTransport:)", "checkRange", "unsigned integer overflow (" + value + ")");
    }
    
    /**
     *
     * Check if the given int can be converted to an unsigned short
     *
     **/
    final static void checkRange(int value) {
        if (value < 0) 
            runtimeException(null, "$(AMQPTransport:)", "checkRange", "unsigned short underflow (" + value + ")");
    
        if (value > 0xFFFF)
            runtimeException(null, "$(AMQPTransport:)", "checkRange", "unsigned short overflow (" + value + ")");
    }
    
    /**
     *
     * Check if the given short can be converted to an unsigned byte
     *
     **/
    final static void checkRange(short value) {
        if (value < 0) 
            runtimeException(null, "$(AMQPTransport:)", "checkRange", "unsigned byte underflow (" + value + ")");
    
        if (value > 0xFF)
            runtimeException(null, "$(AMQPTransport:)", "checkRange", "unsigned byte overflow (" + value + ")");
    }
    
    // Socket level reading/writing
    
    /**
     *
     * Read bytes until a requested amount of data has arrived
     * Timeout is handled by the socket configuration
     *
     **/
    public static void readBytes(InputStream is, byte[] b, int off, int len) throws IOException {
        try {
            while (len > 0) {
                int read = is.read(b, off, len);
                if (read != -1) {
                    off += read;
                    len -= read;
                    if (len > 0) {
                        try {
                            Thread.sleep(readRetryLatency);
                        } catch (InterruptedException e) {}
                    }
                } else {
                    exception(null, "$(AMQPTransport:)", "readBytes", "end of input stream");
                }
            }
        } catch ($(AMQPException) e) {
            // Encapsulate the exception as $(AMQPIOException)
            throw new $(AMQPIOException)(e.getMessage());
        }
    }
    
    /**
     *
     * Write bytes
     *
     **/
    public static void writeBytes(OutputStream os, byte[] b, int off, int len) throws IOException {
        os.write(b, off, len);
    }
    
    /**
     *
     * Write bytes (timeout, bytes)
     * The read timeout value established on the socket is enforced
     *
     **/
    public void writeTimeout(OutputStream os, byte[] b, int off, int len) throws IOException {
        synchronized(writer) {
            checkWrite();
            // Request write bytes
            writeCommand = WRITE_BYTES;
            writeOs = os;
            writeBytes = b;
            writeOff = off;
            writeLen = len;
            writer.notify();
        }
    }
    
    /**
     *
     * Write bytes (timeout, framable)
     * The read timeout value established on the socket is enforced
     *
     **/
    public void writeTimeout(DataOutputStream dos, $(AMQPFramable:) framable) throws IOException {
        synchronized(writer) {
            checkWrite();
            // Request write frame
            writeCommand = WRITE_FRAMABLE;
            writeOs = dos;
            writeFramable = framable;
            writer.notify();
        }
    }
    
    /**
     *
     * Flush the output buffer
     *
     **/
    public void flush() throws IOException {
        flush(outgoing);
    }
    
    /**
     *
     * Flush the output buffer (OutputStream)
     *
     **/
    public void flush(OutputStream os) throws IOException {
        synchronized(writer) {
            checkWrite();
            // Request flush
            writeCommand = WRITE_FLUSH;
            writeOs = os;
            writer.notify();
        }
    }
    
    /**
     *
     * Check write status
     *
     **/
     void checkWrite() throws IOException {
         // Check previous completion status
         if (writeCommand != WRITE_IDLE) {
             try {
                 writer.wait(timeout);
             } catch (InterruptedException e) {}
             if (writeCommand != WRITE_IDLE) 
                throw new SocketTimeoutException("$(AMQPTransport:): checkWrite: EXCEPTION, timeout.");
         }    
         // Check previous outcome
         if (ioe != null) {
             IOException aux = ioe;
                
             ioe = null;
             throw aux;
         }
     }
    
    // Exception/warning handling
    
    /**
     *
     * Warning handling
     *
     **/
    public static void warning(String _class, String method, String message) {
        try {
            exception(null, _class, method, "WARNING, " + message, 0); 
        } catch ($(AMQPException:) e) {}
    }
    
    /**
     *
     * Exception handling
     *
     **/
    public static void exception(Exception e, String _class, String method, String message) throws $(AMQPException:) {
        exception(e, _class, method, "Exception, " + message, 1); 
    }
    
    /**
     *
     * Runtime-exception handling
     *
     **/
    public static void runtimeException(Exception e, String _class, String method, String message) throws RuntimeException {
        try {
            exception(e, _class, method, "ERROR, " + message, 2); 
        } catch ($(AMQPException:) f) {}
    }
    
    /**
     *
     * Exception handling
     *
     **/
    static void exception(Exception e, String _class, String method, String message, int type) throws $(AMQPException:) {
        message = _class + ": " + method + ": " + message + ".";
        
        if (e != null) {
            e.printStackTrace();
            System.err.println("From java:");
            System.err.println(e.getMessage());
        }    
        System.err.println("E: " + message);
        switch (type) {
            case 1:
                throw new $(AMQPException:)(message);
            case 2:
                throw new RuntimeException(message);
        }
    }
}

. close
.-///////////////////////////   I N T E R F A C E   /////////////////////////////
.-  Set the protocol output directory
.   directory.setcwd("../../../..")
.   directory.setcwd(imatix_openamq_dir)
.- Glues the frame types together onto this utility class
.echo "Generating $(AMQPFramingFactory:).java..."
. output "$(AMQPFramingFactory:).java"
/**
 *  $(AMQPFramingFactory:).java - Handles frames and related functionality.
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_package:);

import java.io.InputStream;
import java.io.OutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FilterInputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.net.Socket;
import $(imatix_openamq_frames_package:).*;
import $(imatix_openamq_transport_package:).$(AMQPTransport:);
import $(imatix_openamq_package:).$(AMQPException:);
import $(imatix_openamq_package:).$(AMQPIOException:);

public class $(AMQPFramingFactory:) extends $(AMQPTransport:) {
    // Variabes
    public boolean 
        verbose = false;                                   /* Verbose switch                   */
    final static int 
        FRAME_LONG = 0xFFFF,                               /* Frames >= to this are long       */
        FRAME_MIN = 1024;                                  /* Minimum frameMax value accepted  */
    long        
        frameMax = 4096;                                   /* Initial maximum frame size       */
    $(AMQPFieldTable:)
        tuning = null;                                     /* Connection tune parameters       */
    // Frame types instances
.   my.outertype = undefined ?
.   for frame
.       my.new_outertype = string.prefix (name, "_")
.       if (!defined(my.outertype) | my.new_outertype <> my.outertype)
.           my.outertype = my.new_outertype
    $(class_prefix:)$(my.outertype: Neat) 
        $(my.outertype: lower) = new $(class_prefix:)$(my.outertype: Neat)();\
                                                           /* $(my.outertype: Neat)            */
.       endif
.   endfor    
    
    /**
     *
     * $(AMQPFramingFactory:) constructor
     *
     **/
    public $(AMQPFramingFactory:)(Socket socket) throws IOException {
        super(socket.getInputStream(), socket.getOutputStream());
        setOutgoingTimeout(socket.getSoTimeout());
    } 

    /**
     *
     * $(AMQPFramingFactory:) configurable buffer constructor
     *
     **/
    public $(AMQPFramingFactory:)(Socket socket, int readBuff, int writeBuff) throws IOException {
        super(socket.getInputStream(), socket.getOutputStream(), readBuff, writeBuff);
        setOutgoingTimeout(socket.getSoTimeout());
    } 
    
    /**
     *
     * $(AMQPFramingFactory:) constructor
     *
     **/
    public $(AMQPFramingFactory:)(InputStream is, OutputStream os) throws IOException {
        super(is, os);
    } 

    /**
     *
     * $(AMQPFramingFactory:) configurable buffer constructor
     *
     **/
    public $(AMQPFramingFactory:)(InputStream is, OutputStream os, int readBuff, int writeBuff) throws IOException {
        super(is, os, readBuff, writeBuff);
    } 
    
    /**
     *
     * Set the connection tune parameters
     *
     **/
    public void setTuneParameters($(class_prefix:)Connection.Tune tune) throws $(AMQPException) {
        tuning = new $(AMQPFieldTable)(tune.options);
        // Set the frame size limit
        frameMax = tuning.getInteger("FRAME_MAX");
        if (frameMax < FRAME_MIN)
            exception(null, "$(AMQPFramingFactory:)", "setTuneParameters", "FRAME_MAX too small (" + frameMax + " bytes)");
    }    
    
    public long getFrameMax() {
        return frameMax;
    }
    
    // Frame header reading/writing
    
    /**
     *
     * Frame header receiver
     *
     **/
    long receiveFrameHeader() throws $(AMQPException), IOException {
        long 
            frameSize = readUnsignedShort();               /* Frame size                       */
            if (verbose) 
                System.out.println("I: read " + 2 + " bytes from server (frame header)");
        
        if (frameSize == FRAME_LONG) {
            // The frame is long
            frameSize = readUnsignedInt();
            if (verbose) 
                System.out.println("I: read " + 4 + " bytes from server (frame header)");
        }
        if (frameSize <= 0) 
            exception(null, "$(AMQPFramingFactory:)", "receiveFrameHeader", "zero-size frame rejected");
        else if (frameSize > frameMax) 
            exception(null, "$(AMQPFramingFactory:)", "receiveFrameHeader", "frame (" + frameSize + ") > frameMax (" + frameMax + " bytes) rejected");
            
        return frameSize;
    }
    
    /**
     *
     * Frame header sender
     *
     **/
    void sendFrameHeader(long frameSize) throws $(AMQPException), IOException {
        if (frameSize <= frameMax) {
            if (frameSize > 0) {
                if (frameSize >= FRAME_LONG) {
                    // Long frame
                    writeUnsignedShort(FRAME_LONG);
                    writeUnsignedInt(frameSize);
                    if (verbose) 
                        System.out.println("I: wrote " + 6 + " bytes to server (frame header)");
                } else {
                    // Short frame
                    writeUnsignedShort((int)frameSize);
                    if (verbose) 
                        System.out.println("I: wrote " + 2 + " bytes to server (frame header)");
                }
            } else {
                exception(null, "$(AMQPFramingFactory:)", "sendFrameHeader", "zero-size frame rejected");
            }
        } else {
            exception(null, "$(AMQPFramingFactory:)", "sendFrameHeader", "frame (" + frameSize + ") > frameMax (" + frameMax + " bytes) rejected");
        }
    }
    
    // Frame reading/writing
    
    /**
     *
     * Frame receiver method
     *
     **/
    public $(AMQPFrame:) receiveFrame() throws $(AMQPException:), IOException {
        $(AMQPFrame:) 
            frame = null;                                  /* Resulting frame                  */
        long 
            frameSize;                                     /* The frame size                   */
        
        // Read the frame header
        frameSize = receiveFrameHeader();
        // Read frame type     
        $(type_type_last:) = readUnsignedByte();
        // Read the rest of the frame
.   build_if_lists(my.frames, my.outertype, AMQPFramingFactory, 1)            
        if (verbose) {
            System.out.println("I: read " + frame.size() + " bytes from server (frame)");
            frame.dump();
        }
        
        return frame;
    } 
    
    /**
     *
     * Frame sender method
     *
     **/
    public void sendFrame($(AMQPFrame:) frame) throws $(AMQPException:), IOException {
        sendFrameHeader(frame.size());      
        writeTimeout(outgoing(), frame);
        flush(outgoing());
        if (verbose) {
            System.out.println("I: wrote " + frame.size() + " bytes to server (frame)");
            frame.dump();
        }
    } 
    
    /**
     *
     * Frame constructor method
     *
     **/
    public $(AMQPFrame:) constructFrame($(type_type_last)) throws $(AMQPException) {
        $(AMQPFrame:) frame = null;
        
.    build_if_lists(my.frames, my.outertype, AMQPFramingFactory, 2)            

        return frame;
    } 
 
    // Message head reading/writing
    
    /**
     *
     * Message head receiver method
     *
     **/
    public $(class_prefix:)Message.Head receiveMessageHead() throws $(AMQPException:) {
        return receiveMessageHead(null);
    }
    
    /**
     *
     * Message head receiver method (InputStream)
     *
     **/
    public $(class_prefix:)Message.Head receiveMessageHead(DataInputStream dis) throws $(AMQPException:) {
        $(class_prefix:)Message.Head head = null;
        
        // Read the message header
        head = ($(class_prefix:)Message.Head)message.receiveFrame((dis != null) ? dis : incoming());
        if (verbose) {
            System.out.println("I: read " + head.size() + " bytes from server (message head)");
            head.dump();
        }
        
        return head;
    }
    
    /**
     *
     * Message head sender method
     *
     **/
    public void sendMessageHead($(class_prefix:)Message.Head head) throws IOException {
        sendMessageHead(head, null);
    }
    
    /**
     *
     * Message head sender method (OutputStream)
     *
     **/
    public void sendMessageHead($(class_prefix:)Message.Head head, DataOutputStream dos) throws IOException {
        DataOutputStream
            os = (dos != null) ? dos : outgoing();
        writeTimeout(os, head);
        flush(os);
        if (verbose) 
            System.out.println("I: wrote " + head.size() + " bytes to server (message head)");
    }
    
    /**
     *
     * Message head constructor method
     *
     **/
    public $(class_prefix:)Message.Head constructMessageHead() throws $(AMQPException:) {
        return ($(class_prefix:)Message.Head)message.constructFrame();
    }
    
    // Message body reading/writing
    
    /**
     *
     * This returns an InputStream for receiving a message
     * The first handle notify for this message and an empty head must be supplied
     * If the message was NOT prepared, the passed head is filled from the network.
     * If the passed input stream is null, in-band message consumption will take place 
     * Copies the destName variable in the last handle notify to the provided hnFirst
     *
     **/
    public InputStream receiveMessage($(class_prefix:)Handle.Notify hnFirst, $(class_prefix:)Message.Head head, DataInputStream is, boolean prepared)\
    throws IOException {
        return new MessageInputStream(hnFirst, head, (is != null) ? is : incoming(), prepared);
    }
    
    /**
     *
     * This class processes handle notifies from the server, and provides the body of the message as an inputstream
     *
     **/
    public class MessageInputStream extends FilterInputStream {
        $(class_prefix:)Handle.Notify 
            hnFirst,                                       /* Parameters of first fragment     */
            hnCurr;                                        /* Parameters of current fragment   */
        $(class_prefix:)Message.Head 
            head;                                          /* Header for the message           */            
        InputStream
            is;                                            /* Copy of the passed input stream  */            
        long
            mRead,                                         /* Message read so far              */
            fRead;                                         /* Fragment read so far             */
        boolean
            fNew,                                          /* Unread fragment ready            */
            empty = false;                                 /* End of stream                    */
    
        MessageInputStream($(class_prefix:)Handle.Notify hnFirst, $(class_prefix:)Message.Head head, DataInputStream is, boolean prepared) throws IOException {
            super(is);

            try {
                this.hnFirst = hnCurr = hnFirst;
                this.head = head;
                this.is = is;
                mRead = 0; 
                fRead = prepared ? 0 : head.size();
                fNew = fRead == 0;
                if (!prepared) {
                    head = receiveMessageHead();
                    this.head.cloneFrom(head);
                }
            } catch ($(AMQPException:) e) {
                // Encapsulate the exception as $(AMQPIOException) to allow method overloading
                throw new $(AMQPIOException)(e.getMessage());
            }
            
        }
        
        /**
         *
         * Return the number of bytes we can give from the buffer
         *
         */
        public int available() throws IOException {
            if (hnCurr.fragmentSize - fRead == 0 && !fNew)
                receiveHandleNotify();                
            // We will tell the current amount of available remaining fragment
            return (int)Math.min(Integer.MAX_VALUE, Math.min(super.available(), hnCurr.fragmentSize - fRead));
        }
        
        /**
         *
         * The underlying stream will NOT be closed
         *
         */
        public void close() throws IOException {
            try {
                // Test for some inconsistencies    
                if (mRead < head.bodySize)
                    exception(null, "MessageBodyInputStream", "close", "message body underflow");
                if (mRead > head.bodySize)
                    exception(null, "MessageBodyInputStream", "close", "message body overflow");
            } catch ($(AMQPException:) e) {
                // Encapsulate the exception as $(AMQPIOException) to allow method overloading
                throw new $(AMQPIOException)(e.getMessage());
            }
        }
        
        /**
         *
         * This will read a byte from the message
         *
         */
        public int read() throws IOException {
            byte[]
                aByte = new byte[1];
                
            if (read(aByte, 0, aByte.length) != -1) 
                return aByte[0];
            else
                return -1;    
        }
        
        /**
         *
         * This will read a specified amount of bytes from the message
         *
         */
        public int read(byte[] bytes, int off, int len) throws IOException {
            if (!empty) {
                long
                    available; 
                    
                while (len > 0) {    
                    available = hnCurr.fragmentSize - fRead;
                    if (available >= len) {
                        // Read from current fragment
                        receiveData(is, bytes, off, len);
                        if (verbose) 
                            System.out.println("I: read " + len + " bytes from server (of fragment)");
                        mRead += len;
                        fRead += len;
                        fNew = len == 0;
                        off += len;
                        len = 0;
                        if (mRead >= head.bodySize)    
                            empty = true;
                    } else {
                        if (available > 0) {
                            // Read what is available from current fragment
                            receiveData(is, bytes, off, (int)available);
                            if (verbose) 
                                System.out.println("I: read " + available + " bytes from server (of fragment)");
                            mRead += available;
                            fRead += available;
                            off += available;
                            len -= available;
                        } else {   
                            // We must get another handle notify
                            if (receiveHandleNotify() == -1)
                                empty = true;
                        }    
                    }
                }
                return off;
            } else {
                // The stream is empty
                return -1;
            }
        }
        
        int receiveHandleNotify() throws IOException {
            try {
                if (hnCurr.partial) {
                    $(class_prefix:)Frame frame = receiveFrame();
                    if (frame instanceof $(class_prefix:)Handle.Notify) {
                        fRead = 0;
                        fNew = true;
                        hnCurr = ($(class_prefix:)Handle.Notify)frame;
                        if (hnCurr.fragmentSize > frameMax)
                            exception(null, "MessageBodyInputStream", "receiveHandleNotify", "oversized fragment");
                        if (!hnCurr.partial) 
                            hnFirst.destName = hnCurr.destName;
                    } else {
                        frame.dump();
                        exception(null, "MessageBodyInputStream", "receiveHandleNotify", "unexpected frame");
                    }
                } else {    
                
                    return -1;
                }    
            } catch ($(AMQPException:) e) {
                // Encapsulate the exception as $(AMQPIOException) to allow method overloading
                throw new $(AMQPIOException)(e.getMessage());
            }
            
            return 0;
        }
        
        /**
         *
         * Is mark/reset supported (no, no need for look-ahead due to the protocol nature)
         *
         */
        public boolean markSupported() {
            return false;
        }
        
        /**
         *
         * Throws a runtime exception
         *
         */
        public void mark(int limit) {
            runtimeException(null, "MessageBodyInputStream", "mark", "mark not supported");
        }
        
        /**
         *
         * Throws a runtime exception
         *
         */
        public void reset() throws IOException {
            runtimeException(null, "MessageBodyInputStream", "reset", "reset not supported");
        }
        
        /**
         *
         * Skip bytes on the underlying reader
         *
         */
        public long skip(long n) throws IOException {
            long
                skip = n;
            int
                kilo = 1024,
                kilos = 64 * kilo;
            byte[]
                aKilo = new byte[kilo], 
                someKilos = new byte[kilos]; 
        
            while (available() > 0 && n > 0) {    
               // Skip some kilobytes
               if (available() >= kilos) { 
                    read(someKilos, 0, kilos);
                    n -= kilos;
                    continue;
                }                
                
                // Skip kilobytes
                if (available() >= kilo) { 
                    read(aKilo, 0, kilo);
                    n -= kilo;
                    continue;
                }                
                
                // Skip remaining bytes
                while (available() >= 1) {  
                    read();
                    n --;
                }    
            } 
            
            return skip - n;   
        }
    }
    
    /**
     *
     * This returns an OutputStream for sending a message
     * The first handle send and the head for this message must be supplied
     * The constructor will NOT send the message head passed for messages that were prepared
     * If the passed output stream is null, in-band message production will take place 
     * Uses the destName variable from the provided hsFirst for the last handle send
     * Sends fragments of the size specified in hsFirst.fragmentSize 
     *
     */
    public OutputStream sendMessage($(class_prefix:)Handle.Send hsFirst, $(class_prefix:)Message.Head head, DataOutputStream os, boolean prepared)\
    throws IOException {
        return new MessageOutputStream(hsFirst, head, (os != null) ? os : outgoing(), prepared);
    }
 
    /**
     *
     * This class fragments the message body generating handle sends as needed 
     *
     **/
    public class MessageOutputStream extends FilterOutputStream {
        $(class_prefix:)Handle.Send 
            hsCurr;                                        /* Parameters for current fragment  */
        $(class_prefix:)Message.Head 
            head;                                          /* Header for the message           */            
        OutputStream
            os;                                            /* Copy of the passed output stream */
        String
            destName;                                      /* Destination name                 */
        long
            mWritten,                                      /* Message written so far           */
            fWritten,                                      /* Fragment written so far          */
            fragmentSize;                                  /* Target fragment size             */
        boolean
            full = false;                                  /* The message body was written     */
    
        MessageOutputStream($(class_prefix:)Handle.Send hsFirst, $(class_prefix:)Message.Head head, DataOutputStream os, boolean prepared) throws IOException {
            super(os);
            
            try {
                if (hsFirst.fragmentSize > frameMax)
                    runtimeException(null, "MessageBodyOutputStream", "MessageBodyOutputStream", "oversized fragment");
                destName = hsFirst.destName;
                if (!hsFirst.partial) {
                    if (head.size() + head.bodySize > hsFirst.fragmentSize)
                        runtimeException(null, "MessageBodyOutputStream", "MessageBodyOutputStream", "partial is false but message does not fit in fragment");
                } else {
                    hsFirst.destName = "";
                }    
                fragmentSize = hsFirst.fragmentSize;
                hsCurr = hsFirst;
                this.head = head;
                this.os = os;
                mWritten = 0;
                if (!prepared) {
                    sendFrame(hsFirst);
                    sendMessageHead(head);
                    fWritten = head.size();
                } else {
                    sendFrame(hsFirst);
                    fWritten = 0;
                }
            } catch ($(AMQPException:) e) {
                // Encapsulate the exception as $(AMQPIOException) to allow method overloading
                throw new $(AMQPIOException)(e.getMessage());
            }
        }
        
        /**
         *
         * The underlying stream will NOT be closed
         *
         */
        public void close() throws IOException {
            try {
                // Test for some inconsistencies    
                if (mWritten < head.bodySize)
                    exception(null, "MessageBodyOutputStream", "close", "message body underflow");
                if (mWritten > head.bodySize)
                    exception(null, "MessageBodyOutputStream", "close", "message body overflow");
            } catch ($(AMQPException:) e) {
                // Encapsulate the exception as $(AMQPIOException) to allow method overloading
                throw new $(AMQPIOException)(e.getMessage());
            }
        }
        
        /**
         *
         * Requests a flush
         *
         */
        public void flush() throws IOException {
            flushRequest(os);
        }
        
        /**
         *
         * This writes a byte from the message
         *
         */
        public void write(int b) throws IOException {
            byte[]
                aByte = new byte[]{(byte)b};
                
            write(aByte, 0, aByte.length);
        }
        
        /**
         *
         * This will write a specified amount of bytes from the message
         *
         */
        public void write(byte[] bytes, int off, int len) throws IOException {
            if (!full) {
                long
                    available; 

                while (len > 0) {                        
                    available = hsCurr.fragmentSize - fWritten;
                    if (available >= len) {
                        // Fill current fragment
                        sendData(os, bytes, off, len);
                        if (verbose) 
                            System.out.println("I: wrote " + len + " bytes to server (of fragment)");
                        mWritten += len;
                        fWritten += len;
                        off += len;
                        len = 0;    
                        if (mWritten > head.bodySize)
                            full = true;    
                    } else {
                        if (available > 0) {
                            // Fill what is available from current fragment
                            sendData(os, bytes, off, (int)available);
                            if (verbose) 
                                System.out.println("I: wrote " + available + " bytes to server (of fragment)");
                            mWritten += available;
                            fWritten += available;
                            off += available;
                            len -= available;    
                        } else {   
                            // We must generate another handle send
                            if (sendHandleSend() == -1) 
                                full = true;
                        }    
                    }
                }
            }
        }
        
        /**
         *
         * This will prepare for sending the next message fragment
         *
         */
        int sendHandleSend() throws IOException {
            try {
                if (hsCurr.partial) {
                    long
                        mLeft = head.bodySize - mWritten;
                    if (mLeft <= fragmentSize) {
                        // This should be the last fragment
                        hsCurr.partial = false;
                        hsCurr.destName = destName;
                    }
                    hsCurr.fragmentSize = Math.min(fragmentSize, mLeft); 
                    fWritten = 0;
                    sendFrame(hsCurr);
                } else {
                    return -1;
                }
            } catch ($(AMQPException:) e) {
                // Encapsulate the exception as $(AMQPIOException) to allow method overloading
                throw new $(AMQPIOException)(e.getMessage());
            }
            
            return 0;
        }
    }
    
    /**
     *
     * Make flush available for the inner streams
     *
     */
    public void flushRequest(OutputStream os) throws IOException {
        super.flush(os);
    }
}

. close
. endscope
.-///////////////////////////   E X C E P T I O N S   ///////////////////////////
.-  Set the openamq output directory
.- Currently, this generates general exceptions. This can serve as the basis to generate more specialized exceptions.
.    my.current_exception = AMQPException
.    my.current_extends = "Exception"
.    my.current_description = "General protocol exception"
.    my.current_with_cause = 1
.    my.current_import = undefined ?
.    while (defined(my.current_exception))
.        echo "Generating $(my.current_exception:).java..."
. output "$(my.current_exception:).java"
/**
 *  $(my.current_exception:).java - $(my.current_description)
 *
 *  Generated from $(arg?filename) by java/$(script) using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004 JPMorgan
 *  Copyright (c) 1991-2004 iMatix Corporation
 *
 **/
 
package $(imatix_openamq_package);
 
.if (defined (my.current_import))
import $(my.current_import:)
 
.endif
public class $(my.current_exception:) extends $(my.current_extends:) {
    /**
     *
     * Default constructor
     *
     **/
    public $(my.current_exception:)() {
        super();
    }
    
    /**
     *
     * Message constructor
     *
     **/
    public $(my.current_exception:)(String message) {
        super(message);
    }
    
.if (my.current_with_cause)    
    /**
     *
     * Message and cause constructor
     *
     **/
    public $(my.current_exception:)(String message, Throwable cause) {
        super(message, cause);
    }
    
    /**
     *
     * Cause constructor
     *
     **/
    public $(my.current_exception:)(Throwable cause) {
        super(cause);
    }
.endif    
}

. close
.        if (my.current_exception = AMQPException)
.            my.current_exception = AMQPIOException
.            my.current_extends = "IOException"
.            my.current_description = "AMQP IOException"
.            my.current_with_cause = 0
.            my.current_import = "java.io.$(my.current_extends:);"
.        else
.            my.current_exception = undefined ?
.        endif
.    endwhile
.endmacro

#  ------------------------------   Main code  --------------------------------

if scope (frames)
    generate_directories ()
    parse_frames    (frames)
    generate_frames (frames)
endif 
.endtemplate
