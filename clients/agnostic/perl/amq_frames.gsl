.template 0
#! /usr/local/bin/gsl -a
#  ----------------------------------------------------------------------------
#   AMQ Frame Generator
#
#   Frames are structures designed to be easily serialized for writing
#   to a socket or file.  Frames are described using an XML language.
#
#   This script generates frame structures and serialization code.
#
#   Copyright (c) 2004 JPMorgan
#   Copyright (c) 1991-2004 iMatix Corporation
#  ----------------------------------------------------------------------------

function abort_xml_error ()
    abort xml.error
endfunction

function parse_frames (frames)
    name   = "$(name:c)"
    prefix = "$(prefix:c)"
    for . where name() = "frame"
        if name = "frame"
            abort "'frame' is a reserved name, please change this"
        endif
        name = "$(name:c)"
        for field
            name = "$(name:c)"
        endfor
        if count (field, type = "bit")
            .bit_count = count (field, type = "bit")
            for field where type = "bit"
                .start = "1"
                last
            endfor
        endif
        .pack_template = ""
        for field 
            if    type = "char"
                pack_template += "c"
            elsif type = "bit" & start ?= 1
                pack_template += "b"
                pack_template += bit_count
            elsif type = "octet"
                pack_template += "C"
            elsif type = "shortint"
                pack_template += "n"
            elsif type = "longint"
                pack_template += "N"
            elsif type = "shortstr"
                pack_template += "C/a*"
            elsif type = "longstr" | type = "table"
                pack_template += "n/a*"
            endif
        endfor
    endfor
endfunction

.macro generate_frames (frames)
.echo "Generating AMQ::Frame.pm..."
.output "AMQ/Frame.pm"
. scope my.frames
package AMQ::Frame;

.   for frame 
.       for field where name = "type"
use constant $(FRAME.NAME) => $(value);
.       endfor
.   endfor

use constant s_type_to_name => {
.   for frame
.       for field where name = "type"
    $(value) => '$(frame.name)',
.       endfor
.   endfor
};

sub dump {
    my ($frame) = shift;
    my ($output) = '';
   
    $output = "type=" . &s_type_to_name->{$frame->{'type'}} . " ";
    for my $key (keys %$frame) {
        next if $key eq 'type';
        $output .= $key . "=" . $frame->{$key} . " ";
    }
    $output;
}


sub pack {
    my ($frame)      = shift;
    my ($bit_string) = '';
    my ($output)     = '';
    
    SWITCH: {
.   for frame
    if ($frame->{type} == $(NAME)) {
.       if count (field, type = "bit")
            $bit_string = join ('', 
.           for field where type = "bit"
                $frame->{'$(name)'}$(!last()??','?)
.           endfor
                );
.       endif
            $output = pack ('$(pack_template:no)',
.       for field
.           if type = "bit" & start ?= "1"
                $bit_string$(!last()??','?)
.           elsif type <> "bit"
                $frame->{'$(name)'}$(!last()??','?)
.           endif
.       endfor
            );
            last SWITCH;
    }
.   endfor frame
    } # SWITCH

    return ($output);
}

sub unpack {
    my ($input)      = shift;
    my ($frame)      = { };
    
    SWITCH: {
.   for frame
    if (unpack ('C', substr ($input, 0, 1)) == $(NAME)) {
            @$frame{ 
.       for field
.           if type = "bit" & start ?= "1"
                'bit_string'$(!last()??','?)
.           elsif type <> "bit"
                '$(name)'$(!last()??','?) 
.           endif
.       endfor
            }  = unpack ('$(pack_template:no)', $input);
.       if count (field, type = "bit")
            @$frame{
.           for field where type = "bit"
                '$(name)'$(!last()??','?) 
.           endfor
            }  = split (//, $frame->{'bit_string'});
            delete $frame->{'bit_string'};
.       endif
            last SWITCH;
    }
.   endfor frame
    } # SWITCH

    return ($frame);
}
1;
. endscope
.close
.endmacro

.macro generate_proto (frames)
.echo "Generating AMQ::Proto.pm..."
.output "AMQ/Proto.pm"
. scope my.frames
package AMQ::Proto;

use AMQ::Frame;

sub s_hexdump {
    my ($data)   = shift;
    my ($output) = '';
    map { $output .= sprintf ("%02x ", $_) } (unpack ('C*', $data));
    $output;
}

.   for frame
sub $(frame.name) {
    my ($socket)      = shift;
    my ($frame)       = shift;
    my ($frame_data);
    my ($frame_size);
    my ($buffer);

.       for field where name <> "type"
    die "missing $(name)" if (!exists $frame->{'$(name)'});
.       endfor
    $frame->{'type'} = &AMQ::Frame::$(FRAME.NAME);
    $frame_data = &AMQ::Frame::pack ($frame);
    $frame_size = length ($frame_data) + 1; # Include EOF byte
    
    if ($frame_size < 0xfffe) {
        $buffer .= pack ('n', $frame_size);
    } elsif ($length < 0xfffffffe) {
        $buffer .= pack ('nN', 0xffff, $frame_size);
    } else {
        die "frame too long";
    }

    $buffer .= $frame_data;
    $buffer .= pack ('C', 0xce); # EOF
    print ("Sending frame: ", &AMQ::Frame::dump ($frame), "\\n");
    print ("Writing ", length ($buffer), " bytes: ", &s_hexdump ($buffer), "\\n");
    $socket->print ($buffer);
}

.   endfor
sub recv {
    my ($socket)    = shift;
    my ($callbacks) = shift;
    my ($data);
    my ($length);
    my ($frame);

    $socket->read ($data, 2);
    $length = unpack ('n', $data);
    if ($length == 0xffff) {
        $socket->read ($data, 4);
        $length = unpack ('N', $data);
    }
    print ("Will read ", $length, " bytes\\n");
    $socket->read ($data, $length);
    print ("Read: ", &s_hexdump ($data), "\\n");
    $frame = &AMQ::Frame::unpack ($data);
    print ("Received frame: ", &AMQ::Frame::dump ($frame), "\\n");
    if (unpack ('C', substr ($data, -1)) != 0xce) {
        die "framing error";
    }

    if (!exists $callbacks->{$frame->{'type'}}) {
        die "unhandled frame type ", $frame->{'type'};
    }
    &{$callbacks->{$frame->{'type'}}} ($frame);

    return 0;
}

sub init {
    my ($socket) = shift;

    #  Send initiation bytes to server.
    $socket->print (pack ('CC', 128, 1));
}

sub term {
    #  Nothing.
}
. endscope
1;
.close
.endmacro

.
#  ------------------------------   Main code  --------------------------------

if scope (frames)
    parse_frames    (frames)
    generate_frames (frames)
    generate_proto  (frames)
else
    argn = 1
    while argn <= gsl.argc
        arg = gsl.arg$(argn)
        echo "Processing " + arg + "..."
        frames = xml.load_file (arg) ? abort_xml_error ()
        parse_frames    (frames)
        generate_frames (frames)
        generate_proto  (frames)
        argn += 1
    endwhile
endif

.endtemplate
