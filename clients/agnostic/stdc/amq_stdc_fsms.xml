<root
    script = "amq_stdc_fsms"
    >

<machine name = "global_fsm" output = "amq_stdc_global_fsm">
    Holds global state of the API

    <constructor action = "do construct"/>
    <destructor action = "do destruct"/>

    <event name = "init">
        Request to initialise the API
    </event>
    <event name = "create connection">
        Request to create new connection
        <arg type = "const char *" name = "server">
             Server to connect to, IP address or name
        </arg>
        <arg type = "const char *" name = "host">
             Virtual host to connect to
        </arg>
        <arg type = "const char *" name = "client_name">
             Client name to use to connect to server
        </arg>
        <arg type = "amq_stdc_table_t" name = "options">
             Options to be passed to CONNECTION OPEN command
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "remove connection">
        Request to remove connection from global list of connections
        <arg type = "connection_fsm_t" name = "connection">
            Connection to remove
        </arg>
    </event>
    <event name = "assign new channel id">
        Request to assign new channel id
        <arg type = "dbyte *" name = "channel_id">
            Output parameter, new channel id
        </arg>
    </event>
    <event name = "assign new handle id">
        Request to assign new handle id
        <arg type = "dbyte *" name = "handle_id">
            Output parameter, new handle id
        </arg>
    </event>
    <event name = "terminate">
        Request to shut down the API
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion                
        </arg>
    </event>

    <state name = "initial">
        State API is in before it is initialised
        <event name = "init" action = "do init" next = "active"/>
    </state>
    <state name = "active">
        API initialised and functional
        <event name = "create connection" action = "do create connection"/>
        <event name = "remove connection" action = "do remove connection"/>
        <event name = "assign new channel id" action = "do assign new channel id"/>
        <event name = "assign new handle id" action = "do assign new handle id"/>
    </state>
    <state name = "closing">
        API shutting down
        <event name = "terminate" action = "do duplicate terminate"/>
    </state>
    <state name = "terminal">
        API already shut down
    </state>
    <state name = "default">
        Default state
        <event name = "terminate" action = "do terminate" next = "closing"/>
    </state>
</machine>

<machine name = "connection_fsm" output = "amq_stdc_connection_fsm">
    Holds state and additional data associated with CONNECTION

    <constructor action = "do construct"/>
    <destructor action = "do destruct"/>

    <event name = "init">
        Request to open connection
        <arg type = "global_fsm_t" name = "global">
            Global object handle
        </arg>
        <arg type = "dbyte" name = "connection_id">
            Connection id for new connection
        </arg>
        <arg type = "const char *" name = "server">
            Server to connect to
        </arg>
        <arg type = "const char *" name = "host">
            Virtual host to connect to
        </arg>
        <arg type = "const char *" name = "client_name">
            Client name to use to connect to server
        </arg>
        <arg type = "amq_stdc_table_t" name = "options">
            Options table to be passed to OPEN CONNECTION command
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name ="lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "get chunk">
        Used by sender thread to receive next chunk to send
        <arg type = "amq_stdc_lock_t *" name = "lock">
            Out parameter; used by sender thread to wait while next chunk
            is available
        </arg>
    </event>
    <event name = "send chunk">
        Used to send chunks of data tos server via sender thread
        <arg type = "char *" name = "data">
            Chunk to be send by send. Chunk has to be allocated via
            amq_malloc and will be freed by sender thread.
        </arg>
        <arg type = "qbyte" name = "size">
            Number of bytes to send.
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
            Out parameter; can be used to wait for sending completion;
            if NULL, no lock is created
        </arg>
    </event>
    <event name = "challenge">
        CONNECTION CHALLENGE received from server
        <arg type = "byte" name = "version">
            Version of AMQ protocol proposed by server
        </arg>
    </event>
    <event name = "tune">
        CONNECTION TUNE received from server
    </event>
    <event name = "create channel">
        Request to open new channel within the connection
        <arg type = "byte" name = "transacted">
            If 1, channel will be opened in transacted mode
        </arg>
        <arg type = "byte" name = "restartable">
            If 1, channel will be opened in restartable mode
        </arg>
        <arg type = "amq_stdc_table_t" name = "options">
             Options to be passed to CHANNEL OPEN command
        </arg>
        <arg type = "const char *" name = "out_of_band">
             Specifies how out of band transfer should work
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "remove channel">
        Request to remove channel from connection's list of opened channels
        <arg type = "channel_fsm_t" name = "channel">
             Channel to be removed
        </arg>
    </event>
    <event name = "reply">
        CONNECTION REPLY received
        <arg type = "dbyte" name = "confirm_tag">
            Confirm tag
        </arg>
        <arg type = "dbyte" name = "reply_code">
            Reply code received from server
        </arg>
        <arg type = "dbyte" name = "reply_text_size">
            Size of reply text received from server
        </arg>
        <arg type = "const char *" name = "reply_text">
            Reply text received from server
        </arg>
    </event>
    <event name = "terminate">
        Request to shut down the connection
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "close">
        CONNECTION CLOSE received from server
    </event>

    <state name = "initial">
        State connection is in before it is physically opened
        <event name = "init" action = "do init" next = "expect challenge"/>
    </state>
    <state name = "expect challenge">
        Socket opened, initiation bytes sent, wating for CONNECTION CHALLENGE
        <event name = "challenge" action = "do challenge" next = "expect tune"/>
    </state>
    <state name = "expect tune">
        Waiting for CONNECTION TUNE from server
        <event name = "tune" action = "do tune" next = "active"/>
    </state>
    <state name = "active">
        Connection is opened and functional
        <event name = "create channel" action = "do create channel"/>
        <event name = "remove channel" action = "do remove channel"/>
        <event name = "reply" action = "do reply"/>
    </state>
    <state name = "expect close">
        Connection is shutting down
        <event name = "terminate" action = "do duplicate terminate"/>
        <event name = "close" action = "do client requested close" next = "terminal"/>
    </state>
    <state name = "terminal">
        Connection is already shut down
    </state>
    <state name = "default">
        Default state
        <event name = "terminate" action = "do terminate" next = "expect close"/>
        <event name = "close" action = "do server requested close" next = "terminal"/>
        <event name = "get chunk" action = "do get chunk"/>
        <event name = "send chunk" action = "do send chunk"/>
    </state>
</machine>

<machine name = "channel_fsm" output = "amq_stdc_channel_fsm">
    Holds state and additional data associated with CHANNEL

    <constructor action = "do construct"/>
    <destructor action = "do destruct"/>

    <event name = "init">
        Request to open channel
        <arg type = "global_fsm_t" name = "global">
            Global object handle
        </arg>
        <arg type = "connection_fsm_t" name = "connection">
            Connection channel belongs to
        </arg>
        <arg type = "dbyte" name = "connection_id">
            Id of connection channel belongs to
        </arg>
        <arg type = "dbyte" name = "channel_id">
            Id of this channel
        </arg>
        <arg type = "byte" name = "transacted">
            If 1, channel will operate in transacted mode
        </arg>
        <arg type = "byte" name = "restartable">
            If 1, channel will operate in restartable mode
        </arg>
        <arg type = "amq_stdc_table_t" name = "options">
             Options to be passed to CHANNEL OPEN command
        </arg>
        <arg type = "const char *" name = "out_of_band">
             Specifies how out of band transfer should work
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "create handle">
        Request to open new handle
        <arg type = "dbyte" name = "service_type">
            Service type (queue, topic, peer to peer, ...)
        </arg>
        <arg type = "byte" name = "producer">
            If 1, handle may be used to produce messages
        </arg>
        <arg type = "byte" name = "consumer">
            If 1, handle may be used to consume messages
        </arg>
        <arg type = "byte" name = "browser">
            If 1, handle may be used to browse for messages
        </arg>
        <arg type = "byte" name = "temporary">
            If 1, temporary destination will be created
        </arg>
        <arg type = "const char *" name = "dest_name">
            Destination name
        </arg>
        <arg type = "const char *" name = "mime_type">
            MIME type
        </arg>
        <arg type = "const char *" name = "encoding">
            Content encoding
        </arg>
        <arg type = "amq_stdc_table_t" name = "options">
             Options to be passed to HANDLE OPEN command
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "created_lock">
             Output parameter, to be used to wait for confirmation of
             temporary destination creation
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "remove handle">
        Request to remove handle from channel's list of opened handles
        <arg type = "handle_fsm_t" name = "handle">
        </arg>
    </event>
    <event name = "acknowledge">
        Request for message acknowledgement
        <arg type = "qbyte" name = "message_nbr">
             Number of message to acknowledge
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "commit">
        Request to commit work done
        <arg type = "amq_stdc_table_t" name = "options">
             Options to be passed to CHANNEL COMMIT command
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "rollback">
        Request to roll back work done
        <arg type = "amq_stdc_table_t" name = "options">
             Options to be passed to CHANNEL ROLLBACK command
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "receive message">
        Message received from server
        <arg type = "amq_stdc_handle_notify_t *" name = "command">
            Corresponding handle notify command
        </arg>
        <arg type = "const char *" name = "header_buffer">
            Pointer to the buffer where message header is stored
        </arg>
        <arg type = "qbyte" name = "header_buffer_size">
            Size of message header
        </arg>
        <arg type = "char *" name = "body">
            Pointer to newly allocated block with message content.
            There are FRAGMENT_HEADER_SIZE bytes free at the beginning
            of the block
        </arg>
        <arg type = "qbyte" name = "body_size">
            Size of message content
        </arg>
    </event>
    <event name = "get message">
        Request to dispatch message to client
        <arg type = "byte" name = "wait">
             If 1, waits for message to arrive, if 0 returns immediately
             whether message is present or not
        </arg>
        <arg type = "amq_stdc_message_desc_t **" name = "message_desc">
             Output parameter; if no-wait mode is on and message
             is present contains message descriptor, otherwise NULL
        </arg>
        <arg type = "amq_stdc_message_t *" name = "message">
             Output parameter; if no-wait mode is on and message
             is present contains message handle, otherwise NULL
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait (in wait mode)
             for operation completion; in no-wait mode NULL
        </arg>
    </event>
    <event name = "reply">
        CHANNEL REPLY received from server
        <arg type = "dbyte" name = "confirm_tag">
            Confirm tag
        </arg>
        <arg type = "dbyte" name = "reply_code">
            Reply code received from server
        </arg>
        <arg type = "dbyte" name = "reply_text_size">
            Size of reply text received from server
        </arg>
        <arg type = "const char *" name = "reply_text">
            Reply text received from server
        </arg>
    </event>
    <event name = "terminate">
        Request to shut down the channel
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "close">
        CHANNEL CLOSE received from server
    </event>

    <state name = "initial">
        State channel is in before it is physically opened
        <event name = "init" action = "do init" next = "active"/>
    </state>
    <state name = "active">
        Channel is opened and functional
        <event name = "create handle" action = "do create handle"/>
        <event name = "remove handle" action = "do remove handle"/>
        <event name = "acknowledge" action = "do acknowledge"/>
        <event name = "commit" action = "do commit"/>
        <event name = "rollback" action = "do rollback"/>
        <event name = "receive message" action = "do receive message"/>
        <event name = "get message" action = "do get message"/>
        <event name = "reply" action = "do reply"/>
    </state>
    <state name = "expect close">
        Channel is shutting down
        <event name = "terminate" action = "do duplicate terminate"/>
        <event name = "close" action = "do client requested close" next = "terminal"/>
    </state>
    <state name = "terminal">
        Channel is shut down
    </state>
    <state name = "default">
        Default state
        <event name = "terminate" action = "do terminate" next = "expect close"/>
        <event name = "close" action = "do server requested close" next = "terminal"/>
    </state>
</machine>

<machine name = "handle_fsm" output = "amq_stdc_handle_fsm">
    Holds state and additional data associated with HANDLE

    <constructor action = "do construct"/>
    <destructor action = "do destruct"/>

    <event name = "init">
        Request to open handle
        <arg type = "global_fsm_t" name = "global">
            Global object handle
        </arg>
        <arg type = "connection_fsm_t" name = "connection">
            Connection handle belongs to
        </arg>
        <arg type = "channel_fsm_t" name = "channel">
            Channel handle belongs to
        </arg>
        <arg type = "dbyte" name = "connection_id">
            Id of connection handle belongs to
        </arg>
        <arg type = "dbyte" name = "channel_id">
            Id of channel handle belongs to
        </arg>
        <arg type = "dbyte" name = "handle_id">
            Id of this handle
        </arg>
        <arg type = "dbyte" name = "service_type">
            Service type (queue, topic, peer to peer, ...)
        </arg>
        <arg type = "byte" name = "producer">
            If 1, client may produce messages
        </arg>
        <arg type = "byte" name = "consumer">
            If 1, client may consume messages
        </arg>
        <arg type = "byte" name = "browser">
            If 1, client may browse for messages
        </arg>
        <arg type = "const char *" name = "dest_name">
            Destination name
        </arg>
        <arg type = "const char *" name = "mime_type">
            MIME type
        </arg>
        <arg type = "const char *" name = "encoding">
            Content encoding
        </arg>
        <arg type = "amq_stdc_table_t" name = "options">
             Options to be passed to HANDLE OPEN command
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "init temporary">
        Request to open handle (using temporary destination)
        <arg type = "global_fsm_t" name = "global">
            Global object handle
        </arg>
        <arg type = "connection_fsm_t" name = "connection">
            Connection handle belongs to
        </arg>
        <arg type = "channel_fsm_t" name = "channel">
            Channel handle belongs to
        </arg>
        <arg type = "dbyte" name = "connection_id">
            Id of connection handle belongs to
        </arg>
        <arg type = "dbyte" name = "channel_id">
            Id of channel handle belongs to
        </arg>
        <arg type = "dbyte" name = "handle_id">
            Id of this handle
        </arg>
        <arg type = "dbyte" name = "service_type">
            Service type (queue, topic, peer to peer, ...)
        </arg>
        <arg type = "byte" name = "producer">
            If 1, client may produce messages
        </arg>
        <arg type = "byte" name = "consumer">
            If 1, client may consume messages
        </arg>
        <arg type = "byte" name = "browser">
            If 1, client may browse messages
        </arg>
        <arg type = "const char *" name = "dest_name">
            Destination name
        </arg>
        <arg type = "const char *" name = "mime_type">
            MIME type
        </arg>
        <arg type = "const char *" name = "encoding">
            Content encoding
        </arg>
        <arg type = "amq_stdc_table_t" name = "options">
             Options to be passed to HANDLE OPEN command
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "created_lock">
             Output parameter, to be used to wait for confirmation of
             temporary destination creation
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "created">
        HANDLE CREATED received from server
        <arg type = "dbyte" name = "dest_name_size">
            Size of temporary destination name
        </arg>
        <arg type = "const char *" name = "dest_name">
            Temporary destination name
        </arg>
    </event>
    <event name = "consume">
        Request to consume data from destination
        <arg type = "dbyte" name = "prefetch">
            Number of messages to prefetch
        </arg>
        <arg type = "byte" name = "no_local">
            If 1, messages sent from this connection won't be received
        </arg>
        <arg type = "byte" name = "unreliable">
            If 1, client won't acknowledge messages
        </arg>
        <arg type = "const char *" name = "dest_name">
            Destination name
        </arg>
        <arg type = "const char *" name = "identifier">
            Durable subsription name
        </arg>
        <arg type = "const char *" name = "selector">
            Selector string
        </arg>
        <arg type = "const char *" name = "mime_type">
            MIME type
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "send message">
        Request to send message
        <arg type = "byte" name = "out_of_band">
            If 1, message content will be transferred out of band
        </arg>
        <arg type = "byte" name = "recovery">
            If 1, recovery is going on
        </arg>
        <arg type = "byte" name = "streaming">
            If 1, message is a stream
        </arg>
        <arg type = "const char *" name = "dest_name">
            Destination name
        </arg>
        <arg type = "byte" name = "persistent">
            If 1, message is persistent
        </arg>
        <arg type = "byte" name = "priority">
            Message priority 
        </arg>
        <arg type = "qbyte" name = "expiration">
            Message expiration
        </arg>
        <arg type = "const char *" name = "mime_type">
            MIME type
        </arg>
        <arg type = "const char *" name = "encoding">
            Content encoding
        </arg>
        <arg type = "const char *" name = "identifier">
            Message identifier
        </arg>
        <arg type = "apr_size_t" name = "data_size">
            Number of bytes in message body
        </arg>
        <arg type = "void *" name = "data">
            Message body
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "flow">
        Request to suspend or resume message flow from server
        <arg type = "byte" name = "pause">
             If 1, flow should be suspended, if 0, it should be resumed
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "cancel">
        Request to cancel persistent subscription
        <arg type = "const char *" name = "dest_name">
            Destination name
        </arg>
        <arg type = "const char *" name = "identifier">
            Durable subscription name
        </arg>
        <arg type = "byte" name = "async">
            When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
            Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "unget">
        Request to push received message back to server
        <arg type = "qbyte" name = "message_nbr">
            Number of message to push back to server
        </arg>
        <arg type = "byte" name = "async">
            When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
            Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "query">
        Request to query server for messages present
        <arg type = "qbyte" name = "message_nbr">
            Query messages with message number greater than this value
        </arg>
        <arg type = "const char *" name = "dest_name">
            Destination name
        </arg>
        <arg type = "const char *" name = "selector">
            Selector string
        </arg>
        <arg type = "const char *" name = "mime_type">
            MIME type
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
            Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "index">
        HANDLE INDEX received from server
        <arg type = "qbyte" name = "message_nbr">
            Last message number received
        </arg>
        <arg type = "qbyte" name = "message_list_size">
            Size of list of message numbers
        </arg>
        <arg type = "const char *" name = "message_list">
            List of message numbers
        </arg>
    </event>
    <event name = "browse">
        Request to browse server for specific message
        <arg type = "qbyte" name = "message_nbr">
             Number of message to browse
        </arg>
        <arg type = "byte" name = "async">
             When 1, don't wait for confirmation from server
        </arg>
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "reply">
        HANDLE REPLY received from server
        <arg type = "dbyte" name = "confirm_tag">
            Confirm tag
        </arg>
        <arg type = "dbyte" name = "reply_code">
            Reply code received from server
        </arg>
        <arg type = "dbyte" name = "reply_text_size">
            Size of reply text received from server
        </arg>
        <arg type = "const char *" name = "reply_text">
            Reply text received from server
        </arg>
    </event>
    <event name = "terminate">
        Request to shut down the handle
        <arg type = "amq_stdc_lock_t *" name = "lock">
             Output parameter, to be used to wait for operation completion
        </arg>
    </event>
    <event name = "close">
        HANDLE CLOSE received from server
    </event>

    <state name = "initial">
        State handle is in before it is physically opened
        <event name = "init" action = "do init" next = "active"/>
        <event name = "init temporary" action = "do init temporary" next = "expect created"/>
    </state>
    <state name = "expect created">
        In case of opening temporary destination, handle waits in this state
        for confirmation of temporary destination creation
        <event name = "created" action = "do created" next = "active"/>
    </state>
    <state name = "active">
        Handle is opened and functional
        <event name = "consume" action = "do consume"/>
        <event name = "send message" action = "do send message"/>
        <event name = "flow" action = "do flow"/>
        <event name = "cancel" action = "do cancel"/>
        <event name = "unget" action = "do unget"/>
        <event name = "query" action = "do query"/>
        <event name = "index" action = "do index"/>
        <event name = "browse" action = "do browse"/>
        <event name = "reply" action = "do reply"/>
    </state>
    <state name = "expect close">
        Handle is shutting down
        <event name = "terminate" action = "do duplicate terminate"/>
        <event name = "close" action = "do client requested close" next = "terminal"/>
    </state>
    <state name = "terminal">
        Handle is already shut down
    </state>
    <state name = "default">
        Default state
        <event name = "terminate" action = "do terminate" next = "expect close"/>
        <event name = "close" action = "do server requested close" next = "terminal"/>
    </state>
</machine>

<machine name = "message_fsm" output = "amq_stdc_message_fsm">
    Holds state and additional data of individual message

    <constructor action = "do construct"/>
    <destructor action = "do destruct"/>

    <event name = "init">
    </event>
    <event name = "receive fragment">
        <arg type = "char *" name = "body">
            Block with fragment content. There are FRAGMENT_HEADER_SIZE
            bytes free at the beginning of the block
        </arg>
        <arg type = "qbyte" name = "body_size">
            Size of fragment content
        </arg>
    </event>
    <event name = "receive last fragment">
        <arg type = "char *" name = "body">
            Block with frgament content. There are FRAGMENT_HEADER_SIZE
            bytes free at the beginning of the block
        </arg>
        <arg type = "qbyte" name = "body_size">
            Size of fragment content
        </arg>
    </event>
    <event name = "read">
        <arg type = "char *" name = "destination">
            Destination where to read the data, if NULL function just skips
            apropriate number of bytes in stream
        </arg>
        <arg type = "qbyte" name = "size">
            Number of bytes to read
        </arg>
        <arg type = "qbyte*" name = "out_size">
            Number of bytes actually read
        </arg> 
    </event>
    <event name = "term">
    </event>

    <state name = "initial">
        State message is in before first fragment is received
        <event name = "init" action = "do_init" next = "incomplete"/>
    </state>
    <state name = "incomplete">
        Some fragments already received but still waiting for the last one
        <event name = "receive fragment" action = "do_receive_fragment"/>
        <event name = "receive last fragment" action = "do_receive_fragment" next = "complete"/>
        <event name = "read" action = "do_read"/>
        <event name = "term" action = "do_term" next = "zombie"/>
    </state>
    <state name = "complete">
        All fragments already received
        <event name = "read" action = "do_read"/>
        <event name = "term" action = "do_term" next = "terminal"/>
    </state>
    <state name = "zombie">
        Still receiving fragments, but user already closed the message 
        <event name = "receive fragment" action = "do_ignore_fragment"/>
        <event name = "receive last fragment" action = "do_ignore_fragment" next = "terminal"/>
    </state>
    <state name = "terminal">
        Message is already shut down
    </state>
    <state name = "default">
    </state>
</machine>

</root>
