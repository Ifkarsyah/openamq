<root script = "amq_stdc_fsms">

<machine name = "message_fsm" output = "amq_stdc_message_fsm">
    Holds state and additional data of individual message

    <constructor action = "do construct"/>
    <destructor action = "do destruct"/>

    <event name = "init">
        <arg type = "global_fsm_t" name = "global">
            Global object
        </arg>
        <arg type = "channel_fsm_t" name = "channel">
            Channel message belongs to
        </arg>
        <arg type = "dbyte" name = "connection_id">
            Id of connection message belongs to
        </arg>
        <arg type = "dbyte" name = "channel_id">
            Id of channel message belongs to
        </arg>
        <arg type = "amq_stdc_message_desc_t*" name = "message_desc">
            Message descriptor
        </arg>
    </event>
    <event name = "receive content chunk">
        <arg type = "content_chunk_t *" name = "chunk">
            Part of message content.
        </arg>
    </event>
    <event name = "receive last content chunk">
        <arg type = "content_chunk_t *" name = "chunk">
            Last part of message content.
        </arg>
    </event>
    <event name = "open inpipe">
        Opens pipe to read the message
    </event>
    <event name = "pread">
        <arg type = "char *" name = "destination">
            Destination where to read the data, if NULL function just skips
            apropriate number of bytes in stream
        </arg>
        <arg type = "qbyte" name = "size">
            Number of bytes to read
        </arg>
        <arg type = "byte" name = "wait">
            If 1, client wants to wait till specified nuber of bytes is
            available, otherwise return as much as available
        </arg>
        <arg type = "byte" name = "complete">
            If 1, returns either the block of requested size or nothing;
            If 0, return as much data as is currently available;
            Argument has no meaning in combination with wait = 1
        </arg>
        <arg type = "qbyte*" name = "out_size">
            Number of bytes actually read
        </arg> 
        <arg type = "amq_stdc_lock_t *" name = "lock">
            Lock to wait for when wait argument is set to 1
        </arg>
    </event>
    <event name = "peof">
        <arg type = "byte *" name = "out">
            Out parameter; if 1, reading has reached end of stream
        </arg>
    </event>
    <event name = "terminate">
    </event>

    <state name = "initial">
        State message is in before first fragment is received
        <event name = "init" action = "do_init" next = "incomplete"/>
    </state>
    <state name = "incomplete">
        Some fragments already received but still waiting for the last one
        <event name = "receive content chunk" action = "do_receive_content_chunk"/>
        <event name = "receive last content chunk" action = "do_receive_last_content_chunk" next = "complete"/>
        <event name = "open inpipe" action = "do open inpipe"/>
        <event name = "pread" action = "do_pread"/>
        <event name = "peof" action = "do_peof"/>
        <event name = "terminate" action = "do_term" next = "zombie"/>
    </state>
    <state name = "complete">
        All fragments already received
        <event name = "pread" action = "do_pread"/>
        <event name = "terminate" action = "do_term" next = "terminal"/>
    </state>
    <state name = "zombie">
        Still receiving fragments, but user already closed the message 
        <event name = "receive content chunk" action = "do_ignore_content_chunk"/>
        <event name = "receive last content chunk" action = "do_ignore_content_chunk" next = "terminal"/>
    </state>
    <state name = "terminal">
        Message is already shut down
    </state>
    <state name = "default">
    </state>
</machine>

</root>
