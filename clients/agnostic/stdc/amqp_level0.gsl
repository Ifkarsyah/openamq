.template 0
# ------------------------------------------------------------------------------
#  amqp_level0.gsl - source file that generates AMQP/C client API (Level 0)
#  gsl -script:amqp_level0.gsl amq_frames.xml
# 
#  Copyright (c) 2004-2005 JPMorgan
#  Copyright (c) 1991-2005 iMatix Corporation
# ------------------------------------------------------------------------------

# gets access to the field, either on stack or inside the amqp_frame_t structure
.macro getfield (struct, frmname)
.    if "$(my.struct)" = "0" | "$(name:)" = "fragment size"
$(name:c)\
.    else
.        if "$(name:)" = "type"
frame->type\
.        else
frame->fields.$(my.frmname:c).$(name:c)\
.        endif
.    endif
.endmacro

#  Converts type as described in XML to native C type
function makectype (prefix, postfix, comment, local, const)
    if "$(my.const)" = "1"
        cnst = "const "
    else
        cnst = ""
    endif
    if "$(type)" = "octet"
>$(my.prefix)$(cnst)apr_byte_t\
    elsif "$(type)" = "shortstr"
>$(my.prefix)$(cnst)char*\
    elsif "$(type)" = "longstr" | "$(type)" = "table"
>$(my.prefix)$(cnst)char*\
    elsif "$(type)" = "shortint"
>$(my.prefix)$(cnst)apr_uint16_t\
    elsif "$(type)" = "longint"
>$(my.prefix)$(cnst)apr_uint32_t\
    elsif "$(type)" = "bit"
>$(my.prefix)$(cnst)apr_byte_t\
    else
        echo "'$(type)' : unsupported type"
    endif
    if "$(my.local)" = "1"
>
>$(my.prefix)    \
    else
> \
    endif
>$(name:c)\
    if "$(my.comment)" = "1"
> /*  $(field)  */\
    endif
>$(my.postfix)\
endfunction
 
function makectypesize (prefix, postfix, comment, local, const)
    if "$(my.const)" = "1"
        cnst = "const "
    else
        cnst = ""
    endif
    if "$(type)" = "octet"
    elsif "$(type)" = "shortstr"
    elsif "$(type)" = "longstr" | "$(type)" = "table"
>$(my.prefix)$(cnst)apr_size_t\
        if "$(my.local)" = "1"
>
>$(my.prefix)    \
        else
> \
        endif
>$(name:c)_size\
        if "$(my.comment)" = "1"
> /*  $(name) size  */\
        endif
>$(my.postfix)
    elsif "$(type)" = "shortint"
    elsif "$(type)" = "longint"
    elsif "$(type)" = "bit"
    else
        echo "'$(type)' : unsupported type"
    endif
endfunction

#  Creates header for function sending specific frame type to server
function makeheader (comment)
>apr_status_t amqp_$(name:c) (
>    apr_socket_t *socket\
    if "$(my.comment)" = "1"
> /*  amqp socket  */\
    endif
>,
>    char *buffer\
    if "$(my.comment)" = "1"
> /*  buffer used to compose the command  */\
    endif
>,
>    apr_size_t buffer_size\
    if "$(my.comment)" = "1"
> /*  buffer size  */\
    endif
    for field where "$(name)" <> "type" & ("$(frame.name)" <> "handle send" | "$(name)" <> "fragment size")
>,
        makectypesize ("    ", ",", "$(my.comment)", "0", "1")
        makectype ("    ", "", "$(my.comment)", "0", "1")
    endfor
    if "$(name)" = "handle send"
        for frames.frame where name = "message head"
            for field
>,
                makectypesize ("    ", ",", "$(my.comment)", "0", "1")
                makectype ("    ", "", "$(my.comment)", "0", "1")
            endfor
        endfor
>,
>    char* data\
    endif
>
>    )\
endfunction
 
#  Generates code for writing single field into buffer
.macro writeargument (struct, frmname)
    /*  writes '$(name)' field into buffer  */
.    if "$(type)" = "octet"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
    pos += sizeof (apr_byte_t);
.        endif
    if (pos + sizeof (apr_byte_t) > buffer_size) 
        return AMQ_BUFFER_OVERFLOW;
    buffer [pos] = \
.        getfield ("$(my.struct)", "$(my.frmname)")
;
    pos += sizeof (apr_byte_t);
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %ld\\n", (long) \
.        getfield ("$(my.struct)", "$(my.frmname)")
); 
#   endif

.    elsif "$(type)" = "shortint"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
    pos += sizeof (apr_byte_t);
.        endif
    if ( (pos + sizeof (apr_uint16_t) ) > buffer_size) 
        return AMQ_BUFFER_OVERFLOW;
    *( (apr_uint16_t *) (buffer + pos) ) =
        htons (\
.        getfield ("$(my.struct)", "$(my.frmname)")
);
    pos += sizeof (apr_uint16_t);
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %ld\\n", (long) \
.        getfield ("$(my.struct)", "$(my.frmname)")
);
#   endif

.    elsif "$(type)" = "longint"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
    pos += sizeof (apr_byte_t);
.        endif
    if (pos + sizeof (apr_uint32_t) > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
    *( (apr_uint32_t *) (buffer + pos) ) =
        htonl (\
.        getfield ("$(my.struct)", "$(my.frmname)")
);
    pos += sizeof(apr_uint32_t);
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %ld\\n", (long) \
.        getfield ("$(my.struct)", "$(my.frmname)")
);
#   endif

.    elsif "$(type)" = "shortstr"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
    pos += sizeof (apr_byte_t);
.        endif
    len = strlen (\
.        getfield ("$(my.struct)", "$(my.frmname)")
);
    if (len > 0xff)
        return APR_EINVAL;
    if (pos + sizeof (apr_byte_t) > buffer_size )
        return AMQ_BUFFER_OVERFLOW;
    buffer [pos] = (apr_byte_t) len;
    pos += sizeof (apr_byte_t);
    if (pos + len > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
    memmove (buffer + pos, \
.        getfield ("$(my.struct)", "$(my.frmname)")
, len);
    pos += len;
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %s\\n", \
.        getfield ("$(my.struct)", "$(my.frmname)")
);
#   endif

.    elsif "$(type)" = "longstr" | "$(type)" = "table"
.        if "$(bitshift)"<>"0"
.            bitshift=0
    pos += sizeof (apr_byte_t);
.        endif
    if (\
.        getfield ("$(my.struct)", "$(my.frmname)")
_size > 0xffff)
        return APR_EINVAL;
    if (pos + sizeof (apr_uint16_t) > buffer_size )
        return AMQ_BUFFER_OVERFLOW;
    *( (apr_uint16_t *) (buffer+pos) ) =
        htons ( (apr_uint16_t) \
.        getfield ("$(my.struct)", "$(my.frmname)")
_size);
    pos += sizeof (apr_uint16_t);
    if (pos + \
.        getfield ("$(my.struct)", "$(my.frmname)")
_size > buffer_size )
        return AMQ_BUFFER_OVERFLOW;
    memmove (buffer + pos, \
.        getfield ("$(my.struct)", "$(my.frmname)")
, \
.        getfield ("$(my.struct)", "$(my.frmname)")
_size);
    pos += \
.        getfield ("$(my.struct)", "$(my.frmname)")
_size;
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %ld B\\n", (long) \
.        getfield ("$(my.struct)", "$(my.frmname)")
_size);
#   endif

.    elsif "$(type)" = "bit"
.        if "$(bitshift)" = "0"
    buffer [pos] = \
.        getfield ("$(my.struct)", "$(my.frmname)")
 ? 1 : 0;
.        else 
    buffer [pos] |= ( (\
.        getfield ("$(my.struct)", "$(my.frmname)")
 ? 1 : 0) << $(bitshift));
.        endif
.        bitshift = bitshift + 1
.        if bitshift = 8
.            bitshift = 0
    if (pos + sizeof(apr_byte_t) > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
.        endif
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %ld\\n", (long) \
.        getfield ("$(my.struct)", "$(my.frmname)")
);
#   endif

.    else
.        echo "'$(type)' : unsupported type"
.    endif
.endmacro

#  Generates code for reading single field from buffer
.macro readargument (struct, frmname)
            /*  decodes '$(name)' field  */
.    if "$(type)" = "octet"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
            pos+=sizeof(apr_byte_t);
.        endif
            \
.        getfield ("$(my.struct)", "$(my.frmname)")
 = (apr_byte_t) buffer [pos];
            pos += sizeof (apr_byte_t);
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %ld\\n", (long) \
.        getfield ("$(my.struct)", "$(my.frmname)")
);
#           endif

.    elsif "$(type)" = "shortint"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
            pos += sizeof (apr_byte_t);
.        endif
            \
.        getfield ("$(my.struct)", "$(my.frmname)")
 = ntohs (*( (apr_uint16_t *) (buffer + pos) ) );
            pos += sizeof (apr_uint16_t);
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %ld\\n", (long) \
.        getfield ("$(my.struct)", "$(my.frmname)")
);
#           endif

.    elsif "$(type)" = "longint"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
            pos += sizeof (apr_byte_t);
.        endif
            \
.        getfield ("$(my.struct)", "$(my.frmname)")
 = ntohl (*( (apr_uint32_t *) (buffer + pos) ) );
            pos += sizeof(apr_uint32_t);
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %ld\\n", (long) \
.        getfield ("$(my.struct)", "$(my.frmname)")
);
#           endif

.    elsif "$(type)" = "shortstr"
.    if "$(bitshift)" <> "0"
.        bitshift = 0
            pos += sizeof (apr_byte_t);
.        endif
            \
.        getfield ("$(my.struct)", "$(my.frmname)")
 = (char *) (buffer + pos + sizeof (apr_byte_t) );
            pos += sizeof(apr_byte_t) + (apr_byte_t) (buffer [pos] );
            if (command_length + 1 >= buffer_size)
                return AMQ_BUFFER_OVERFLOW;
            memmove (buffer + pos + 1, buffer + pos, full_size - pos);
            buffer [pos] = 0;
            pos++;
            full_size++;
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %s\\n", \
.        getfield ("$(my.struct)", "$(my.frmname)")
);
#           endif

.    elsif "$(type)" = "longstr" | "$(type)" = "table"
.        if "$(bitshift)" <> "0"
.        bitshift = 0
            pos += sizeof (apr_byte_t);
.        endif
            \
.        getfield ("$(my.struct)", "$(my.frmname)")
_size = ntohs (*( (apr_uint16_t*) (buffer+pos) ) );
            buffer += sizeof (apr_uint16_t);
            \
.        getfield ("$(my.struct)", "$(my.frmname)")
 = buffer + pos;
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %ld B\\n", (long) \
.        getfield ("$(my.struct)", "$(my.frmname)")
_size);
#           endif
            pos += \
.        getfield ("$(my.struct)", "$(my.frmname)")
_size;
            if (command_length + 1 >= buffer_size) 
                return AMQ_BUFFER_OVERFLOW;
            memmove (buffer + pos + 1, buffer + pos, full_size - pos);
            buffer [pos] = 0;
            pos++;
            full_size++;

.    elsif "$(type)" = "bit"
            \
.        getfield ("$(my.struct)", "$(my.frmname)")
 =
                ( ( (apr_byte_t) buffer [pos] ) >> $(bitshift))&0x01;
.        bitshift = bitshift + 1
.        if "$(bitshift)" = "8"
.            bitshift = 0
            pos += sizeof (apr_byte_t);
.        endif
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %ld\\n", (long) \
.        getfield ("$(my.struct)", "$(my.frmname)")
);
#           endif

.    else
.        echo "'$(type)' : unsupported type"
.    endif
.endmacro

.macro recv_body (struct)
    apr_status_t
        result;
    apr_uint32_t
        command_length = 0;
    apr_uint32_t
        full_size = 0;
    apr_uint32_t
        pos = 0;
    apr_size_t
        sz;
.    if "$(my.struct)" = "0"
    amqp_frame_type_t
        frame_type;
.    endif

    /*  get all frame data from socket  */
    sz = sizeof (apr_uint16_t);
    result = apr_socket_recv (socket, buffer, &sz);
    if(result != APR_SUCCESS)
        return result;
    pos += sizeof (apr_uint16_t);
    command_length = ntohs (*( (apr_uint16_t *) buffer) );
    full_size = command_length + sizeof (apr_uint16_t);
    if (command_length == 0xffff) {
        sz = sizeof (apr_uint32_t);
        result = apr_socket_recv (socket, buffer + pos, &sz);
        if (result!=APR_SUCCESS)
            return result;
        pos += sizeof (apr_uint32_t);
        command_length =
            ntohl (*( (apr_uint32_t*) (buffer + sizeof(apr_uint16_t) ) ) );
        full_size = command_length + sizeof (apr_uint16_t) + sizeof (apr_uint32_t);
    }
    if (command_length > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
    sz = command_length;
    result = apr_socket_recv (socket, buffer + pos, &sz);
    if (result != APR_SUCCESS) return result;
    if (*(apr_byte_t *) (buffer + pos + command_length - sizeof (apr_byte_t) ) != (apr_byte_t) 0xce)
        return AMQ_FRAME_CORRUPTED;

    /*  parse individual command types  */
.    if "$(my.struct)" = "0"
    frame_type = (amqp_frame_type_t) buffer [pos];
.    else
    frame->type = (amqp_frame_type_t) buffer [pos];
.    endif
    pos += sizeof(apr_byte_t);
.    if "$(my.struct)" = "0"
    switch (frame_type)
.    else
    switch (frame->type)
.    endif
    {
.- generates code to dispatch individual frame type
.for frame where defined (frame->sender (role = "server") )
    case amqp_$(name:c)_type:
        {
            /*  decodes and dispatches '$(name)' command  */

.    bitshift = 0
.    if "$(my.struct)" = "0"
.        for field where "$(name)" <> "type"
.            makectypesize ("            ", ";", "0", "1", "0")
.            makectype ("            ", "", "0", "1", "0")
;
.        endfor
.        if "$(name)" = "handle notify"
.            for frames.frame where name = "message head"
.                for field
.                    makectypesize ("            ", ";", "0", "1", "0")
.                    makectype ("            ", "", "0", "1", "0")
;
.                endfor
.            endfor
            char*
                data;
.        endif

.    endif
.    for field where "$(name)" <> "type"
.        readargument ("$(my.struct)", "$(frame.name)")
.    endfor
.- handle notify frame is followed by message head
.- following lines generate code to decode it
.    if "$(name)" = "handle notify"
.        for frames.frame where name = "message head"
            /*  decodes message head  */
            sz = fragment_size;
            result = apr_socket_recv (socket, buffer + pos, &sz );
            if (result != APR_SUCCESS)
                return result;
            full_size = pos + fragment_size;

.            for field
.                readargument ("$(my.struct)", "handle notify")
.            endfor
.        endfor
            /*  decodes message data  */
.        if "$(my.struct)" = "0"
            data = (char *) (buffer + pos);
            pos += body_size;
.        else
            frame->fields.handle_notify.data = (char *) (buffer + pos);
            pos += frame->fields.handle_notify.body_size;
.        endif

.    endif
            /*  dispatches command  */
#           if defined(AMQTRACE)
                fprintf (stderr, "$(name) received.\\n\\n"); 
#           endif
.    if "$(my.struct)" = "0"
            if (callbacks->$(name:c))
                return callbacks->$(name:c) (
                    hint,\
.        for field where "$(name)" <> "type" & ("$(frame.name)" <> "handle notify" | "$(name)" <> "fragment size")

.            if "$(type)" = "longstr" | "$(type)" = "table"
                    $(name:c)_size,
.            endif
                    $(name:c)$(!last()??","?)\
.        endfor
.        if "$(name)" = "handle notify"
,
.            for frames.frame where name = "message head"
.                for field
.                    if "$(type)" = "longstr" | "$(type)" = "table"
                    $(name:c)_size,
.                    endif
                    $(name:c),
.                endfor
.            endfor
                    data\
.        endif

                    );
            else return APR_SUCCESS;
.    else
            return APR_SUCCESS;
.    endif
        }
.endfor
    default:
        return AMQ_FRAME_CORRUPTED;
    }
.endmacro

.macro send_body (struct)
    /*  writes '$(name)' command into buffer  */

    type = amqp_$(name:c)_type;

.    bitshift = 0
.    for field
.        if "$(frame.name)" = "handle send" & "$(name)" = "fragment size"
    fragment_size_pos = pos;
.        endif
.        writeargument ("$(my.struct)", "$(frame.name)")
.    endfor
.    if "$(bitshift)" <> "0"
.        bitshift = 0
    pos += sizeof (apr_byte_t);
.    endif
    /*  writes terminal byte into buffer  */
    if (pos + sizeof(apr_byte_t) > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
    buffer [pos] = (apr_byte_t) 0xce;
    pos += sizeof (apr_byte_t);

    /*  adjusts size  */
    if (pos - sizeof (apr_uint32_t) - sizeof (apr_uint16_t) < 0xffff) {
        *( (apr_uint16_t *) (buffer + sizeof (apr_uint32_t) ) ) =
            htons ( (apr_uint16_t) (pos - sizeof (apr_uint32_t) - sizeof (apr_uint16_t) ) );
        start_pos = sizeof (apr_uint32_t);
    }
    else {
        *( (apr_uint16_t *) buffer) = 0xffff;
        *( (apr_uint32_t *) (buffer + sizeof (apr_uint16_t) ) ) =
            htonl (pos - sizeof (apr_uint32_t) - sizeof (apr_uint16_t) );
        sz = pos;
        start_pos = sizeof (apr_uint16_t);
    }
.- handle send command is followed by message head
.- following lines generate code to write it into buffer
.    if "$(name)" = "handle send"
    
    /*  writes message head  */
	message_head_pos = pos;

.        frmname = "$(frame.name)"
.        bitshift = 0
.        for frames.frame where name = "message head"
.            for field
.                writeargument ("$(my.struct)", "$(frmname)")
.            endfor
.        endfor
    /*  writes message data  */
    if (pos + \
.        if "$(my.struct)" = "0"
body_size\
.        else
frame->fields.handle_send.body_size\
.        endif
 > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
.        if "$(my.struct)" = "0"
    memmove (buffer + pos, data, body_size);
    pos += body_size;
.        else
    memmove (buffer + pos, frame->fields.handle_send.data, frame->fields.handle_send.body_size);
    pos += frame->fields.handle_send.body_size;
.        endif
.    endif
.    if "$(name)" = "handle send"

    /*  adjusts fragment size  */
    *( (apr_uint32_t*) (buffer + fragment_size_pos) ) =
        htonl (pos - message_head_pos);
.    endif

    /*  sends command to server  */
    sz = pos - start_pos;
    result = apr_socket_send (socket, buffer + start_pos, &sz);
    if (result != APR_SUCCESS)
        return result;
#   if defined(AMQTRACE)
        fprintf (stderr, "$(name) issued.\\n\\n");
#   endif

    return APR_SUCCESS;
.endmacro

.macro generate_interface ()
.output "amqp_level0.h"
/*---------------------------------------------------------------------------
 *  amqp_level0.h - headers for AMQP client API (Level 0)
 *
 *  Generated from amq_frames.xml by amqp_level0.gsl using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004-2005 JPMorgan
 *  Copyright (c) 1991-2005 iMatix Corporation
 *---------------------------------------------------------------------------*/

#include "base_apr.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*  error value received when frame non coforming to  */
/*  AMQP protocol is received from the server.  */
#define AMQ_FRAME_CORRUPTED (APR_OS_START_USERERR + 0)
/*  error value received when supplied buffer is too small to either :  */
/*      1. store whole frame received from the server  */
/*      2. store whole frame to be sent to the server  */
#define AMQ_BUFFER_OVERFLOW (APR_OS_START_USERERR + 1)

/*  types of amqp frames  */
typedef enum
{
.for frame where name <> "message head"
    amqp_$(name:c)_type = $(frame->field (name = "type").value)$(!last()??","?)
.endfor
} amqp_frame_type_t;

/*  structure corresponding to the generic amqp frame  */
typedef struct
{
    amqp_frame_type_t type;
    union
    {
.for frame where "$(name)" <> "message head"
        struct
        {
.    for field where "$(name)" <> "type" & ("$(frame.name)" <> "handle notify" | "$(name)" <> "fragment size")
.        makectypesize ("            ", ";", "1", "0", "0") 
.        makectype ("            ", ";\n", "1", "0", "0") 
.    endfor
.    if "$(name)" = "handle notify" | "$(name)" = "handle send"
.        for frames.frame where name = "message head"
.            for field
.                makectypesize ("            ", ";", "1", "0", "0") 
.                makectype ("            ", ";\n", "1", "0", "0")
.            endfor
.        endfor
            char *data;
.    endif
        } $(name:c);
.endfor
    } fields;
} amqp_frame_t;

.for frame where defined (frame->sender (role = "server") )
/*  prototype of callback function corresponding to '$(name)' command  */
typedef apr_status_t (*amqp_$(name:c)_t) (
    const void *hint /*  hint passed to amqp_recv  */,\
.    for field where "$(name)" <> "type" & ("$(frame.name)" <> "handle notify" | "$(name)" <> "fragment size")

.        makectypesize ("    ", ",", "1", "0", "1") 
.        makectype ("    ", "", "1", "0", "1") 
$(!last()??","?)\
.    endfor
.    if "$(name)" = "handle notify"
,\
.        for frames.frame where name = "message head"
.            for field

.                makectypesize ("    ", ",", "1", "0", "1")
.                makectype ("    ", "", "1", "0", "1") 
,\
.            endfor
.        endfor

    const char *data\
.    endif

    );

.endfor
/*  structure that keeps callback function pointers  */
/*  if field is equal to NULL, no callback will be called  */
typedef struct
{
.for frame where defined (frame->sender (role = "server") )
    amqp_$(name:c)_t $(name:c);
.endfor
} amqp_callbacks_t;

/*  ---------------------------------------------------------------------[<]-
    Function: amqp_init

    Synopsis:
    Sends initiation bytes to the server.
    ---------------------------------------------------------------------[>]-*/
apr_status_t amqp_init (
    apr_socket_t *socket /*  amqp socket  */
    );

/*  ---------------------------------------------------------------------[<]-
    Function: amqp_term

    Synopsis:
    Uninitializes AMQP client API (dummy function for now)
    ---------------------------------------------------------------------[>]-*/
apr_status_t amqp_term (
    apr_socket_t *socket /*  amqp socket  */
    );

/*  ---------------------------------------------------------------------[<]-
    Function: amqp_recv_struct

    Synopsis:
    Returns single command frame received from server
    ---------------------------------------------------------------------[>]-*/
apr_status_t amqp_recv_struct (
    apr_socket_t *socket /*  amqp socket  */,
    char *buffer /*  buffer used to store the strings  */,
    apr_size_t buffer_size /*  buffer size  */,
    amqp_frame_t *frame /*  frame that will be filled in  */
    );

/*  ---------------------------------------------------------------------[<]-
    Function: amqp_send_struct

    Synopsis:
    Sends single command to the server
    ---------------------------------------------------------------------[>]-*/
apr_status_t amqp_send_struct (
    apr_socket_t *socket /*  amqp socket  */,
    char *buffer /*  buffer used to compose the command  */,
    apr_size_t buffer_size /*  buffer size  */,
    amqp_frame_t *frame /*  frame to send  */
    );

/*  ---------------------------------------------------------------------[<]-
    Function: amqp_recv

    Synopsis:
    Dispatches single command to apropriate callback function (if registered).
    ---------------------------------------------------------------------[>]-*/
apr_status_t amqp_recv (
    apr_socket_t *socket /*  amqp socket  */,
    char *buffer /*  buffer used to store the command  */,
    apr_size_t buffer_size /*  buffer size  */,
    amqp_callbacks_t *callbacks /*  contians pointers to callback functions for individual commands  */,
    void *hint /*  hint to be passed to callback function  */
    );
    
.for frame where defined(frame->sender(role="client"))
/*  ---------------------------------------------------------------------[<]-
    Function: amqp_$(name:c)

    Synopsis:
    Sends $(name) command to the server.
    ---------------------------------------------------------------------[>]-*/
.    makeheader ("1")
;

.endfor
/*  ---------------------------------------------------------------------[<]-
    Function: amqp_strerror

    Synopsis:
    Translates error code into human readable string.
    ---------------------------------------------------------------------[>]-*/
char *amqp_strerror (
    apr_status_t statcode /*  status to be translated to string  */,
    char *buffer /*  buffer to hold the result  */,
    apr_size_t buffer_size /*  buffer size  */
    );
.endmacro

.macro generate_implementation ()
.output "amqp_level0.c"
/*---------------------------------------------------------------------------
 *  amqp_level0.c - implementation for AMQP client API (Level 0)
 *
 *  Generated from amq_frames.xml by amqp_level0.gsl using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004-2005 JPMorgan
 *  Copyright (c) 1991-2005 iMatix Corporation
 *---------------------------------------------------------------------------*/

#include "amqp_level0.h"

apr_status_t amqp_init (
    apr_socket_t *socket
    )
{
    apr_status_t
        result;
    char
        data [2];
    apr_size_t
        sz;

    /*  send initiation bytes to server  */
    data [0] = (char) 128;
    data [1] = (char) 1;
    sz = 2;
    result = apr_socket_send (socket, data, &sz);
    if (result != APR_SUCCESS)
        return result;
    return APR_SUCCESS;
};

apr_status_t amqp_term (
    apr_socket_t *socket
    )
{
    return APR_SUCCESS;
};

apr_status_t amqp_recv_struct (
    apr_socket_t *socket,
    char *buffer,
    apr_size_t buffer_size,
    amqp_frame_t *frame
    )
{
    apr_uint32_t
        fragment_size;
.recv_body ("1")
}

apr_status_t amqp_send_struct (
    apr_socket_t *socket,
    char *buffer,
    apr_size_t buffer_size,
    amqp_frame_t *frame
    )
{
    apr_status_t
        result;
    apr_uint32_t
        pos = sizeof (apr_uint16_t) + sizeof(apr_uint32_t);
    apr_uint32_t
        len = 0;
    apr_size_t
        sz;
    amqp_frame_type_t
        type;
    apr_uint32_t
        start_pos;
    apr_uint32_t
        fragment_size_pos;
    apr_uint32_t
        fragment_size = 0;
    apr_uint32_t
        message_head_pos;

    switch (frame->type)
    {
.for frame where defined (frame->sender (role = "client") )
    case amqp_$(name:c)_type:
.    send_body ("1")

.endfor
    default:
        return AMQ_FRAME_CORRUPTED;
    }
}

apr_status_t amqp_recv (
    apr_socket_t *socket,
    char *buffer,
    apr_size_t buffer_size,
    amqp_callbacks_t *callbacks,
    void *hint
    )
{
.recv_body ("0")
}

.- generates functions to send individual command types to server
.for frame where defined(frame->sender(role="client"))
.    makeheader ("0")

{
    apr_status_t
        result;
    apr_uint32_t
        pos = sizeof (apr_uint16_t) + sizeof(apr_uint32_t);
.    shortstrcount = 0
.    for field where type = "shortstr"
.        shortstrcount = shortstrcount + 1
.    endfor
.    if shortstrcount > 0
    apr_uint32_t
        len = 0;
.    endif
    apr_size_t
        sz;
    amqp_frame_type_t
        type;
    apr_uint32_t
        start_pos;
.    if "$(name)" = "handle send"
    apr_uint32_t
        fragment_size_pos;
    apr_uint32_t
        fragment_size = 0;
    apr_uint32_t
        message_head_pos;
.    endif

.    send_body ("0")
};

.endfor
char *amqp_strerror (
    apr_status_t statcode,
    char *buffer,
    apr_size_t buffer_size
    )
{
    const char*
        str = NULL;

    switch (statcode)
    {
    case AMQ_FRAME_CORRUPTED:
        str = "Received corrupted frame.";
        break;
    case AMQ_BUFFER_OVERFLOW:
        str = "Received or trying to send frame bigger than available buffer.";
        break;
    default:
        return apr_strerror (statcode, buffer, buffer_size);
    }
    return strncpy(buffer, str, buffer_size);
}
.endmacro


#
#  Main Program 
#
generate_interface ()
generate_implementation ()

endtemplate  
