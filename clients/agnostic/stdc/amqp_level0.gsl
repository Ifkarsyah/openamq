.template 0
# ------------------------------------------------------------------------------
#  amqp_level0.gsl - source file that generates AMQP/C client API (Level 0)
#  gsl -script:amqp_level0.gsl amq_frames.xml
# 
#  Copyright (c) 2004-2005 JPMorgan
#  Copyright (c) 1991-2005 iMatix Corporation
# ------------------------------------------------------------------------------

#  Converts type as described in XML to native C type
function makectype (prefix, comment, local, const)
    if "$(my.const)" = "1"
        cnst = "const "
    else
        cnst = ""
    endif
    if "$(type)" = "octet"
>$(my.prefix)$(cnst)apr_byte_t\
    elsif "$(type)" = "shortstr"
>$(my.prefix)$(cnst)char*\
    elsif "$(type)" = "longstr" | "$(type)" = "table"
>$(my.prefix)$(cnst)char*\
    elsif "$(type)" = "shortint"
>$(my.prefix)$(cnst)apr_uint16_t\
    elsif "$(type)" = "longint"
>$(my.prefix)$(cnst)apr_uint32_t\
    elsif "$(type)" = "bit"
>$(my.prefix)$(cnst)apr_byte_t\
    else
        echo "'$(type)' : unsupported type"
    endif
    if "$(my.local)" = "1"
>
>$(my.prefix)    \
    else
> \
    endif
>$(name:c)\
    if "$(my.comment)" = "1"
> /*  $(field)  */\
    endif
endfunction
 
function makectypesize (prefix, postfix, comment, local, const)
    if "$(my.const)" = "1"
        cnst = "const "
    else
        cnst = ""
    endif
    if "$(type)" = "octet"
    elsif "$(type)" = "shortstr"
    elsif "$(type)" = "longstr" | "$(type)" = "table"
>$(my.prefix)$(cnst)apr_size_t\
        if "$(my.local)" = "1"
>
>$(my.prefix)    \
        else
> \
        endif
>$(name:c)_size\
        if "$(my.comment)" = "1"
> /*  $(name) size  */\
        endif
>$(my.postfix)
    elsif "$(type)" = "shortint"
    elsif "$(type)" = "longint"
    elsif "$(type)" = "bit"
    else
        echo "'$(type)' : unsupported type"
    endif
endfunction

#  Creates header for function sending specific frame type to server
function makeheader (comment)
>apr_status_t amqp_$(name:c) (
>    apr_socket_t *socket\
    if "$(my.comment)" = "1"
> /*  amqp socket  */\
    endif
>,
>    char *buffer\
    if "$(my.comment)" = "1"
> /*  buffer used to compose the command  */\
    endif
>,
>    apr_size_t buffer_size\
    if "$(my.comment)" = "1"
> /*  buffer size  */\
    endif
    for field where "$(name)" <> "type" & ("$(frame.name)" <> "handle send" | "$(name)" <> "fragment size")
>,
        makectypesize ("    ", ",", "$(my.comment)", "0", "1")
        makectype ("    ", "$(my.comment)", "0", "1")
    endfor
    if "$(name)" = "handle send"
        for frames.frame where name = "message head"
            for field
>,
                makectypesize ("    ", ",", "$(my.comment)", "0", "1")
                makectype ("    ", "$(my.comment)", "0", "1")
            endfor
        endfor
>,
>    char* data\
    endif
>
>    )\
endfunction
 
#  Generates code for writing single field into buffer
.macro writeargument()
    /*  writes '$(name)' field into buffer  */
.    if "$(type)" = "octet"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
    pos += sizeof (apr_byte_t);
.        endif
    if (pos + sizeof (apr_byte_t) > buffer_size) 
        return AMQ_BUFFER_OVERFLOW;
    buffer [pos] = $(name:c);
    pos += sizeof (apr_byte_t);
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %ld\\n", (long) $(name:c)); 
#   endif

.    elsif "$(type)" = "shortint"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
    pos += sizeof (apr_byte_t);
.        endif
    if ( (pos + sizeof (apr_uint16_t) ) > buffer_size) 
        return AMQ_BUFFER_OVERFLOW;
    *( (apr_uint16_t *) (buffer + pos) ) = htons ($(name:c));
    pos += sizeof (apr_uint16_t);
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %ld\\n", (long) $(name:c));
#   endif

.    elsif "$(type)" = "longint"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
    pos += sizeof (apr_byte_t);
.        endif
    if (pos + sizeof (apr_uint32_t) > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
    *( (apr_uint32_t *) (buffer + pos) ) = htonl ($(name:c));
    pos += sizeof(apr_uint32_t);
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %ld\\n", (long) $(name:c));
#   endif

.    elsif "$(type)" = "shortstr"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
    pos += sizeof (apr_byte_t);
.        endif
    len = strlen ($(name:c));
    if (len > 0xff)
        return APR_EINVAL;
    if (pos + sizeof (apr_byte_t) > buffer_size )
        return AMQ_BUFFER_OVERFLOW;
    buffer [pos] = (apr_byte_t) len;
    pos += sizeof (apr_byte_t);
    if (pos + len > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
    memmove (buffer + pos, $(name:c), len);
    pos += len;
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %s\\n", $(name:c));
#   endif

.    elsif "$(type)" = "longstr" | "$(type)" = "table"
.        if "$(bitshift)"<>"0"
.            bitshift=0
    pos += sizeof (apr_byte_t);
.        endif
    if ($(name:c)_size > 0xffff)
        return APR_EINVAL;
    if (pos + sizeof (apr_uint16_t) > buffer_size )
        return AMQ_BUFFER_OVERFLOW;
    *( (apr_uint16_t *) (buffer+pos) ) = htons ( (apr_uint16_t) $(name:c)_size);
    pos += sizeof (apr_uint16_t);
    if (pos + $(name:c)_size > buffer_size )
        return AMQ_BUFFER_OVERFLOW;
    memmove (buffer + pos, $(name:c), $(name)_size);
    pos += $(name)_size;
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %ld B\\n", (long) $(name)_size);
#   endif

.    elsif "$(type)" = "bit"
.        if "$(bitshift)" = "0"
    buffer [pos] = $(name:c) ? 1 : 0;
.        else 
    buffer [pos] |= ( ($(name:c) ? 1 : 0) << $(bitshift));
.        endif
.        bitshift = bitshift + 1
.        if bitshift = 8
.            bitshift = 0
    if (pos + sizeof(apr_byte_t) > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
.        endif
#   if defined(AMQTRACE)
        fprintf (stderr, "    $(name) = %ld\\n", (long) $(name:c));
#   endif

.    else
.        echo "'$(type)' : unsupported type"
.    endif
.endmacro

#  Generates code for reading single field from buffer
.macro readargument ()
            /*  decodes '$(name)' field  */
.    if "$(type)" = "octet"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
            pos+=sizeof(apr_byte_t);
.        endif
            $(name:c) = (apr_byte_t) buffer [pos];
            pos += sizeof (apr_byte_t);
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %ld\\n", (long) $(name:c));
#           endif

.    elsif "$(type)" = "shortint"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
            pos += sizeof (apr_byte_t);
.        endif
            $(name:c) = ntohs (*( (apr_uint16_t *) (buffer + pos) ) );
            pos += sizeof (apr_uint16_t);
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %ld\\n", (long) $(name:c));
#           endif

.    elsif "$(type)" = "longint"
.        if "$(bitshift)" <> "0"
.            bitshift = 0
            pos += sizeof (apr_byte_t);
.        endif
            $(name:c) = ntohl (*( (apr_uint32_t *) (buffer + pos) ) );
            pos += sizeof(apr_uint32_t);
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %ld\\n", (long) $(name:c));
#           endif

.    elsif "$(type)" = "shortstr"
.    if "$(bitshift)" <> "0"
.        bitshift = 0
            pos += sizeof (apr_byte_t);
.        endif
            $(name:c) = (char *) (buffer + pos + sizeof (apr_byte_t) );
            pos += sizeof(apr_byte_t) + (apr_byte_t) (buffer [pos] );
            if (command_length + 1 >= buffer_size)
                return AMQ_BUFFER_OVERFLOW;
            memmove (buffer + pos + 1, buffer + pos, full_size - pos);
            buffer [pos] = 0;
            pos++;
            full_size++;
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %s\\n", $(name:c));
#           endif

.    elsif "$(type)" = "longstr" | "$(type)" = "table"
.        if "$(bitshift)" <> "0"
.        bitshift = 0
            pos += sizeof (apr_byte_t);
.        endif
            $(name:c)_size = ntohs (*( (apr_uint16_t*) (buffer+pos) ) );
            buffer += sizeof (apr_uint16_t);
            $(name:c) = buffer + pos;
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %ld B\\n", (long) $(name:c)_size);
#           endif
            pos += $(name:c)_size;
            if (command_length + 1 >= buffer_size) 
                return AMQ_BUFFER_OVERFLOW;
            memmove (buffer + pos + 1, buffer + pos, full_size - pos);
            buffer [pos] = 0;
            pos++;
            full_size++;

.    elsif "$(type)" = "bit"
            $(name:c) =
                ( ( (apr_byte_t) buffer [pos] ) >> $(bitshift))&0x01;
.        bitshift = bitshift + 1
.        if "$(bitshift)" = "8"
.            bitshift = 0
            pos += sizeof (apr_byte_t);
.        endif
#           if defined(AMQTRACE)
                fprintf (stderr, "    $(name) = %ld\\n", (long) $(name:c));
#           endif

.    else
.        echo "'$(type)' : unsupported type"
.    endif
.endmacro

.macro generate_interface ()
.output "amqp_level0.h"
/*---------------------------------------------------------------------------
 *  amqp_level0.h - headers for AMQP client API (Level 0)
 *
 *  Generated from amq_frames.xml by amqp_level0.gsl using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004-2005 JPMorgan
 *  Copyright (c) 1991-2005 iMatix Corporation
 *---------------------------------------------------------------------------*/

#include "base_apr.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*  error value received when frame non coforming to  */
/*  AMQP protocol is received from the server.  */
#define AMQ_FRAME_CORRUPTED (APR_OS_START_USERERR + 0)
/*  error value received when supplied buffer is too small to either :  */
/*      1. store whole frame received from the server  */
/*      2. store whole frame to be sent to the server  */
#define AMQ_BUFFER_OVERFLOW (APR_OS_START_USERERR + 1)

.for frame where defined (frame->sender (role = "server") )
/*  prototype of callback function corresponding to '$(name)' command  */
typedef apr_status_t (*amqp_$(name:c)_t) (
    const void *hint /*  hint passed to amqp_recv  */,\
.    for field where "$(name)" <> "type" & ("$(frame.name)" <> "handle notify" | "$(name)" <> "fragment size")

.        makectypesize ("    ", ",", "1", "0", "1") 
.        makectype ("    ", "1", "0", "1") 
$(!last()??","?)\
.    endfor
.    if "$(name)" = "handle notify"
,\
.        for frames.frame where name = "message head"
.            for field

.                makectypesize ("    ", ",", "1", "0", "1")
.                makectype ("    ", "1", "0", "1") 
,\
.            endfor
.        endfor

    char *data\
.    endif

    );

.endfor
/*  structure that keeps callback function pointers  */
/*  if field is equal to NULL, no callback will be called  */
typedef struct
{
.for frame where defined (frame->sender (role = "server") )
    amqp_$(name:c)_t $(name:c);
.endfor
} amqp_callbacks_t;

/*  ---------------------------------------------------------------------[<]-
    Function: amqp_init

    Synopsis:
    Sends initiation bytes to the server.
    ---------------------------------------------------------------------[>]-*/
apr_status_t amqp_init (
    apr_socket_t *socket /*  amqp socket  */
    );

/*  ---------------------------------------------------------------------[<]-
    Function: amqp_term

    Synopsis:
    Uninitializes AMQP client API (dummy function for now)
    ---------------------------------------------------------------------[>]-*/
apr_status_t amqp_term (
    apr_socket_t *socket /*  amqp socket  */
    );

/*  ---------------------------------------------------------------------[<]-
    Function: amqp_recv

    Synopsis:
    Dispatches single command to apropriate callback funcgion (if registered).
    ---------------------------------------------------------------------[>]-*/
apr_status_t amqp_recv (
    apr_socket_t *socket /*  amqp socket  */,
    char *buffer /*  buffer used to store the command  */,
    apr_size_t buffer_size /*  buffer size  */,
    amqp_callbacks_t *callbacks /*  contians pointers to callback functions for individual commands  */,
    void *hint /*  hint to be passed to callback function  */
    );
    
.for frame where defined(frame->sender(role="client"))
/*  ---------------------------------------------------------------------[<]-
    Function: amqp_$(name:c)

    Synopsis:
    Sends $(name) command to the server.
    ---------------------------------------------------------------------[>]-*/
.    makeheader ("1")
;

.endfor
/*  ---------------------------------------------------------------------[<]-
    Function: amqp_strerror

    Synopsis:
    Translates error code into human readable string.
    ---------------------------------------------------------------------[>]-*/
char *amqp_strerror (
    apr_status_t statcode /*  status to be translated to string  */,
    char *buffer /*  buffer to hold the result  */,
    apr_size_t buffer_size /*  buffer size  */
    );
.endmacro

.macro generate_implementation ()
.output "amqp_level0.c"
/*---------------------------------------------------------------------------
 *  amqp_level0.c - implementation for AMQP client API (Level 0)
 *
 *  Generated from amq_frames.xml by amqp_level0.gsl using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004-2005 JPMorgan
 *  Copyright (c) 1991-2005 iMatix Corporation
 *---------------------------------------------------------------------------*/

#include "amqp_level0.h"

.for frame where name <> "message head"
#define AMQP_$(name:c,UPPER)_TYPE $(frame->field (name = "type").value)
.endfor

apr_status_t amqp_init (
    apr_socket_t *socket
    )
{
    apr_status_t
        result;
    char
        data [2];
    apr_size_t
        sz;

    /*  send initiation bytes to server  */
    data [0] = (char) 128;
    data [1] = (char) 1;
    sz = 2;
    result = apr_socket_send (socket, data, &sz);
    if (result != APR_SUCCESS)
        return result;
    return APR_SUCCESS;
};

apr_status_t amqp_term (
    apr_socket_t *socket
    )
{
    return APR_SUCCESS;
};

apr_status_t amqp_recv (
    apr_socket_t *socket,
    char *buffer,
    apr_size_t buffer_size,
    amqp_callbacks_t *callbacks,
    void *hint
    )
{
    apr_status_t
        result;
    apr_uint32_t
        command_length = 0;
    apr_uint32_t
        full_size = 0;
    apr_uint32_t
        pos = 0;
    apr_size_t
        sz;
    apr_byte_t
        frame_type;

    /*  get all frame data from socket  */
    sz = sizeof (apr_uint16_t);
    result = apr_socket_recv (socket, buffer, &sz);
    if(result != APR_SUCCESS)
        return result;
    pos += sizeof (apr_uint16_t);
    command_length = ntohs (*( (apr_uint16_t *) buffer) );
    full_size = command_length + sizeof (apr_uint16_t);
    if (command_length == 0xffff) {
        sz = sizeof (apr_uint32_t);
        result = apr_socket_recv (socket, buffer + pos, &sz);
        if (result!=APR_SUCCESS)
            return result;
        pos += sizeof (apr_uint32_t);
        command_length =
            ntohl (*( (apr_uint32_t*) (buffer + sizeof(apr_uint16_t) ) ) );
        full_size = command_length + sizeof (apr_uint16_t) + sizeof (apr_uint32_t);
    }
    if (command_length > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
    sz = command_length;
    result = apr_socket_recv (socket, buffer + pos, &sz);
    if (result != APR_SUCCESS) return result;
    if (*(apr_byte_t *) (buffer + pos + command_length - sizeof (apr_byte_t) ) != (apr_byte_t) 0xce)
        return AMQ_FRAME_CORRUPTED;

    /*  parse individual command types  */
    frame_type = (apr_byte_t) buffer [pos];
    pos += sizeof(apr_byte_t);
    switch (frame_type)
    {
.- generates code to dispatch individual frame type
.for frame where defined (frame->sender (role = "server") )
    case AMQP_$(name:c,UPPER)_TYPE:
        {
            /*  decodes and dispatches '$(name)' command  */

.    bitshift = 0
.    for field where "$(name)" <> "type"
.        makectypesize ("            ", ";", "0", "1", "0")
.        makectype ("            ", "0", "1", "0")
;
.    endfor
.    if "$(name)" = "handle notify"
.        for frames.frame where name = "message head"
.            for field
.                makectypesize ("            ", ";", "0", "1", "0")
.                makectype ("            ", "0", "1", "0")
;
.            endfor
.        endfor
            char*
                data;
.    endif

.    for field where "$(name)" <> "type"
.        readargument()
.    endfor
.- handle notify frame is followed by message head
.- following lines generate code to decode it
.    if "$(name)" = "handle notify"
.        for frames.frame where name = "message head"
            /*  decodes message head  */
            sz = fragment_size;
            result = apr_socket_recv (socket, buffer + pos, &sz );
            if (result != APR_SUCCESS)
                return result;
            full_size = pos + fragment_size;

.            for field
.                readargument()
.            endfor
.        endfor
            /*  decodes message data  */
            data = (char *) (buffer + pos);
            pos += body_size;

.    endif
            /*  dispatches command  */
#           if defined(AMQTRACE)
                fprintf (stderr, "$(name) received.\\n\\n"); 
#           endif
            if (callbacks->$(name:c))
                return callbacks->$(name:c) (
                    hint,\
.    for field where "$(name)" <> "type" & ("$(frame.name)" <> "handle notify" | "$(name)" <> "fragment size")

.        if "$(type)" = "longstr" | "$(type)" = "table"
                    $(name:c)_size,
.        endif
                    $(name:c)$(!last()??","?)\
.    endfor
.    if "$(name)" = "handle notify"
,
.        for frames.frame where name = "message head"
.            for field
.                if "$(type)" = "longstr" | "$(type)" = "table"
                    $(name:c)_size,
.                endif
                    $(name:c),
.            endfor
.        endfor
                    data\
.    endif

                    );
            else return APR_SUCCESS;
        }
.endfor
    default:
        return AMQ_FRAME_CORRUPTED;
    }
};

.- generates functions to send individual command types to server
.for frame where defined(frame->sender(role="client"))
.    makeheader ("0")

{
    apr_status_t
        result;
    apr_uint32_t
        pos = sizeof (apr_uint16_t) + sizeof(apr_uint32_t);
    apr_uint32_t
        len = 0;
    apr_size_t
        sz;
    const apr_byte_t
        type = AMQP_$(name:c,UPPER)_TYPE;
    apr_uint32_t
        start_pos;
.    if "$(name)" = "handle send"
    apr_uint32_t
        fragment_size_pos;
    apr_uint32_t
        fragment_size = 0;
    apr_uint32_t
        message_head_pos;
.    endif

    /*  writes '$(name)' command into buffer  */

.    bitshift = 0
.    for field
.        if "$(frame.name)" = "handle send" & "$(name)" = "fragment size"
    fragment_size_pos = pos;
.        endif
.        writeargument()
.    endfor
.    if "$(bitshift)" <> "0"
.        bitshift = 0
    pos += sizeof (apr_byte_t);
.    endif
    /*  writes terminal byte into buffer  */
    if (pos + sizeof(apr_byte_t) > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
    buffer [pos] = (apr_byte_t) 0xce;
    pos += sizeof (apr_byte_t);

    /*  adjusts size  */
    if (pos - sizeof (apr_uint32_t) - sizeof (apr_uint16_t) < 0xffff) {
        *( (apr_uint16_t *) (buffer + sizeof (apr_uint32_t) ) ) =
            htons ( (apr_uint16_t) (pos - sizeof (apr_uint32_t) - sizeof (apr_uint16_t) ) );
        start_pos = sizeof (apr_uint32_t);
    }
    else {
        *( (apr_uint16_t *) buffer) = 0xffff;
        *( (apr_uint32_t *) (buffer + sizeof (apr_uint16_t) ) ) =
            htonl (pos - sizeof (apr_uint32_t) - sizeof (apr_uint16_t) );
        sz = pos;
        start_pos = sizeof (apr_uint16_t);
    }
.- handle send command is followed by message head
.- following lines generate code to write it into buffer
.    if "$(name)" = "handle send"
    
    /*  writes message head  */
	message_head_pos = pos;

.        bitshift = 0
.        for frames.frame where name = "message head"
.            for field
.                writeargument()
.            endfor
.        endfor
    /*  writes message data  */
    if (pos + body_size > buffer_size)
        return AMQ_BUFFER_OVERFLOW;
    memmove (buffer + pos, data, body_size);
    pos += body_size;
.    endif
.    if "$(name)" = "handle send"

    /*  adjusts fragment size  */
    *( (apr_uint32_t*) (buffer + fragment_size_pos) ) =
        htonl (pos - message_head_pos);
.    endif

    /*  sends command to server  */
    sz = pos - start_pos;
    result = apr_socket_send (socket, buffer + start_pos, &sz);
    if (result != APR_SUCCESS)
        return result;
#   if defined(AMQTRACE)
        fprintf (stderr, "$(name) issued.\\n\\n");
#   endif

    return APR_SUCCESS;
};

.endfor
char *amqp_strerror (
    apr_status_t statcode,
    char *buffer,
    apr_size_t buffer_size
    )
{
    const char*
        str = NULL;

    switch (statcode)
    {
    case AMQ_FRAME_CORRUPTED:
        str = "Received corrupted frame.";
        break;
    case AMQ_BUFFER_OVERFLOW:
        str = "Received or trying to send frame bigger than available buffer.";
        break;
    default:
        return apr_strerror (statcode, buffer, buffer_size);
    }
    return strncpy(buffer, str, buffer_size);
}
.endmacro


#
#  Main Program 
#
generate_interface ()
generate_implementation ()

endtemplate  
