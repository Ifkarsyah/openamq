.-------------------------------------------------------------------------------
.- amq_stdc_framing.gsl - source file that generates AMQP/C client API
.- gsl -script:amq_stdc_framing.gsl amq_frames.xml
.-
.- Copyright (c) 2004-2005 JPMorgan
.- Copyright (c) 1991-2005 iMatix Corporation
.-------------------------------------------------------------------------------
.template 1
.macro make_size ()
.    if "$(type)" <> "bit"
.        if bitshift <> 0
sizeof (byte) + \
.            bitshift = 0
.        endif
.    endif
.    if "$(type)" = "octet"
sizeof (byte) + \
.    elsif "$(type)" = "shortstr"
sizeof (byte) + \
.    elsif "$(type)" = "longstr" | "$(type)" = "table"
sizeof (dbyte) + \
.    elsif "$(type)" = "shortint"
sizeof (dbyte) + \
.    elsif "$(type)" = "longint"
sizeof (qbyte) + \
.    elsif "$(type)" = "bit"
.        bitshift = bitshift + 1
.        if bitshift = 8
sizeof (byte) + \
.            bitshift = 0
.        endif
.    else
.        abort "'$(type)' : unsupported type"
.    endif
.endmacro
.macro make_varsize ()
.    if "$(type)" = "shortstr" | "$(type)" = "longstr" | "$(type)" = "table"
 + $(name:c)_size\
.    endif
.endmacro
.macro make_field ()
.    if "$(type)" = "octet"
    byte $(name:c);
.    elsif "$(type)" = "shortstr"
    byte $(name:c)_size;
    const char *$(name:c);
.    elsif "$(type)" = "longstr" | "$(type)" = "table"
    dbyte $(name:c)_size;
    const char *$(name:c);
.    elsif "$(type)" = "shortint"
    dbyte $(name:c);
.    elsif "$(type)" = "longint"
    qbyte $(name:c);
.    elsif "$(type)" = "bit"
    byte $(name:c);
.    else
.        abort "'$(type)' : unsupported type"
.    endif
.endmacro
.macro make_arg ()
.    if "$(type)" = "octet"
    byte $(name:c)\
.    elsif "$(type)" = "shortstr"
    byte $(name:c)_size,
    const char *$(name:c)\
.    elsif "$(type)" = "longstr" | "$(type)" = "table"
    dbyte $(name:c)_size,
    const char *$(name:c)\
.    elsif "$(type)" = "shortint"
    dbyte $(name:c)\
.    elsif "$(type)" = "longint"
    qbyte $(name:c)\
.    elsif "$(type)" = "bit"
    byte $(name:c)\
.    else
.        abort "'$(type)' : unsupported type"
.    endif
.endmacro
.macro make_decoder (frame)
.    if "$(type)" <> "bit"
.        if bitshift <> 0
.            bitshift = 0
        pos += sizeof (byte);
.        endif
.    endif
.    if "$(type)" = "octet"
        if (pos + sizeof (byte) > size)
            return 0;
        $(my.frame)$(name:c) = *((byte*) (buffer + pos));
        pos += sizeof (byte);
.    elsif "$(type)" = "shortstr"
        if (pos + sizeof (byte) > size)
            return 0;
        $(my.frame)$(name:c)_size = *((byte*) (buffer + pos));
        pos += sizeof (byte);
        if (pos + $(my.frame)$(name:c)_size > size)
            return 0;
        $(my.frame)$(name:c) = buffer + pos;
        pos += $(my.frame)$(name:c)_size;
.    elsif "$(type)" = "longstr" | "$(type)" = "table"
        if (pos + sizeof (dbyte) > size)
            return 0;
        GET_SHORT ($(my.frame)$(name:c)_size, buffer + pos)
        pos += sizeof (dbyte);
        if (pos + $(my.frame)$(name:c)_size > size)
            return 0;
        $(my.frame)$(name:c) = buffer + pos;
        pos += $(my.frame)$(name:c)_size;
.    elsif "$(type)" = "shortint"
        if (pos + sizeof (dbyte) > size)
            return 0;
        GET_SHORT ($(my.frame)$(name:c), buffer + pos)
        pos += sizeof (dbyte);
.    elsif "$(type)" = "longint"
        if (pos + sizeof (qbyte) > size)
            return 0;
        GET_LONG ($(my.frame)$(name:c), buffer + pos)
        pos += sizeof (qbyte);
.    elsif "$(type)" = "bit"
.        if bitshift = 8
.            bitshift = 0
        pos += sizeof (byte);
.        endif
.        if bitshift = 0
        if (pos + sizeof (byte) > size)
            return 0;
.        endif
        $(my.frame)$(name:c) = (*((byte*) (buffer + pos)) >> $(bitshift)) & 0x01;
.        bitshift = bitshift + 1
.    else
.        abort "'$(type)' : unsupported type"
.    endif
.endmacro
.macro make_encoder ()
.    if "$(type)" <> "bit"
.        if bitshift <> 0
.            bitshift = 0
    buffer += sizeof (byte);
.        endif
.    endif
.    if "$(type)" = "octet"
    *((byte*) buffer) = $(name:c);
    buffer += sizeof (byte);
.    elsif "$(type)" = "shortstr"
    *((byte*) buffer) = $(name:c)_size;
    buffer += sizeof (byte);
    memcpy ((void*) buffer, (void*) $(name:c), $(name:c)_size);
    buffer += $(name:c)_size;
.    elsif "$(type)" = "longstr" | "$(type)" = "table"
    PUT_SHORT (buffer, $(name:c)_size)
    buffer += sizeof (dbyte);
    memcpy ((void*) buffer, (void*) $(name:c), $(name:c)_size);
    buffer += $(name:c)_size;
.    elsif "$(type)" = "shortint"
    PUT_SHORT (buffer, $(name:c));
    buffer += sizeof (dbyte);
.    elsif "$(type)" = "longint"
    PUT_LONG (buffer, $(name:c));
    buffer += sizeof (qbyte);
.    elsif "$(type)" = "bit"
.        if bitshift = 8
.            bitshift = 0
    buffer += sizeof (byte);
.        endif
.        if bitshift = 0
    *((byte*) buffer) = 0;
.        endif
    *((byte*) buffer) |= ($(name:c) ? 1 : 0) << $(bitshift);
.        bitshift = bitshift + 1
.    else
.        abort "'$(type)' : unsupported type"
.    endif
.endmacro
.output "amq_stdc_framing.h"
/*---------------------------------------------------------------------------
 *  amq_stdc_framing.h - headers for AMQP client API (Level 0)
 *
 *  Generated from amq_frames.xml by amq_stdc_framing_old.gsl using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004-2005 JPMorgan
 *  Copyright (c) 1991-2005 iMatix Corporation
 *---------------------------------------------------------------------------*/

#ifndef AMQ_STDC_FRAMING_INCLUDED
#define AMQ_STDC_FRAMING_INCLUDED

#include "base.h"

#define GET_SHORT(host, net) \\
    (host) = ((net) [0] << 8) + (net) [1];

#define GET_LONG(host, net) \\
    (host) = ((net) [0] << 24) + ((net) [1] << 16) + ((net) [2] << 8) + (net) [3];

#define PUT_SHORT(net, host) \\
    (net) [0] = (byte) (((host) >> 8) & 255); \\
    (net) [1] = (byte) ((host)      & 255);

#define PUT_LONG(net, host) \\
    (net) [0] = (byte) (((host) >> 24) & 255); \\
    (net) [1] = (byte) (((host) >> 16) & 255); \\
    (net) [2] = (byte) (((host) >> 8)  & 255); \\
    (net) [3] = (byte) ((host)       & 255);

#define COMMAND_SIZE_MAX_SIZE \\
    (sizeof (dbyte) + sizeof (qbyte))
.for frame where name <> "message head"
#define AMQ_STDC_$(name:c,UPPER)_CONSTANT_SIZE \\
    (\
.    bitshift = 0
.    for field
.        make_size ()
.    endfor
.    if bitshift <> 0
sizeof (byte) + \
.    endif
sizeof (byte))
.endfor
.for frame where name = "message head"
#define AMQ_STDC_$(name:c,UPPER)_CONSTANT_SIZE \\
    (\
.    bitshift = 0
.    for field
.        make_size ()
.    endfor
.    if bitshift <> 0
sizeof (byte) + \
.    endif
0)
.endfor

typedef enum
{
.for frame where name <> "message head"
    amq_stdc_$(name:c)_type = $(frame->field (name = "type").value)$(!last()??","?)
.endfor
} amq_stdc_frame_type_t;

.for frame
typedef struct
{
.for field where name <> "type"
.    make_field ()
.endfor
} amq_stdc_$(name:c)_t;

.endfor

typedef struct
{
    amq_stdc_frame_type_t type;
    union
    {
.for frame where name <> "message head"
        amq_stdc_$(name:c)_t $(name:c);
.endfor
    } fields;
} amq_stdc_frame_t;

qbyte amq_stdc_decode_command (
    const char *buffer,
    qbyte size,
    amq_stdc_frame_t *frame
    );

.for frame where name = "message head"
qbyte amq_stdc_decode_$(name:c) (
    const char *buffer,
    qbyte size,
    amq_stdc_$(name:c)_t *frame
    );

.endfor

.for frame
qbyte amq_stdc_encode_$(name:c) (
    char *buffer,
    qbyte size,
.    for field where name <> "type"
.        make_arg ()
$(!last()??","?)
.    endfor
    );

.endfor
#endif
.close
.output "amq_stdc_framing.c"
/*---------------------------------------------------------------------------
 *  amq_stdc_framing.c - implementation for AMQP client API
 *
 *  Generated from amq_frames.xml by amq_stdc_framing.gsl using GSL/4.
 *  DO NOT MODIFY THIS FILE.
 *
 *  For documentation and updates see http://www.imatix.com.
 *  Copyright (c) 2004-2005 JPMorgan
 *  Copyright (c) 1991-2005 iMatix Corporation
 *---------------------------------------------------------------------------*/

#include "amq_stdc_framing.h"

qbyte amq_stdc_decode_command (
    const char *buffer,
    qbyte size,
    amq_stdc_frame_t *frame
    )
{
    qbyte
        pos = 0;

    if (pos + sizeof (byte) > size)
        return 0;
    frame->type = *((byte*) (buffer + pos));
    pos += sizeof (byte);
    switch (frame->type)
    {
.for frame where name <> "message head"
    case amq_stdc_$(name:c)_type:
.    bitshift = 0
.    for field where name <> "type"
.        make_decoder ("frame->fields.$(frame.name:c).")
.    endfor
.    if bitshift <> 0
        pos += sizeof (byte);
.    endif
        break;
.endfor
    default:
        return 0;
    }
    if (pos + sizeof (byte) > size)
        return 0;
    if (*((byte*) (buffer + pos)) != 0xce)
        return 0;
    pos += sizeof (byte);
    return pos;
}

.for frame where name = "message head"
qbyte amq_stdc_decode_$(name:c) (
    const char *buffer,
    qbyte size,
    amq_stdc_$(name:c)_t *frame
    )
{
    qbyte
        pos = 0;

.    bitshift = 0
.    for field
.        make_decoder ("frame->")
.    endfor
.    if bitshift <> 0
        pos += sizeof (byte);
.    endif
    return pos;
}

.endfor
#define ENCODE_SIZE \\
    if (sz < 0xffff) {\\
        if (sz + sizeof (dbyte) > size)\\
            return 0;\\
        PUT_SHORT (buffer, sz)\\
        buffer += sizeof (dbyte);\\
        sz += sizeof (dbyte);\\
    }\\
    else {\\
        if (sz + sizeof (dbyte) + sizeof (qbyte) > size)\\
            return 0;\\
        PUT_SHORT (buffer, 0xffff)\\
        buffer += sizeof (dbyte);\\
        PUT_LONG (buffer, sz)\\
        buffer += sizeof (qbyte);\\
        sz += sizeof (dbyte) + sizeof (qbyte);\\
    }

.for frame
qbyte amq_stdc_encode_$(name:c) (
    char *buffer,
    qbyte size,
.    for field where name <> "type"
.        make_arg ()
$(!last()??","?)
.    endfor
    )
{
    qbyte
        sz = AMQ_STDC_$(name:c,UPPER)_CONSTANT_SIZE\
.    for field where name <> "type"
.        make_varsize ()
.    endfor
;

.    if "$(name)" <> "message head"
    ENCODE_SIZE
    *((byte*) buffer) = amq_stdc_$(name:c)_type;
    buffer += sizeof (byte);
.    endif
.    bitshift = 0
.    for field where name <> "type"
.        make_encoder ()
.    endfor
.    if bitshift <> 0
    buffer += sizeof (byte);
.    endif
.    if "$(name)" <> "message head"
    *((byte*) buffer) = 0xce;
    buffer += sizeof (byte);
.    endif
    return sz;
}

.endfor
.close
.endtemplate
