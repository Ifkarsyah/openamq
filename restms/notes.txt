use routing-key@feed.name addressing form?

selectors
    - how to do query?
identify selectors properly
    - using pipe argument
invoke create, destroy selectors

post message to sink with address
create private queue per pipe
    - use pipe name as private queue name
    - make automatic connection scoping
for exchange selectors, bind pipe's private queue
for queue selectors, consume from shared queue
    - use pipe name as consumer tag
arrived message processing
    - queue name = pipe name, put to pipe list
    - queue name = private queue, use consumer tag as pipe name

GET /
    returns set of containers defined
    returns XML content
        <restms version="1.0" status="ok">
          <container type="pipe" uri="http://localhost/pipe" />
          <container type="sink" uri="http://localhost/sink"
            types = "fanout direct topics header service selector" />
        <rest>

PUT /pipe
    creates a new pipe resource
    returns XML content
        <restms version="1.0" status="ok">
          <pipe uri="http://localhost/pipe/name" />
        <rest>

GET /pipe
    gets information about container
    returns XML content
        <restms version="1.0" status="ok">
          <container type="pipe" size="[size]" />
        <rest>

PUT /pipe/{name}
    creates a new pipe resource
    returns XML content
        <restms version="1.0" status="ok">
          <pipe name="name" uri="http://localhost/pipe/name" />
        <rest>

GET /pipe/{name}
    gets information about the pipe
    gets a list of all waiting messages
    returns XML content
        <restms version="1.0" status="ok">
          <pipe name="name" uri="http://localhost/pipe/name">
            <message uri="http://localhost/pipe/name/[nbr]" />...
          </pipe>
        <rest>
    => NOTFOUND if not known

DELETE /pipe/{name}
    deletes pipe resource
    returns XML content
        <restms version="1.0" status="ok" />
    idempotent, pipe does not need to exist

POST /pipe/{name}
    => BADREQUEST

PUT /sink/{path}?type={type}
    creates sink, idempotent
    returns XML content
        <restms version="1.0" status="ok">
          <sink name="{name}" uri="http://localhost/sink/{name}" />
        <rest>

GET /sink/{path}
    queries sink
    returns XML content
        <restms version="1.0" status="ok">
          <sink name="{name}" uri="http://localhost/sink/{name}" />
        <rest>
    => NOTFOUND if not known

DELETE /sink/{path}
    deletes sink
    returns XML content
        <restms version="1.0" status="ok" />
    idempotent, pipe does not need to exist

PUT /sink/{path}/{selector}#{pipename}
    create selector
    selector syntax depends on sink type
    Defined in RestMS/AMQP mapping:
        - for rotators, services, ignored
        - for fanout, ignored
        - for direct, string
        - for topic, topic pattern
        - for headers, ignored (need header spec)
    idempotent
    both sink and pipe must exist

GET /sink/{path}/{selector}#{pipename}
    returns information on selector
    returns XML content
        <restms version="1.0" status="ok">
            <sink name="{name}" uri="{uri}">
                <pipe="{name}" selector="{selector}" />
            </sink>
        </restms>
    idempotent
    both sink and pipe must exist

DELETE /sink/{path}/{selector}#{pipename}
    deletes the selector
    returns XML content
        <restms version="1.0" status="ok" />
    idempotent
    neither sink nor pipe need to exist



^^^^^ IMPLEMENTED ^^^^^

Manipulating sink resources

POST /sink/{path}/{address}
    post "sink/sink-name/address"
    posts a message to the sink
    address is routing key for exchanges
    address is message-id for queues
    address may be empty
    expects body data, content-type

Manipulating selectors in sinks:

^^^^^ NEXT ^^^^^

Zyre - an open source RestMS implementation

++ The RESTful Messaging Service (RestMS)

"All REST interactions are stateless. That is, each request contains all of the information necessary for a connector to understand the request, independent of any requests that may have preceded it."

++ Introduction

RestMS is a RESTful messaging service designed for web applications.  A RestMS application can be as simple as this fully working "Hello World!" example:

[[code]]
#!/usr/bin/perl
#   Hello World application for RestMS
#
use LWP::UserAgent;
my $ua = new LWP::UserAgent;
$ua->agent ('Perl');
$ua->credentials ("localhost", "RestMS", "guest", "guest");

#   Create a fanout feed called 'ping', create a pipe called 'hello' and
#   connect the feed to the pipe using a wildcard tap expression.
my $request = HTTP::Request->new (
    PUT => "http://localhost/restms/fanout/ping/*?pipe=hello");
my $response = $ua->request ($request);
die if $response->code != 200;

#   Post "Hello World!" to the ping feed
my $request = HTTP::Request->new (
    POST => "http://localhost/restms/fanout/ping");
$request->content("Hello World!\n");
my $response = $ua->request ($request);
die if $response->code != 200;

#   Message goes into feed and then comes back to our pipe
my $request = HTTP::Request->new (
    GET => "http://localhost/restms/pipe/hello/");
my $response = $ua->request ($request);
die if $response->code != 200;
print $response->content;
[[/code]]

RestMS aims to:

* Deliver a properly RESTful messaging service with all the advantages of the RESTful model.
* Be easy to use in any programming language, for any application, on any platform.
* Be interoperable with enterprise messaging products like OpenAMQ.

RestMS uses URIs to address a set of resources.  Applications create, use, and delete these resources.  RestMS URIs are standard HTTP URIs, and RestMS is designed to be built into a web server as an extension or URL handler.  In our hello world example, and by convention, the URI paths start with "/restms".

RestMS uses a simple loosely-coupled message model based on these key types of resource:

* A "feed" is a stream of messages that is filled at one end by publishing applications, and used at the other end by subscriber applications.
* A "pipe" is a stream of messages that is filled from a feed, and made available to applications.
* A "tap" connects a pipe to a feed and tells the feed precisely what messages should go into the pipe.

The difference between a feed and a pipe may not be immediately clear.  Both feeds and pipes acts like first-in-first-out queues, but they do different types of work.  Feeds are mainly concerned with routing and fanning out messages to many applications, while pipes are mainly concerned with supplying messages to a single application.  In a distributed network, feeds will be close to publishers, and pipes will be close to subscribers.  Feeds are public resources, pipes are usually private to a single application.  Finally, feeds have sophisticated semantics for deciding what messages go where, while pipes do not.

++ Feeds

The URL for a feed takes this form:

[[code]]
/restms/{feed-class}/{feed-name}
[[/code]]

The set of valid feed classes, and their meaning, is implementation dependent.  Each feed class defines a particular set of semantics for the feeds it contains.  Applications can create and delete feeds at runtime.  Feeds may also be created automatically by implementations.

The valid methods on feeds are:

* PUT - creates a feed of the specified class, with the specified name.  The method is idempotent (it can be repeated with no further effect).
* GET - queries the specified feed.  The method returns information about the feed.  It is idempotent and has no side effects.
* DELETE - deletes the specified feed.  This method is idempotent.
* POST - posts a message to the specified feed.  This is how publishers send data to other applications.

The POST method uses this syntax for the URL:

[[code]]
/restms/{feed-class}/{feed-name}/{address}
[[/code]]

Where the address tells the feed how to route the message.  For example, implementations may route messages by matching addresses to tap expressions.  The address may be empty.

Further, applications can also use these methods on feed classes:

* GET - queries the feed class.  This method returns the set of feeds defined in that class.  It is idempotent and has no side effects.

++ Pipes

The URL for a pipe takes this form:

[[code]]
/restms/{pipe-class}/{pipe-name}
[[/code]]

The set of valid pipe classes, and their meaning, is implementation dependent.  Each pipe class defines a particular set of semantics for the pipes it contains.  Applications can create and delete pipes at runtime.

The valid methods on pipes are:

* PUT - creates a pipe of the specified class and name.  The method is idempotent.
* GET - queries the specified pipe.  The method returns information about the pipe.  It is idempotent and has no side effects.
* DELETE - deletes the specified pipe.  This method is idempotent.

Applications should delete pipes when they are finished using them.  However, implementations may delete unused or overflowing pipes automatically.

++ Taps

Taps are contained in feeds, and the basic URL for a tap consists of a feed URL followed by a tap expression.  A tap always refers to a specific pipe, which we specify in the URL arguments:

[[code]]
/restms/{feed-class}/{feed-name}/{tap-expression}?{pipe-class}={pipe-name}
[[/code]]

The valid methods on taps are:

* PUT - creates a tap as specified.  The method is idempotent.  The pipe is created if necessary.
* GET - queries the specified tap.  This method is idempotent and has no side effects.
* DELETE - deletes the specified tap.  This method is idempotent.

Tap expressions are paths and their syntax and meaning depend on the feed class.  A tap expression may be empty.  Note the difference between the URL for a feed with an empty tap expression, and the URL for a tap:

[[code]]
/restms/{feed-class}/{feed-name}
/restms/{feed-class}/{feed-name}/?{pipe-class}={pipe-name}
[[/code]]

++ Messages

Messages are contained in pipes, and the basic URL for a message consists of a pipe URL followed by a message selector:

[[code]]
/restms/{pipe-class}/{pipe-name}/{message-selector}
[[/code]]

The valid methods on messages are:

* GET - retrieves the specified message or messages.  This method is idempotent and has no side effects, if a selector is specified.
* DELETE - deletes the specified message or messages.  This method is idempotent.

The message selector specifies which messages to retrieve or delete.  Messages are indexed on the pipe, from 1 (the first message the pipe receives) upwards.  The message selector can be a single message index (to specify one message), an open-ended range (to specify all waiting messages starting from the index), or a range (to specify an exactly list of messages):

[[code]]
/restms/{pipe-class}/{pipe-name}/{index}
/restms/{pipe-class}/{pipe-name}/{index}-
/restms/{pipe-class}/{pipe-name}/{index}-{end-index}
[[/code]]

Messages are held in the pipe for a reasonable period, which is implementation dependent.  Implementations may arbitrarily delete read, or unread messages, if applications do not fetch them promptly.  If a pipe is deleted, any messages it still holds are also deleted.

Applications have a choice of techniques for fetching and deleting messages.  The simplest is to use alternate GET and DELETE methods.  High performance applications can use an open-ended GET to receive a stream of messages, and then delete them using range DELETEs, on a separate HTTP connection.

Applications can also GET a message using an empty selector:

[[code]]
/restms/{pipe-class}/{pipe-name}/
[[/code]]

This method is NOT idempotent, and has the side effect of immediately deleting the message.  The empty selector breaks the strict RESTful rules but makes it possible for more than one application to share a single pipe, and to use the simplest possible technique for fetching messages.

++ Summary of URLs

This table shows the different URL types and the methods they allow:

|| Root         || /restms || GET ||
|| Feed class   || /restms/{feed-class} || GET ||
|| Feed         || /restms/{feed-class}/{feed-name} || PUT, GET, DELETE ||
|| Feed address || /restms/{feed-class}/{feed-name}/{address} || POST ||
|| Pipe         || /restms/{pipe-class}/{pipe-name} || PUT, GET, DELETE ||
|| Tap          || /restms/{feed-class}/{feed-name}/{tap-expression}?{pipe-class}={pipe-name} PUT, GET, DELETE ||
|| Message      || /restms/{pipe-class}/{pipe-name}/{message-selector} || GET, DELETE ||






Manipulating messages in pipes

Messages received from the server are sorted into pipe queues.  This is done as a side effect of any access to the pipe.  Messages are sorted using their consumer-tags, which are their pipe number.

In Rest style, we get the container information which would list all waiting messages and then we would get those messages one by one, delete them, etc.:

GET /pipe/pipenbr/msgid
    get "pipe/nbr/msgid"
    gets the message specified
    implementation:
        - must be next message on pipe
        - waits
DELETE /pipe/pipenbr/msgid
    delete "pipe/nbr/msgid"
    deletes the message and all prior messages (gone off the pipe), (ack)
PUT /pipe/pipenbr/msgid
    put "pipe/pipenbr/msgid"
    rejects the message (nack)
POST /pipe/pipenbr/msgid
    post "pipe/pipenbr/msgid"
    => not allowed

msgid's are incremental, so the application can guess them if it is the only one using the pipe.  It must still do DELETE to remove from pipe.  We allow deleting a range by specifying the highest message id to delete.

++ Sinks

Sinks are where we post messages.  Sinks are also containers for selectors, which is how we get messages into our pipes. All visible exchanges and shared queues are exposed as sinks.


++ Internal

- each pipe needs a matching private queue on server
    - to allow many pipes to grab same messages
    - will need to redesign direct mode pipes / sinks
    - maybe: don't use direct mode for RestMS?
        - if use it, faster message transfer
        - if not use it, single server connection

++ Scenarios

POST /sink.topic/nasdaq.imatix + content

PUT /sink/stocks/?type=topic
POST /sink/stocks/nasdaq.imatix + content

PUT /pipe
S: /pipe/1
GET /pipe/1/1
S: message

config
    amqp server name
    amqp server login and password
    client logins
        - basic auths
        - not same as openamq credentials

- if-modified-since
- cache-control
- last-modified-time

=====

Not supported:

* Does not allow binding arguments (headers) yet.

RESTful extensions to AMQP
    - RestMS protocol class
    - / in topics equivalent to ., both in bind and publish
    - * in topics matches empty routing-key
    - empty topic segments are allowed (.value or /value)
    - Basic.Consume is assertive, idempotent
        - note that must not allow same tag on different queues
    - Queue.Declare private queues are scoped per connection
        - names uniquified on server, automatically
        - in declare, consume, cancel, bind, delete
