GET /
    returns set of containers defined
    returns XML content
        <amqprest version="1.0" status="ok">
          <container type="feed" uri="http://localhost/feed" />
          <container type="sink" uri="http://localhost/sink"
            types = "fanout direct topics header service selector" />
        <rest>

PUT /feed
    creates a new feed resource
    returns XML content
        <amqprest version="1.0" status="ok">
          <feed uri="http://localhost/feed/name" />
        <rest>

GET /feed
    gets information about container
    returns XML content
        <amqprest version="1.0" status="ok">
          <container type="feed" size="[size]" />
        <rest>

PUT /feed/name
    creates a new feed resource
    returns XML content
        <amqprest version="1.0" status="ok">
          <feed uri="http://localhost/feed/name" />
        <rest>

GET /feed/name
    gets information about the feed
    gets a list of all waiting messages
        <amqprest version="1.0" status="ok">
          <feed uri="http://localhost/feed/name">
            <message uri="http://localhost/feed/name/[nbr]" />...
          </feed>
        <rest>
    => NOTFOUND if not known

DELETE /feed/name
    deletes feed resource
    returns XML content
        <amqprest version="1.0" status="ok" />
    idempotent, feed does not need to exist

POST /feed/name
    => BADREQUEST

PUT /sink/sink-path?type=sinktype
    creates sink, idempotent

^^^^^ IMPLEMENTED ^^^^^

Manipulating sink resources

GET /sink/sink-name
    get "sink/sink-name"
    queries sink
    returns information on sink
DELETE /sink/sink-name
    delete "sink/sink-name"
    deletes sink, idempotent
POST /sink/sink-name
    post "sink/sink-name"
POST /sink/sink-name/address
    post "sink/sink-name/address"
    posts a message to the sink
    address is routing key for exchanges
    address is message-id for queues
    address may be empty
    expects body data, content-type

Manipulating selectors in sinks:

PUT /sink/sink-name/selector?feed=nbr
    put sink/sink-name/selector
    for queues, selector must be "*"
    for exchanges, selector is routing key
    pulls matching messages into specified feed
    idempotent
GET /sink/sink-name/selector
    get sink/sink-name/selector
    returns information on selector

DELETE /sink/sink-name/selector
    delete sink/sink-name/selector
    deletes the selector

^^^^^ NEXT ^^^^^

Zyre - an open source RestMS implementation

++ The RESTful Messaging Service (RestMS)

"All REST interactions are stateless. That is, each request contains all of the information necessary for a connector to understand the request, independent of any requests that may have preceded it."

++ Summary

RestMS provides applications with the ability to manage and access a set of resources that provide a RESTful HTTP interface to AMQP messaging networks.  These resources are:

# "Feeds", which are private collections of incoming messages.
# "Sinks", which are public recipient routing points for outgoing messages.
# "Selectors", which sinks are containers for.  Selectors direct messages from sinks to feeds.
# "Messages", which feeds are containers for.

While the primary goal of RestMS is to provide a simpler, more accessible set of semantics than those packaged in AMQP/0-9-1 implementations, many aspects of the design (such as the unification of queues and exchanges as a single concept) are also meant to drive the design of AMQP/1.0.

The RestMS model maps to AMQP as follows:

* Sinks map to exchanges or named queues, according to the sink type.
* Selectors map to bindings or consumers, according to the sink type.
* Feeds map to consumers.

The AMQP concept of private queue is not visible to the RESTful Messaging Service.

RestMS could also be mapped to other messaging services, the concepts of sink, feed, and selector are generic.  AMQP-specific aspects of RestMS are defined in a separate layer, "the RestMS-AMQP Mapping".

++ Feeds

A feed is a collection of messages, organized as a queue.  Feeds are usually private for applications but can be shared.  Feeds are created by applications and destroyed either after a period of inactivity, or explicitly by applications.

++ Sinks

A sink is an intermediate recipient for messages, which routes the message according to one or more algorithms.


Manipulating messages in feeds

Messages received from the server are sorted into feed queues.  This is done as a side effect of any access to the feed.  Messages are sorted using their consumer-tags, which are their feed number.

In Rest style, we get the container information which would list all waiting messages and then we would get those messages one by one, delete them, etc.:

GET /feed/feednbr/msgid
    get "feed/nbr/msgid"
    gets the message specified
    implementation:
        - must be next message on feed
        - waits

DELETE /feed/feednbr/msgid
    delete "feed/nbr/msgid"
    deletes the message and all prior messages (gone off the feed), (ack)
PUT /feed/feednbr/msgid
    put "feed/feednbr/msgid"
    rejects the message (nack)
POST /feed/feednbr/msgid
    post "feed/feednbr/msgid"
    => not allowed

msgid's are incremental, so the application can guess them if it is the only one using the feed.  It must still do DELETE to remove from feed.  We allow deleting a range by specifying the highest message id to delete.

++ Sinks

Sinks are where we post messages.  Sinks are also containers for selectors, which is how we get messages into our feeds. All visible exchanges and shared queues are exposed as sinks.


++ Scenarios

POST /sink.topic/nasdaq.imatix + content

PUT /sink/stocks/?type=topic
POST /sink/stocks/nasdaq.imatix + content

PUT /feed
S: /feed/1
GET /feed/1/1
S: message

config
    amqp server name
    amqp server login and password
    client logins
        - basic auths
        - not same as openamq credentials

- if-modified-since
- cache-control
- last-modified-time


This restriction accomplishes four functions: 1) it removes any need for the connectors to retain application state between requests, thus reducing consumption of physical resources and improving scalability; 2) it allows interactions to be processed in parallel without requiring that the processing mechanism understand the interaction semantics; 3) it allows an intermediary to view and understand a request in isolation, which may be necessary when services are dynamically rearranged; and, 4) it forces all of the information that might factor into the reusability of a cached response to be present in each request.

**** REST METHODS ****

Resolve - resolve path into sink, selector, type
Put - declare a sink of specified type, or selector on existing sink
Get - query a sink and get back type, or get selector information
Delete - delete a sink or selector

Resources are sinks or selectors:

    /
    /sink-name
    /sink-name/selector-string
    /sink-name/*

Sinks are exchanges or queues.  These share the same namespace.  Selectors are, for queues, patterns that match the message-id field.  For exchanges, selectors are binding keys.  All selectors have the same effect: pull messages into own private message queue.  Application can define selectors in advance, using Put method, or dynamically, using Get method.

****  NEW  ****

amq_rest_new (hostname, login, password)

Connects to the specified host.  If successful, creates a private queue for own messages.

****  RESOLVE  ****

rc = amq_rest_resolve (path, sink, info, type)

Resolves a path and returns the sink, info, and type if any.  If the path cannot be resolved, returns -1, else returns 0.  Uses a local cache to reduce the number of exchanges with the server.  Uses the Rest.Resolve method.

****  PUT  ****

rc = amq_rest_put (path, [type])

    put /exchange-name?type="exchange-type"
    put /queue-name?type="queue"
    put /exchange-name/binding-key
    put /queue-name/*

Assert-creates a resource specified by path.  The path is a sink name + optional selector.  To specify a selector, the sink must already exist.  The type is mandatory when creating a sink, and must be a valid exchange type, or  "queue".  Returns 0 if the resource could be assert-created, -1 if not.  Attempting to create an existing resource is not an error.

Implementation:

* Resolve path via amq_rest_resolve()
* If sinkname is unknown, use Rest.Put to declare sink (type is mandatory).
* If selector is not empty, create binding:
 * If sink is exchange, do Queue.Bind to exchange using selector
 * If sink is queue, consume from queue (selector must be "*")

****  GET  ****

message = amq_rest_get (path, timeout)

    get /
    get /exchange-name
    get /queue-name
    get /exchange-name/binding-key
    get /queue-name/*

Attempts to fetch a message from a specified path.  The path is one of: "/", meaning the private queue for the client or a sink name followed by a selector.  Valid selectors are "*" for queue sinks, and binding keys for exchange sinks.  The sink must exist.  If the path refers to a sink name with no selector, acts as a passive assertion that the sink exists, but does not return a message.

Implementation:

* If path is /, wait on message from private queue
* Else
 * Resolve path via amq_rest_resolve()
 * If sinkname is unknown, print error and end
 * If selector is empty, do Rest.Get on resource (assertion), and end
 * If sinktype is exchange, re-bind to specified selector and wait for message
 * If sinktype is queue, get message from queue (selector must be "*")

****  DELETE  ****

rc = amq_rest_delete (path)

    delete /exchange-name
    delete /queue-name
    delete /exchange-name/binding-key
    delete /queue-name/*

Assert-deletes a resource specified by path.  The path is a sink name + optional selector.  To specify a selector, the sink must exist.  Deletes the selector by doing an unbind if the sinktype is exchange, otherwise stops consuming from the queue.  Deletes a sink (if only a sink name is specified) by deleting the exchange or queue as specified.  Attempting to delete a non-existing resource is not an error.

****  POST  ****

rc = amq_rest_post (path, message)

Posts a message to a resource specified by path.  The path is a sink name + optional address.  The sink must exist.  If the sink is an exchange, the address is used as a routing-key.  If the sink is a queue, the address is used as a message-id.


=====

Not supported:

* Does not allow binding arguments (headers) yet.

RESTful extensions to AMQP
    - Rest protocol class
    - / in topics equivalent to ., both in bind and publish
    - * in topics matches empty routing-key
    - empty topic segments are allowed (.value or /value)





=\==============================================================




<!--
<method name = "resolve" template = "function">
    <doc>
    Resolves a resource path and sets the following properties:

    self->is_feed           TRUE if the path refers to the feed
    self->sink_name         Name of sink, if not the feed
    self->sink_type         Type of sink as a string
    self->selector          Selector string if not empty
    self->is_queue          TRUE if the sink is a queue

    If path could not be resolved, returns -1 and sets self->strerror to
    the error cause.  An unresolved path refers to a non-existent sink.
    </doc>
    <argument name = "path" type = "char *">Resource path</argument>
    <local>
    char
        *path_delim;
    </local>
    //
    assert (path && strused (path));
    self->is_feed = FALSE;
    self->is_queue = FALSE;
    path_delim = path + strlen (self->sink_name);
    if (streq (path, "."))
        self->is_feed = TRUE;           //  Don't touch cached sink
    else
    //  If path starts with cached sink name, cleanly ending in
    //    slash or null, then use cache
    if (strused (self->sink_name)
    &&  ipr_str_prefixed (path, self->sink_name)
    &&  (*path_delim == 0 || *path_delim == '/')) {
        if (*path_delim == 0)
            strclr (self->selector);
        else
        if (*path_delim == '/')
            icl_shortstr_cpy (self->selector, path_delim + 1);
        if (streq (self->sink_type, "rotator")
        ||  streq (self->sink_type, "service"))
            self->is_queue = TRUE;
    }
    else {
        amq_client_session_rest_resolve (self->session, path);
        rc = s_check_rest_reply (self);
        if (rc == 0) {
            icl_shortstr_cpy (self->sink_name, self->session->sink_name);
            icl_shortstr_cpy (self->sink_type, self->session->sink_type);
            icl_shortstr_cpy (self->selector,  self->session->selector);
        }
        if (streq (self->sink_type, "rotator")
        ||  streq (self->sink_type, "service"))
            self->is_queue = TRUE;
    }
</method>

<method name = "sink create" template = "function">
    <doc>
    Creates the sink as specified, or checks that the sink exists.
    Returns 0 if OK, -1 if the method failed.
    </doc>
    <argument name = "sink name" type = "char *">Full sink name</argument>
    <argument name = "sink type" type = "char *">A valid sink type</argument>
    //
    assert (sink_name && strused (sink_name));
    assert (sink_type && strused (sink_type));
    amq_client_session_rest_put (self->session, sink_name, sink_type);
    rc = s_check_rest_reply (self);
</method>

<method name = "sink query" template = "function">
    <doc>
    Queries the sink as specified.  Returns 0 if the sink exists, or -1
    if the sink does not exist.  If the sink exists, returns a set of sink
    properties in self->properties.
    </doc>
    <argument name = "sink name" type = "char *">Full sink name</argument>
    //
    assert (sink_name && strused (sink_name));
    amq_client_session_rest_get (self->session, sink_name);
    rc = s_check_rest_reply (self);
    if (rc == 0) {
        asl_field_list_destroy (&self->properties);
        self->properties = asl_field_list_new (self->session->properties);
    }
</method>

<method name = "sink delete" template = "function">
    <doc>
    Deletes the sink as specified.  Returns 0 if the sink was deleted or
    was already absent.  Returns -1 if the delete request was not allowed.
    </doc>
    <argument name = "sink name" type = "char *">Full sink name</argument>
    //
    assert (sink_name && strused (sink_name));
    amq_client_session_rest_delete (self->session, sink_name);
    rc = s_check_rest_reply (self);
    //  Empty sink cache if successful
    if (!rc)
        strclr (self->sink_name);
</method>

<method name = "selector create" template = "function">
    <doc>
    Creates the selector as specified, and starts to receive messages from
    the specified sink. Returns 0 if OK, -1 if the method failed.
    </doc>
    <argument name = "path" type = "char *">Full path</argument>
    //
    assert (path && strused (path));
    rc = restapi_resolve (self, path);
    if (rc == 0) {
        if (self->is_feed) {
            rc = -1;
            icl_shortstr_fmt (self->strerror, "E: cannot create feed");
        }
        else
        if (self->is_queue) {
            if (streq (self->selector, "*"))
                //  Consume from queue, consumer tag is queue name
                //  Requires assertive patch for Basic.Consume
                amq_client_session_basic_consume (self->session, 0,
                    self->sink_name,
                    self->sink_name,
                    FALSE, FALSE, FALSE, NULL);
            else {
                rc = -1;
                icl_shortstr_fmt (self->strerror,
                    "E: invalid queue selector '%s'", self->selector);
            }
        }
        else
            //  Bind to exchange using specified routing key
            amq_client_session_queue_bind (
                self->session, 0,
                "myqueue", //self->feed_queue,
                self->sink_name,
                self->selector,
                NULL);
    }
</method>

<method name = "selector delete" template = "function">
    <doc>
    Deletes the selector as specified, and stops receiving messages from
    the specified sink/selector. Returns 0 if OK, -1 if the method failed.
    </doc>
    <argument name = "path" type = "char *">Full path</argument>
    //
    assert (path && strused (path));
    rc = restapi_resolve (self, path);
    if (rc == 0) {
        if (self->is_feed) {
            rc = -1;
            icl_shortstr_fmt (self->strerror, "E: cannot delete feed");
        }
        else
        if (self->is_queue) {
            if (streq (self->selector, "*"))
                //  Cancel consumer, consumer tag is queue name
                amq_client_session_basic_cancel (self->session, self->sink_name);
            else {
                rc = -1;
                icl_shortstr_fmt (self->strerror,
                    "E: invalid queue selector '%s'", self->selector);
            }
        }
        else
            amq_client_session_queue_unbind (
                self->session, 0,
                "myqueue", //self->feed_queue,
                self->sink_name,
                self->selector,
                NULL);
    }
</method>

<method name = "message set type" template = "function">
    <doc>
    Sets the content encoding and type for outgoing messages.
    </doc>
    <argument name = "content type" type = "char *">Message MIME type</argument>
    <argument name = "content encoding" type = "char *">Message MIME encoding</argument>
    //
    icl_shortstr_cpy (self->out_content_type, content_type);
    icl_shortstr_cpy (self->out_content_encoding, content_encoding);
</method>

<method name = "message post" template = "function">
    <doc>
    Sends a content body to the specified sink.  If the sink is an exchange,
    the selector is used as the routing key and the message is published to
    the exchange. If the sink is a queue, the selector is used as the message
    id, the feed as the reply-to, and the message is published to the default
    exchange. In both cases the selector may be empty.  You should unlink the
    message bucket after doing this call. Returns 0 on success, or -1 if the
    call failed.
    </doc>
    <argument name = "path" type = "char *">Resource path</argument>
    <argument name = "bucket" type = "ipr_bucket_t *">Message to send</argument>
    <local>
    amq_content_basic_t
        *content = NULL;
    </local>
    //
    assert (path && strused (path));
    assert (bucket);
    rc = restapi_resolve (self, path);
    if (rc == 0) {
        content = amq_content_basic_new ();
        amq_content_basic_record_body (content, bucket);
        amq_content_basic_set_content_type (content, self->out_content_type);
        amq_content_basic_set_content_encoding (content, self->out_content_encoding);
        if (self->is_feed) {
            rc = -1;
            icl_shortstr_fmt (self->strerror, "E: cannot post to feed");
        }
        else
        if (self->is_queue) {
            //  Set reply-to to own feed name
            amq_content_basic_set_reply_to (content, "myqueue"); //self->feed_queue);
            //  Set message-id to selector string
            amq_content_basic_set_message_id (content, self->selector);
            //  Publish to default exchange using sink name as routing key
            amq_client_session_basic_publish (
                self->session, content, 0,
                NULL,                   //  Exchange = default exchange
                self->sink_name,        //  Routing key
                TRUE,                   //  Mandatory routing to queue
                FALSE);                 //  Immediate to consumer
        }
        else {
            amq_client_session_basic_publish (
                self->session, content, 0,
                self->sink_name,        //  Exchange name
                self->selector,         //  Routing key = selector
                FALSE,                  //  Mandatory routing to queue
                FALSE);                 //  Immediate to consumer
        }
        amq_content_basic_unlink (&content);
    }
</method>

<method name = "message get" return = "bucket">
    <doc>
    [[TODO: this needs to be fixed]]
    Gets the next message, if any, from the feed.  Returns a bucket with the
    message content, or NULL.  Stores the following message properties in the
    Rest object: content_type, content_encoding, reply_to.
    </doc>
    <argument name = "self" type = "$(selftype) *">Object reference</argument>
    <argument name = "timeout" type = "size_t">msecs to wait for message</argument>
    <declare name = "bucket" type = "ipr_bucket_t *" default = "NULL">Returned message</declare>
    <local>
    amq_content_basic_t
        *content;
    asl_reader_t
        reader;                         //  Body reader
    </local>
    //
    amq_client_session_wait (self->session, timeout? timeout: 1);
    content = amq_client_session_basic_arrived (self->session);
    if (content) {
        amq_content_basic_set_reader (content, &reader, IPR_BUCKET_MAX_SIZE);
        bucket = amq_content_basic_replay_body (content, &reader);
        icl_shortstr_cpy (self->content_type, content->content_type);
        icl_shortstr_cpy (self->content_encoding, content->content_encoding);
        icl_shortstr_cpy (self->reply_to, content->reply_to);
        amq_content_basic_unlink (&content);
    }
</method>

<method name = "message ack" template = "function">
    <doc>
    Acknowledges the previous pedantic message received.
    </doc>
    rc = -1;                            //  Not implemented
</method>

<method name = "message nack" template = "function">
    <doc>
    Rejects the previous pedantic message received.
    </doc>
    rc = -1;                            //  Not implemented
</method>

<private name = "header">
static int s_check_rest_reply ($(selftype) *self);
</private>
<private name = "footer">
static int s_check_rest_reply ($(selftype) *self)
{
    if (self->session->response)
        icl_shortstr_fmt (self->strerror, "E: %s", self->session->reply_text);
    return (self->session->response);
}
</private>


    ipr_bucket_t
        *bucket;

   //  Test a rotator sink
    icl_console_print ("I: test rotator sink");
    assert (restapi_sink_create (session, "test/rotator", "rotator") == 0);
    assert (restapi_sink_create (session, "test/rotator", "rotator") == 0);
    assert (restapi_selector_create (session, "test/rotator/*") == 0);
    assert (restapi_selector_create (session, "test/rotator/*") == 0);
    bucket = ipr_bucket_new (1000);
    ipr_bucket_fill_random (bucket, 1000);
    assert (restapi_message_post (session, "test/rotator/id-001", bucket) == 0);
    ipr_bucket_unlink (&bucket);
//    bucket = restapi_message_get (session, 2000);
//    assert (bucket);
//    ipr_bucket_unlink (&bucket);
//    bucket = restapi_message_get (session, 100);
//    assert (bucket == NULL);
    assert (restapi_sink_query (session, "test/rotator") == 0);
    assert (restapi_selector_delete (session, "test/rotator/*") == 0);
    assert (restapi_selector_delete (session, "test/rotator/*") == 0);
    assert (restapi_sink_query (session, "test/rotator") == 0);
    assert (restapi_sink_delete (session, "test/rotator") == 0);
    assert (restapi_sink_query (session, "test/rotator"));
    assert (restapi_sink_delete (session, "test/rotator") == 0);

    //  Test a service sink
    icl_console_print ("I: test service sink");
    assert (restapi_sink_create (session, "test/service", "service") == 0);
    assert (restapi_sink_create (session, "test/service", "service") == 0);
    assert (restapi_selector_create (session, "test/service/*") == 0);
    assert (restapi_selector_create (session, "test/service/*") == 0);
    bucket = ipr_bucket_new (1000);
    ipr_bucket_fill_random (bucket, 1000);
    assert (restapi_message_post (session, "test/service/id-001", bucket) == 0);
    ipr_bucket_unlink (&bucket);
//    bucket = restapi_message_get (session, 2000);
//    assert (bucket);
 //   ipr_bucket_unlink (&bucket);
 //   bucket = restapi_message_get (session, 100);
 //   assert (bucket == NULL);
    assert (restapi_sink_query (session, "test/service") == 0);
    assert (restapi_selector_delete (session, "test/service/*") == 0);
    //  Sink is gone when selector is deleted
    assert (restapi_sink_query (session, "test/service"));
    assert (restapi_sink_delete (session, "test/service") == 0);
    assert (restapi_selector_delete (session, "test/service/*"));

    //  Test a direct sink
    icl_console_print ("I: test direct sink");
    assert (restapi_sink_create (session, "test/direct", "direct") == 0);
    assert (restapi_sink_create (session, "test/direct", "direct") == 0);
    assert (restapi_selector_create (session, "test/direct/good/address") == 0);
    assert (restapi_selector_create (session, "test/direct/good/address") == 0);
    bucket = ipr_bucket_new (1000);
    ipr_bucket_fill_random (bucket, 1000);
    assert (restapi_message_post (session, "test/direct/good/address", bucket) == 0);
    assert (restapi_message_post (session, "test/direct/wrong/address", bucket) == 0);
    ipr_bucket_unlink (&bucket);
 //   bucket = restapi_message_get (session, 2000);
 //   assert (bucket);
 //   ipr_bucket_unlink (&bucket);
 //   bucket = restapi_message_get (session, 100);
 //   assert (bucket == NULL);
    assert (restapi_sink_query (session, "test/direct") == 0);
    assert (restapi_selector_delete (session, "test/direct/good/address") == 0);
    assert (restapi_sink_query (session, "test/direct") == 0);
    assert (restapi_selector_delete (session, "test/direct/good/address") == 0);
    assert (restapi_sink_query (session, "test/direct") == 0);
    assert (restapi_sink_delete (session, "test/direct") == 0);
    assert (restapi_sink_delete (session, "test/direct") == 0);
    assert (restapi_sink_query (session, "test/direct"));
    assert (restapi_sink_delete (session, "test/direct") == 0);

    //  Test a topic sink
    icl_console_print ("I: test topic sink");
    assert (restapi_sink_create (session, "test/topic", "topic") == 0);
    assert (restapi_sink_create (session, "test/topic", "topic") == 0);
    assert (restapi_selector_create (session, "test/topic/a4/*") == 0);
    assert (restapi_selector_create (session, "test/topic/*/color") == 0);
    bucket = ipr_bucket_new (1000);
    ipr_bucket_fill_random (bucket, 1000);
    assert (restapi_message_post (session, "test/topic/a4/bw", bucket) == 0);
    assert (restapi_message_post (session, "test/topic/a5/bw", bucket) == 0);
    assert (restapi_message_post (session, "test/topic/a5/color", bucket) == 0);
    ipr_bucket_unlink (&bucket);
//    bucket = restapi_message_get (session, 2000);
//    assert (bucket);
//    ipr_bucket_unlink (&bucket);
//    bucket = restapi_message_get (session, 2000);
//    assert (bucket);
//    ipr_bucket_unlink (&bucket);
//    bucket = restapi_message_get (session, 100);
//    assert (bucket == NULL);
    assert (restapi_sink_query (session, "test/topic") == 0);
    assert (restapi_selector_delete (session, "test/topic/a4/*") == 0);
    assert (restapi_sink_query (session, "test/topic") == 0);
    assert (restapi_selector_delete (session, "test/topic/a4/*") == 0);
    assert (restapi_sink_query (session, "test/topic") == 0);
    assert (restapi_selector_delete (session, "test/topic/*/color") == 0);
    assert (restapi_sink_query (session, "test/topic") == 0);
    assert (restapi_selector_delete (session, "test/topic/*/color") == 0);
    assert (restapi_sink_query (session, "test/topic") == 0);
    assert (restapi_sink_delete (session, "test/topic") == 0);
    assert (restapi_sink_delete (session, "test/topic") == 0);
    assert (restapi_sink_query (session, "test/topic"));
    assert (restapi_sink_delete (session, "test/topic") == 0);

    //  Test pedantic messaging
    icl_console_print ("I: test pedantic messaging");
    assert (restapi_sink_create (session, "test/pedantic", "rotator") == 0);
    assert (restapi_selector_create (session, "test/pedantic/*") == 0);
    bucket = ipr_bucket_new (1000);
    ipr_bucket_fill_random (bucket, 1000);
    assert (restapi_message_post (session, "test/pedantic/id-001", bucket) == 0);
    ipr_bucket_unlink (&bucket);
//    bucket = restapi_message_get (session, 2000);
//    assert (bucket);
//    ipr_bucket_unlink (&bucket);
    assert (restapi_message_nack (session));
    assert (restapi_message_ack (session));
    assert (restapi_sink_delete (session, "test/pedantic") == 0);

-->