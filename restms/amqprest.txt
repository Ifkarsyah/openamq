Messaging for the Rest of Us

> "Mediocrity is easy, good things take time" -- Bob Seger Band

This article introduces AMQP/Rest, a way of accessing AMQP networks from HTTP clients.  AMQP/Rest introduces a set of simplifying patterns for AMQP use and maps these onto a REST-like HTTP interface.  AMQP/Rest is designed to be trivial to access from small devices, in any language that provides basic TCP/IP access, and to be compatible with HTTP authentication and encryption mechanisms such as SSL/TLS.  Finally, AMQP/Rest and its reference implementations were designed as components for projects like mod_amqp, the Apache AMQP module.

++ In Defense of New Terminology

> "The quality of a spec is inversely proportional to the number of new terms invented by the author" -- Hintjens' Second Law of Standardisation.[[footnote]]The First Law is "Any project that starts with a call for volunteers is doomed to failure".  The Third Law is "A properly organised community will tend to work faster, more accurately, and more economically, than a tight group of the most brilliant experts."  I can go on inventing Laws forever.[[/footnote]]

In this spec I've invented some new terms.  In my defense I'll argue that there are new words for old things which already had perfectly good names, and there are new words for old things that have skulked around in the shadows, escaping simply for lack of a convenient handle.  Calling a spade a "manual soil excavation tool" is bad.  Creating a turf-digging spade with a sharp titanium cutting blade and leveraged handle, and calling it "splade" is fine.[[footnote]]Don't bother Googling "splade", I made this up.  I could have used "spork" as an example, between a cheap plastic spork and a sharp titanium splade, the choice is a no-brainer.[[/footnote]]

Using new words in place of old ones is a form of encryption that hides information.  But finding new words for things that existed without names is a key part of capturing knowledge.  There is a great value, not to mention joy, in uncovering and naming the patterns behind terms like "bluetoothing" and "blue-egging"[[footnote]]Google may help but it's unlikely.  Bluetoothing is what two women do when they synchronise databases.  "So what did she tell you about...?"  Blue-egging is what geeks do when they insist on solving irrelevant but compellingly attractive problems.  "Hang on, I'll fix that crash as soon as I've finished with this mouse driver optimisation!"  The term is named after a small bird that can be fooled into abandoning its own nest for a huge fake blue plastic egg covered in black spots, which acts as an incredibly attractive super-stimulus.[[/footnote]].  So a large part of the work of defining new specifications is to uncover existing natural patterns and give them clear names, so they can be formalised and reused and built on.

From the point of view of an AMQP engineer, who already has a solid vocabulary, these are the terms I invented and/or have pilfered for the purposes of this document, and turned into reusable named patterns:

* AMQP/Rest proxy: a proxy process which sits between an AMQP broker and a set of applications, speaking AMQP to the broker, and HTTP to the applications, implementing the AMQP/Rest specification.
* Resource: an entity that is manipulated or accessed by an application.  Resources are addressed using a path, which is part of a URI (universal resource indicator).
* Sink: a broker-side entity which receives messages.  Sinks are AMQP exchanges or queues.
* Feed: a dedicated private queue that holds messages delivered to one application.
* Selector: a mechanism for selecting messages from a sink.  In AMQP parlance, selectors are bindings to exchanges, or consumers on queues.
* Rotator: a type of shared queue that lives independently of consuming applications.
* Service: a type of shared queue who's lifespan is tied to that of consuming applications.
* Session: a set of state held by the AMQP/Rest proxy on behalf of one application.  Primarily, holds a set of selectors, and a feed.

++ Overview and Goals

REST defines a set of create/read/update/delete semantics for working with server-side entities through HTTP or an HTTP-like model.  Compared to a protocol like AMQP, REST semantics are considerably simpler and more accessible to a broad developer audience.

We designed a REST-like mapping from AMQP to HTTP (AMQP/Rest), which this article explains. AMQP/Rest is documented on wiki.amqp.org at (insert URL here).  We built the RestMQ messaging server (www.restmq.org) to implement an AMQP/Rest proxy and thus demonstrate and prove these principles.  RestMQ is free software.  AMQP/Rest can be implemented on any AMQP broker with the help of a small set of extensions.

In OpenAMQ, the REST interface is provided by an API library called RestAPI.  RestAPI provides applications with a REST interface to compatible AMQP brokers without actually passing over HTTP.  RestMQ uses RestAPI to communicate with the OpenAMQ server and RestAPI can be used as a reference for other implementations.

In this document we use RestAPI and RestMQ as the basis for explaining one possible reusable architecture for AMQP/Rest.  Other implementations may obviously choose different architectures.

++ Simplifying AMQP

> Path names follow the IETF RFC 3986 "URI Generic Syntax" rules. -- AMQP/0.91 XML specification

REST imposes an interesting restriction: resources are addressed through a single URI that represents an object hierarchy.  AMQP is rather more complex and does not at first sight have a natural object hierarchy.  We have not tried to map all of AMQP to REST.  Rather, we have taken the essential and most frequent patterns of use, and mapped them, making some strong assumptions and hiding areas of flexibility which AMQP offers but which are rarely used.  The result is a simpler messaging semantic which nonetheless integrates into an AMQP network.

These are the simplifications:

* Applications do not manipulate private queues explicitly.  Every application automatically gets a private queue for its own use, called its "feed", and the AMQP/Rest proxy automatically binds the feed to exchanges, and consumes from it as needed.
* Applications cannot bind shared queues explicitly.  Shared queues are always addressed via the default exchange, using the queue name as routing-key.
* Thus, exchanges and queues strongly resemble each other, and we group these under the term "sinks".  A sink accepts messages, and distributes them out to applications depending on some criteria (the "selector").
* For exchanges, the selector is the routing-key.
* For (shared) queues, the selector is a wild-card selector on message IDs.  Note that AMQP does not implement this, so currently the only valid selector for queues is "*".
* Applications cannot (today) create complex messages with properties and header values.
* There are no transactions - every method is in an automatic transaction.
* Consumers are invisible and managed automatically by the AMQP/Rest proxy.

Further, we have defined a set of extensions to AMQP to support the RESTful model:

* A new protocol class, Rest, provides methods to work with AMQP/Rest resources.
* Queue and exchange names are valid path names, so may contain embedded slashes.
* Topic routing keys are valid path names, so may contain embedded slashes.
* In topic keys, slashes act as segment separators, and act as periods.
* In topic keys, segments can be empty.
* In topic keys, the * wildcard matches an empty segment.

We recognize that creating "extended subsets" of a protocol is usually bad practice.  However, these extensions are fully compatible with existing AMQP applications.  The Rest class optimises manipulation of existing concepts, and the remaining extensions could be added to AMQP in any case, to improve syntactic compatibility with URI schemes.

We also propose further extensions to AMQP at the end of this paper, designed to further simplify and improve the AMQP messaging model.

++ A RESTful resource hierarchy

The key to defining a workable REST mapping is to design a natural resource hierarchy that represents the actual objects that applications wish to work with.  Our main insight, and the original basis for this work, was that the most natural hierarchy was exchanges, containing bindings.

Thus the PUT method creates a binding, the GET method queries that binding, and the DELETE method deletes the binding.  The metaphor almost works, but breaks in two areas.  First, it does not work for publishing messages (the POST method), where we can't address bindings.  Second, shared queues do not contain bindings.

We also need to find a clean way of addressing shared queues. There are two ways: either indirectly, via an exchange like amq.direct, or directly, by using the default exchange and automatic binding.  In the first case, we stick to the AMQP orthodoxy (that queues are never addressed directly) but we introduce complexity.  First, every POST method needs to specify both an exchange and a queue name.  Second, we need ways to bind shared queues to exchanges, so our PUT method needs to specify three parties of a relationship (exchange-binding-queue) rather than a parent-child hierarchy.

In practice, 99% of applications that use shared queues address them directly by name, so this flexibility is not needed, and paying the cost of the additional complexity would probably be a bad bargain.

Therefore, we chose the second approach, in which shared queues are addressed by name, and become much closer to exchanges in style.  Both exchanges and queues are "sinks" to which applications can post messages.

The next question is what to do with routing keys, when we publish to a queue.  Queues do not use routing keys to distribute messages.  Indeed, AMQP offers no semantics for selecting messages from a queue.  Yet this seems to be a useful mechanism, especially for workload distribution.  We know that various groups have tried to define a "selector" mechanism, and we decided to integrate this into the AMQP/Rest model.

On queues, the selector is a pattern (with the same format as a topic expression) which matches some arbitrary key in messages.  We use the message-id field, but this could be any field.

This gives us a workable coherence between exchanges and shared queues:

* We post to an exchange and specify a routing key for the message, and we consume from an exchange, specifying a routing key pattern.
* We post to a shared queue and specify an identifier for the message, and we consume from a shared queue, specifying a selector pattern.

If we say that a routing key is a form of selector, we get a clean resource hierarchy of "sinks" that contain "selectors" which select the messages an application wishes to see.  When selectors are strings, we can manipulate them using a URI and the PUT, GET, POST, and DELETE methods.

In both cases, messages arrive in the application feed (an automatic, hidden, private queue).  While AMQP separates shared queues from private queues, and holds them both at the same level, gated by consumers, AMQP/Rest promotes a shared queue to the level of exchange, and hides the private queue within the "feed" concept.

We have previously discussed the benefits of hiding private queues as feeds in (URI to Direct Mode paper).

We believe that this model, which extends on prior work in simplifying and improving the message flow through brokers to applications, is both simpler to understand and use, and provides some insight into how future versions of AMQP could be designed (especially the unification of exchanges and shared queues as "sinks")[[footnote]]Leaving the door open to sink-to-sink bindings.[[/footnote]].

A resource path (the part of the URI after the hostname) has three forms.  The first form is a sink name.  These are valid paths for sinks:

[[code]]
first-sink
second/sink
[[/code]]

Note that a path does not start or end with a slash.  The second form is a sink name plus selector.  The selector may be an empty string.  The only way to know whether a path refers to a sink name or a sink name plus selector is by discovery.  If any leading part of the path maps to an existing exchange or queue on the AMQP broker, that part is the sink name, and the remainder is the selector.  These are valid paths for sinks and selectors, assuming the two sinks above both exist:

[[code]]
first-sink/
first-sink/some-selector
first-sink/another/selector
second/sink/
second/sink/some-selector
second/sink/another/selector
[[/code]]

Note that a sink name plus empty selector (e.g. "first-sink") is not the same as a sink name by itself (e.g. "first-sink/").

The third form of resource path is the application feed, represented by the path ".":

[[code]]
.
[[/code]]

++ AMQP/Rest patterns

Once we have defined our resource hierarchy, and our methods, we can look at the patterns we intend to support.  This is the full set of patterns:

* "PUT sink-name?type=sink-type" - create sink
* "GET sink-name" - query sink
* "DELETE sink-name" - delete sink
* "POST sink-name/selector[?arguments]" - publish to sink
* "PUT sink-name/selector" - create selector and activate feed
* "GET sink-name/selector" - create selector and fetch message from feed
* "DELETE sink-name/selector" - delete selector
* "GET ." - fetch message from feed
* "DELETE ." - acknowledge message
* "PUT ." - reject message

In a perfect RESTful world, GET/PUT/POST/DELETE would work systematically on all forms of path.  Unfortunately it's not as clean as we'd like, and in some cases you can practically hear the HTTP verbs screaming as we twist them into shapes they were never designed for.  It's justified by deliver simple patterns for the most common scenarios, and not inventing arbitrary new abstractions.  The methods for working with the feed are an example.

+++ Creating sinks

To create a sink (an exchange or a queue), we use the PUT method where the path is the name of the sink, and we specify a "type" argument, where the type is either an exchange type, or one of the queue types:

* "PUT sink-name?type=sink-type" - create sink

We define two queue types, which correspond to the two main use cases for shared queues:

# "rotator" is a workload distribution queue which exists independently of consumers, and is usually implemented using persistent disk-backed storage.
# "service" is a service management queue which is deleted automatically if all consumers go away, and is usually implemented in memory.

Service queues are synchronized to the lifespan of their consuming applications so that client applications can detect the presence of services by either sending a message and seeing if it bounces, or by explicitly querying the service queue (a passive Queue.Declare over AMQP, or a sink query in AMQP/Rest).

For example, to create a topic exchange, and a shared service queue:

[[code]]
PUT news?type=topic
PUT printer?type=service
[[/code]]

Note that it is safe to attempt to re-create a sink that already exists with the same type.  We hold queues and exchanges in one namespace, so it is not possible to have a queue with the same name as an exchange.  Further, since paths are resolved hierarchically, it is not possible to use one sink name as the first part of the name of a second.  These methods would be illegal, assuming we have created the two sinks shown above:

[[code]]
PUT news?type=service            -- wrong type
PUT printer/two?type=service     -- name conflict
[[/code]]

+++ Querying sinks

To query a sink we use the GET method where the path is the name of the sink:

* "GET sink-name" - query sink

This provides us with the type of the sink.  If the sink does not exist, we get a 404 not found response.  [[footnote]]The returned information would typically include an HTML body which provides information about the sink, providing such a neat way to monitor, for instance, critical AMQP queues, that one searches for the catch.  There's none.[[/footnote]]

Thus to  query our example sinks:

[[code]]
GET news
GET printer
[[/code]]

+++ Deleting sinks

To delete a sink (an exchange or a queue) and all selectors it contains, we use the DELETE method with the path equal to the sink name:

* "DELETE sink-name" - delete sink

Thus, to delete our example topic exchange and shared queue:

[[code]]
DELETE news
DELETE printer
[[/code]]

Note that it is safe to attempt to delete a sink does not exist (either never existed, or has been deleted).  Deleting a sink will affect all applications that use it, so AMQP brokers may apply access controls to this operation.  Usually, applications do not need to delete sinks, it is sufficient to allow a session and the selectors it includes to expire.

+++ Posting to sinks

To publish a message to a sink, we use the POST method, which carries a content body.  If the sink is an exchange, the selector is used as the routing key and the message is published to the exchange.  If the sink is a queue, the selector is used as the message id, the message reply-to is set to the sender's feed name, and the message is published to the default exchange.  In both cases the selector may be empty.  The message will take the MIME content type and encoding of the message.  An optional arguments string carries message properties.

* "POST sink-name/selector[?arguments]" - publish to sink

Thus, to publish a set of messages to our example news exchange:

[[code]]
POST news/rec.pets.cats?priority=9
POST news/comp.protocol.amqp
POST news/
[[/code]]

And to post a set of messages to our example shared queue:

[[code]]
POST printer/a4.color?paper=300g&quality=high
POST printer/
[[/code]]

+++ Explicit selector creation

To create a selector (a binding to an exchange, or a consumer on a queue), we use the PUT method where the first part of the path is the sink name, and the second part is the selector value:

* "PUT sink-name/selector" - create selector and activate feed

Thus, to make a set of bindings to our example topic exchange:

[[code]]
PUT news/alt.#
PUT news/rec.#
PUT news/comp.#
[[/code]]

And to request messages from a shared queue:

[[code]]
PUT printer/*
[[/code]]

Note that creating a selector implicitly requests messages from the sink, creating consumers automatically as needed and queueing messages in our feed.  For queues, we at present allow only the "*" wildcard selector (AMQP does not have yet have selectors on queues, so this means "all messages".  We would like to extend AMQP to allow topic-style selectors on queues).

+++ Combined select and fetch

The combination of "create selector" and "wait for and fetch next messages from feed" are so common that we provide a single method which does these two together.  Conceptually, this is the "query selector" method: the GET method, where the first part of the path is the sink name, and the second part is the selector:

* "GET sink-name/selector" - create selector and fetch messages from feed

Thus, to get messages from our example topic exchange:

[[code]]
GET news/#.amqp
[[/code]]

And to get messages from our shared queue:

[[code]]
GET printer/*
[[/code]]

Note the subtle but necessary difference between querying an empty selector on a sink ("GET sink-name/") and querying a sink ("GET sink-name").

Querying a new selector implicitly creates the requested selector, and waits for at least one message to arrive.  Applications would use either the GET or the PUT form, but not both.  This deviates from normal REST semantics but lets us implement a minimalist and sensible semantic ("GET resource") for binding, consuming, and receiving a well-specified set of messages from a well-specified sink.

An application that needs to manage multiple selectors in parallel (e.g. subscribe to many different topics) would use explicit selectors.  An application that wanted to manage a mix of topic messages and pedantic queue messages would open two sessions (see description of sessions below) and would at least use the combined select and fetch on the queue.

AMQP/Rest does opportunistic batching.  That is, it will return as many messages are available, in one response, and in order.

+++ Deleting selectors

To delete a selector (a binding to an exchange, or a consumer on a queue), we use the DELETE method where the first part of the path is the sink name, and the second part is the selector value:

* "DELETE sink-name/selector" - delete selector

Thus, to delete our the selectors (bindings) on our example topic exchange:

[[code]]
DELETE news/alt.#
DELETE news/rec.#
DELETE news/comp.#
[[/code]]

And to stop receiving messages from our example shared queue:

[[code]]
DELETE printer/*
[[/code]]

Note that this does NOT delete messages.  Deleting a selector does not immediately stop the flow of messages from it - the feed will usually have messages still pending, and not yet fetched.

+++ Using the feed

The application's feed holds messages according to the selectors that were defined.  There is no difference, from the application's perspective, of messages received from a shared queue and messages from an exchange, except that certain messages can be processed more pedantically than others.  AMQP implements this using an acknowledgment model, optionally wrapped in transactions.  We implement a very simple acknowledge/reject semantic which is appropriate for the RESTful way of working.

To read messages from our feed, we use the GET method with an empty path, which conceptually gets the next message or messages from the feed:

* "GET ." - fetch messages from feed

To acknowledge a message, if this is needed by the queue, we use the DELETE method with an empty path, which signifies the "last delivered message":

* "DELETE ." - acknowledge message

To reject a message (so it can be delivered to other applications), we use the PUT method with an empty path, which signifies the "last delivered message":

* "PUT ." - reject message

Here is an example of fetching messages after explicitly creating selectors:

[[code]]
PUT news/#.amqp
GET .
[[/code]]

Here is an example of fetching and then acknowledging a message:

[[code]]
PUT printer/*
GET .
DELETE .
[[/code]]

Here is an example of fetching and then rejecting a message:

[[code]]
PUT printer/*
GET .
PUT .
[[/code]]

The DELETE and PUT methods only work if the message was delivered from a shared queue that is expecting acknowledgements or rejects.  If the message cannot be acknowledged or rejected, these methods return an error.  For pedantic messages, applications can skip a DELETE method and issue a new GET.  These two sequences are identical:

[[code]]
PUT printer/*
GET .
DELETE .
GET .
DELETE .
GET .
[[/code]]

and:

[[code]]
PUT printer/*
GET .
GET .
GET .
[[/code]]

AMQP/Rest does opportunistic batching.  That is, it will return as many messages are available, in one response, and in order.  When a queue is being pedantic (that is, it expects acks or rejects on messages), its messages are never batched but are received, and acknowledged or rejected, one by one.

Finally, we do not define a POST command for feeds.  This would, naturally, have the effect of posting a message to one's own feed, a feature we do not see any use for.  In AMQP/Rest, doing a POST on a feed returns an error.

+++ Use of the Reply-To property

AMQP defines a reply-to property on messages, which is used in request-response scenarios.  In AMQP/Rest, this works as follows:

* When a message is posted to a sink implemented by a shared queue, the message's reply-to property is automatically set to the sending application's feed name.
* Applications that wish to reply to a request message can use the reply-to field of the request as the full resource path for a response POST.

AMQP applications that want to work properly with AMQP/Rest clients must always send replies to the default exchange, using the reply-to string as the routing key.  AMQP/Rest feeds (private queues) are not bound to any other exchange.

++ Architecture

+++ The AMQP/Rest proxy

AMQP/Rest is designed as a layer that runs beside an AMQP broker, implemented as a proxy between a set of HTTP clients, and an AMQP network.  The AMQP/Rest proxy includes an HTTP service (or it may be built as a plug-in for an HTTP server).

The AMQP/Rest proxy:

* Maintains a session for each HTTP client.  We explain what sessions are later: roughly, this lets clients keep a message feed on the AMQP/Rest proxy, and come back to it later, without maintaining an open HTTP connection.
* Handles all connections to, and discussions with, the AMQP broker.  AMQP/Rest clients do not see the AMQP broker, it is completely hidden.
* Implements feeds by creating, binding, and destroying private queues on the AMQP broker when and as needed.
* Implements HTTP sufficiently to handle a normal HTTP/1.0 or HTTP/1.1 client.

The AMQP/Rest proxy may multiplex AMQP/Rest connections to a single AMQP connection, which may reduce the stress on the AMQP broker.  This is done using multiple private queues, with unique consumer tags on each queue, allowing the proxy to identify the queue (and thus the session) for each incoming message.

For scaling and reliability, one may run many AMQP/Rest proxies in parallel.  This requires that clients are predictably reconnected to the AMQP/Rest proxy instance that they originally connected to, so that they will reconnect to their existing sessions.  This is problem is standard and solved in web fabrics.

+++ The Rest extension class

The AMQP broker implements an extension class, Rest, to give clients the ability to discover server-side resources.  This class provides the following request methods:

* Rest.Resolve - gives the server a path and asks it to resolve the path into a sink name, sink type, and selector.
* Rest.Put - ask the server to create a sink.
* Rest.Delete - ask the server to delete a sink.

The Rest.Put and Rest.Delete methods are similar to the Exchange/Queue.Declare and Delete methods but tuned to work within the AMQP/Rest context.  For example, Exchange.Delete and Queue.Delete will raise an exception and close the channel, if the exchange or queue does not exist.  This is problematic for AMQP/Rest since exceptions can cause loss of data.[[footnote]]AMQP can be improved in this area.[[/footnote]]

+++ The AMQP/Rest Application Programmer Interface

We define a specification for an API that abstracts the AMQP/Rest functionality behind a clean interface.  In OpenAMQ, this is implemented by the RestAPI layer.  This API is intended to:

* Make it easy to build AMQP/Rest into other architectures such as web servers.
* Provide application developers with the simplified AMQP/Rest semantics.

The AMQP/Rest API provides these functions:

* New (host, login, password) - connect to an AMQP host as specified.
* Put (path, type) - implements the PUT method.
* Get (path, timeout) - implements the GET method.
* Delete (path) - implements the DELETE method.
* Post (path) - implements the POST method.
* Destroy () - closes the connection to the AMQP host.

The Put function works according to the path:

* "sink-name?type=sink-type" - create sink
* "sink-name/selector" - create selector and activate feed
* "." - reject message

The Get function works according to the path:

* "sink-name" - query sink
* "sink-name/selector" - create selector and fetch message from feed
* "." - fetch message from feed

The Delete function works according to the path:

* "sink-name" - delete sink
* "sink-name/selector" - delete selector
* "." - acknowledge message

++ HTTP mapping

+++ AMQP/Fast URIs

+++ Hosts

+++ Security
- authentication & encryption

+++ Headers

- content-type
- content-encoding
- reply-to
X-xxxx: xxxxx
AMQP-Resource-Type: 
AMQP-Pedantic: 
AMQP-Reply-To
X-

+++ Sessions

sessions (feed per session, session key)
 - when ends, selectors are deleted, feeds are deleted

+++ Use of HTML

- when do we get HTML and what can it be used for?

+++ Worked examples

    - monitor a queue
    - monitor broker status
    - monitor broker events
    - use for OpenAMQ monitoring
    - web based shell interface (generated from CML...?  in C?... rehack formio?)

++ AMQP Extensions

Stateful exchanges (last value caches, etc.)

- subscribe to topic, synchronize feed with topic
- equivalent to durable feeds
- 
