gdl
    title     = Architecture
    subtitle  = OpenAMQ Content Broker Architecture
    product   = OpenAMQ Content Broker
    author    = Pieter Hintjens <ph@imatix.com>
    date      = 2006/08/11
    copyright = Copyright (c) 1996-2006 iMatix Corporation
    version   = 1.0
end gdl

Cover
*****

State of this Document
======================

This document is a design white paper.

Copyright and License
=====================

Copyright (c) 1996-2006 iMatix Corporation

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

For information on alternative licensing for OEMs, please contact
iMatix Corporation.

Abstract
========

This document describes the proposed architecture for the OpenAMQ
content broker version 2.0.

Goals and Objectives
********************

General Goals
=============

The goal of this architecture is to provide a clear set of objects and
relationships between them which can become the basis for a very large
product.

While the 1.0 broker design was largely developed in an ad-hoc manner,
we want the 2.0 broker design to be clearly specified and fully
discussed before we start to implement it.

Functional Compatability
========================

We want the major functionality of the 1.1 code to be reusable without
heavy changes.

Use of ASL Layer
================

Large parts of the architecture can be and will be handled by the code
produced by ASL. In gross terms, ASL provides the broad server, vhost,
and session framework, while the OpenAMQ content broker code provides
the AMQP-specific functionality.

General Architecture
********************

Object Relationship Diagram
===========================

    mb_broker
    :
    :-- mb_exchange  (factory)
    :
    :-- mb_vhost
    :   :
    :   :-- mb_exchange --> mb_exchange_sometype
    :   :
    :   :-- mb_queue_portal --> mb_queue_sometype
    :   :                       :
    :   :                       `-- mb_subscriber
    :   :
    :   `-- mb_session --> mb_gateway_sometype
    :
    :-- mb_gateway_portal   (factory)
    :
    :-- mb_gateway_portal --> mb_gateway_sometype
    :   :
    :   :-- mb_connection --> mb_broker
    :   :   :
    :   :   `-- mb_session --> mb_vhost
    :   :
    :   `-- mb_consumer --> mb_queue_portal
    :    
    `-- mb_connection --> mb_gateway_sometype
        :
        `-- mb_session --> mb_gateway_sometype
        

Broker and Virtual Hosts
========================

The Broker Class
----------------

The broker class (mb_broker) defines a the central controlling object of
the messaging broker. There is only a single broker though in theory we
could construct multi-broker processes. The broker class holds all
global server-side objects, such as log files, config files, and virtual
hosts. The broker object is asynchronous, visible to the console. It is
owned by the main-line code.

The broker life-cycle is:

 - Main-line code creates broker object.
 - Main-line code executes SMT until finished.
 - Main-line code stops broker object.

The Virtual Host Class
----------------------

The virtual host class (mb_vhost) defines a virtual host. A virtual host
is a collection of server-side resources. Virtual host objects are async
objects, visible to the console, and children of the broker. Virtual
hosts are indexed in a hash table owned by the broker.

The vhost life-cycle is:

- Broker constructor creates vhost objects according to configuration
  data and indexes vhosts via hash table.

- Broker destructor stops vhost objects by stopping the hash table.

Exchange Management
===================

Problem Statement
-----------------

We want to allow the broker to link arbitrary exchange classes together.
The only code that should know the specific set of exchange classes is
the main line code.

General Solution
----------------

Rather than work with exchange classes directly, we create portals that
have implicit portal server objects (the exchange being the portal
server), and we then work with those portals, rather than exchanges. We
use portal factories to abstract the exchange classes, and normal
portals to abstract the exchange instances.

Broker and Vhost
----------------

We have a single set of exchange classes per broker, and we have a
unique set of exchanges per vhost. Thus we hold the exchange factories
in the broker object, and we hold the exchange portals in the vhost
object.

Registering Exchange Types
--------------------------

To register exchange types we create a set of factories in the main-line
code, one for each exchange type. This is done using a broker method.
The factories virtualise the exchange construction process. The
factories are named and held on a looseref list in the broker object.

Creating a New Exchange
-----------------------

To create a new exchange, we use the virtualised construction feature of
the exchange factories. This means that we ask the factory to create a
new exchange for us, without any requirement to know the exchange's real
class type.

The exchange factories are owned by the broker, but the vhost can use
these portals, since it also acts as an exchange portal front-end. Thus
the logic to create a new exchange called X of type T is as follows:

 - An application object asks vhost to create an exchange X of type T.
 - The vhost asks the broker to lookup the factory called "T".(*)
 - The vhost asks the factory to create a new portal called "X" and
   implied exchange object.(*)
 - The vhost binds the new portal, so the portal is ready for use.(*)
 - The vhost indexes the exchange portal by name.(*)
 - The vhost informs the application that the exchange was created.

The steps marked (*) are done synchronously using threadsafe mechanisms
where needed.

Implementation Sketches
-----------------------

Registering an Exchange Type
............................

In the main-line code, we register exchanges as follows:

    mb_server_main.inc:
    ----------------------------------------------------------------------
    //  Register all exchange classes
    mb_exchange_fanout_register  (mb_broker);
    mb_exchange_direct_register  (mb_broker);
    mb_exchange_topic_register   (mb_broker);
    mb_exchange_headers_register (mb_broker);
    mb_exchange_return_register  (mb_broker);
    mb_exchange_system_register  (mb_broker);

The exchange portal class has a "name" property, set in the portal class
constructor:

    mb_exchange.icl:
    ----------------------------------------------------------------------
    <context>
        icl_shortstr_t
            name;           //  Exchange name or type
        ipr_hast_t
            *hash;          //  Reference into vhost exchange hash
    </context>
    <method name = "new">
        <argument name = "name" type = "char *" />
        icl_shortstr_cpy (self->name, name);
    </method>

Each exchange class inherits from an exchange base class and specifies
its type name, e.g.:

    mb_exchange_direct.icl:
    ----------------------------------------------------------------------
    <inherit class = "mb_exchange_base">
        <option name = "type_name" value = "direct" />
    </inherit>

The exchange base class inherits from the exchange portal back-end glue
and implements the "register" method:

    mb_exchange_base.icl:
    ----------------------------------------------------------------------
    <inherit class = "mb_exchange_back" />
    <method name = "register" async = "1" template = "async function">
        <argument name = "broker" type = "mb_broker_t *" />
        <local>
        exchange_portal_t
            *factory;
        </local>
        factory = self_mb_exchange_factory ("$(type_name)");
        mb_broker_exchange_register (broker, factory);
        mb_exchange_unlink (&factory);
    </method>

The "exchange register" method in the broker class binds the factory to
the broker, so that the factory is correctly held as a child of the
broker object (and destroyed correctly at shut-down):

    mb_broker.icl:
    ----------------------------------------------------------------------
    <inherit class = "mb_exchange_front" />
    <method name = "exchange register" async = "1" template = "async function">
        <argument name = "factory" type = "mb_exchange_t *" />
        self_mb_exchange_bind (self, factory);
    </method>

Virtual Host Exchange Hash Table
................................

The virtual host holds a loose-referenced hash table of all exchange
portals it creates:

    mb_vhost.icl:
    ----------------------------------------------------------------------
    <context>
        ipr_hash_table_t
            *exchanges;
    </context>
    <method name = "new">
        self->exchanges = ipr_hash_table_new ();
    </method>
    <method name = "destroy">
        ipr_hash_table_destroy (self->exchanges);
    </method>

Declaring a New Exchange
........................

Exchanges are children of vhosts. To declare an exchange we call the
vhost "exchange declare" method, which creates a new exchange portal and
implicit exchange, like this:

    mb_vhost.icl:
    ----------------------------------------------------------------------
    <method name = "exchange declare" async = "1" template = "async function">
        <argument name = "name" type = "char *">Exchange name</argument>
        <argument name = "type" type = "char *">Exchange type</argument>
        <local>
        mb_exchange_t
            *factory,
            *portal;
        ipr_hash_t
            *hash;          //  Lookup exchange by name
        </local>
        //  Ignore multiple declares of same exchange
        hash = ipr_hash_table_search (self->exchanges, name);
        if (!hash) {
            //  Get exchange factory
            factory = mb_broker_exchange_type_lookup (self->broker, type);
            if (factory) {
                portal = mb_exchange_factory (factory, name);
                self_mb_exchange_bind (self, portal);
                //  Add portal to hash table
                portal->hash = ipr_hash_new (self->exchanges, name, portal);
                mb_exchange_unlink (&portal);
                mb_exchange_unlink (&factory);
                //  Signal to session that exchange was created
            }
            else
                //  Signal to session that exchange type was invalid
        }
    </method>

The "exchange type lookup" method in the broker looks for and returns
the factory for the exchange type, like this:

    mb_broker.icl:
    ----------------------------------------------------------------------
    <method name = "exchange type lookup" return = "portal">
        <argument name = "self" type = "$(selftype) *" />
        <argument name = "type" type = "char *">Exchange type</argument>
        <declare name = "portal" type = "mb_exchange_t" />
        <local>
        ipr_looseref_t
            *looseref;           //  Factory reference
        </local>
        //  This code assumes the portal list is not modified at runtime
        looseref = ipr_looseref_list_first (self->mb_exchange_list);
        while (looseref) {
            portal = (mb_exchange_t *) (looseref->object);
            if (streq (type, portal->name)) {
                portal = mb_exchange_link (portal);
                break;                  //  Have a match
            }
            portal = NULL;              //  Reset matched portal
            looseref = ipr_looseref_list_next (&looseref);
        }
    </method>

Destroying an Exchange
......................

To destroy an exchange an application program calls the vhost "exchange
delete" method, which finds and destroys the exchange's portal, like
this:

    mb_vhost.icl:
    ----------------------------------------------------------------------
    <method name = "exchange delete" async = "1" template = "async function">
        <argument name = "name" type = "char *">Exchange name</argument>
        <local>
        mb_exchange_t
            *portal;
        ipr_hash_t
            *hash;          //  Lookup exchange by name
        </local>
        //  Ignore if exchange does not exist
        hash = ipr_hash_table_search (self->exchanges, name);
        if (hash) {
            //  Get exchange factory
            portal = (mb_exchange_t *) hash->data;
            mb_exchange_destroy (&portal);
            ipr_hash_destroy (&hash);
        }
    </method>

The Protocol Layer
==================

Problem Statement
-----------------

We want to solve three specific problems. First, to allow the server to
support arbitrary protocols in the same way as it can support arbitrary
exchange types. Second, to provide both protocol server and protocol
client functionality in a single layer. Finally, to allow multiple
instances of a protocol server (on different TCP/IP ports, typically) to
be active and addressable at once.

General Solution
----------------

The general solution uses a model that is very similar to the exchange
class model:

- We introduce the concept of "gateway", which abstracts a protocol. The
  gateway implementation is entirely hidden to the rest of the server.
  The server includes at least one gateway class, and can include as many
  as the implementor wants to provide, accessed by name.

- Rather than work with gateway classes directly, we access gateways
  through portals.

- We use factories to abstract gateway types and portals to abstract
  gateway instances.

The entire protocol layer is implemented at the ASL level (not in the
AMQP server code).

The Gateway Class
-----------------

The gateway class encapsulates a specific protocol implementation. The
main-line code registers the various gateway classes that it wants to
support. Each of these registrations is instantiated as a factory of the
mb_gateway class. The gateway factories are created by, and belong to,
the broker.

The gateway class works as follows:

 - A gateway class (mb_gateway_somename) implements a specific protocol.

 - Gateways are created via portals and accessed via their portal.
 
 - Each gateway object acts as a protocol server for incoming connections
   and a managing object for outgoing connections.

 - Gateway objects belong to the broker: the broker creates one gateway
   for each protocol server it wants to start, which is usually a single
   gateway instance per class.

 - The gateway encapsulates all protocol agents. The AMQP gateway, for
   example, encapsulates the db_amqp_server_agent master thread, its
   client threads, and db_amqp_client_agent outgoing threads.

The internal architecture of each gateway is not relevant here but we
know that for an AMQP or HTTP gateway, for example, we have two SMT
agents, one for incoming connections from other servers or from
applications (the server agent) and one for outgoing connections to
other servers (the client agent).

The Connection Class
--------------------

The connection class (mb_connection) handles the interface between the
broker and a gateway instance. We implement the connection as a portal
object. The connection class works as follows:

 - Connections can go from broker to gateway, or from gateway to broker,
   depending on which side initiates the connection. In portal terms, both
   broker and gateway can act as clients and/or servers for the portal
   class.

 - An incoming connection (from an application) is created by the gateway
   and bound onto the broker.

 - An outgoing connection (from the broker to another broker) is created
   by the broker and bound onto the appropriate gateway. 

 - Connections are given temporary IDs (short strings) and are indexed by
   the broker on this key (using an ipr_hash table).

The Session Class
-----------------

The session class (mb_session) handles the interface between a virtual
host and a gateway. Sessions are children of connections, but are also
implemented as portals to or from vhosts, from or to gateways. This lets
us work with arbitrary gateway objects, without the need for a separate
portal object. The session class works as follows:

 - In portal terms, a session links either a vhost client to a gateway
   server, or a gateway client to a vhost sever. 

 - Sessions are created by their parent connection, which creates the
   session from vhost to gateway or from gateway to vhost, as wanted. 

 - When the connection is stopped, all its sessions are also destroyed.

Queue Management
================

Problem Statement
-----------------

We want to allow the addition of plug-in queue classes to the server.
Each queue class handles a specific content type and/or implements a
queueing algorithm.

General Solution
----------------

Queues are created via a portal class (mb_queue) that works in the same
way as a gateway or exchange. Note one significant difference: the
protocol allows multiple content types on a single 'queue', so we will
need to implement some partition per content type.

However, for now we can assume that queues are created and used via
portal objects, like exchanges and gateways.

Publishing Messages off an Exchange
===================================

Problem Statement
-----------------

We define a message "sink" as an object that is capable of receiving
messages off an exchange. Sinks include queues, cluster agents, and
exchanges.

The goal is to let arbitrary application objects act as sinks. Currently
this is hardcoded as a "binding" relationship between queues and
exchanges. We want any object - not just a queue - to be able to bind to
an exchange to receive messages. The main challenge is that we have a
variant exchange class, and an undefined set of message-accepting
classes (including queues and cluster-mtas).

Additionally, we want to allow exchange-to-exchange bindings, which are
a likely new feature of future AMQP versions.

General Solution
----------------

We use a portal, called the "subscriber", to connect message sink objects
with exchanges.

The Subscriber Class
--------------------

The subscriber class (mb_subscriber) is a portal that connects an
arbitrary client object (the sink, usually a queue) to a server object
(the exchange). Subscriber creation is always invoked from the sink
side.

Subscribers work as follows:

 - The client object (e.g. a queue) creates a subscriber using the normal
   portal creation mechanism (it asks the exchange to create the portal
   then it binds this portal to itself).

 - The client object configures the subscriber by sending a single
   "configure" method to it, and thus to the exchange. The exchange
   handles the configure method by creating a binding in its own data
   structures.

 - The exchange delivers messages as they arrive and match the subscriber 
   criteria. 

Subscriber are assumed to be mapped onto exchange bindings in a N-to-1
relationship (multiple subscriber can use the same exchange binding).

Subscriber Methods
------------------

The subscriber portal defines these request methods:

 - configure - configures a new subscriber using the specified
   arguments. The arguments are: a routing key, an arguments field
   table, and a routing option.  The sink sends a single configure
   method.

The routing options are:

 - "match" - when the subscription matches
 - "copyall" - request a copy of all messages
 - "default" - request all messages that have no other matching sinks.

The subscriber defines these response methods:

 - publish - delivers a message to the sink object.

Subscriber Management
---------------------

AMQP does not implement a cancel method for bindings but this will
probably be added at some stage. Queues do not, in any case, need to
manage subscribers on a per-session (channel) basis.

For now, we can create subscribers and then ignore them, at the queue
side. When the queue is destroyed its subscribers will be destroyed
automatically. The exchange must correctly handle the destruction of
subscribers to keep its routing tables updated.

We will map each subscriber to single exchange binding (holding the
binding reference in the subscriber object) so that bindings can be
destroyed rapidly, without lookups. This can be done trivially using
reference counting (when the last subscriber that uses a binding is
destroyed, the binding is also destroyed).

Delivering Messages off a Queue
===============================

Problem Statement
-----------------

The goal is to abstract the relationship between queues and gateways
(the 'consumer' relationship), in such a way that we can add arbitrary
queue implementations to the server, and they can work correctly with
arbitrary gateway types.

General Solution
----------------

We use a portal, called the "consumer", to connect gateways with queues.

The Consumer Class
------------------

The consumer class (mb_consumer) is a portal that connects an arbitrary
client class (the gateway) to a server class (the queue). Consumer
creation is always invoked from the gateway side.

Consumers work as follows:

 - A gateway object creates a consumer using the normal portal creation
   mechanism (it asks the queue to create the portal, then it binds this
   portal to itself).

 - The gateway configures the consumer by sending a single "configure"
   method to it, and thus to the queue. The queue handles the configure
   method by adding the consumer to its list of active consumers.

 - Consumers have a set of properties (like the no-local and prefetch
   options), which the queue uses when selecting consumers. To avoid
   concurrency issues on consumers, we se these properties from the
   queue, not the gateway.
   
 - The gateway configures the consumer by sending "quality" methods to
   it, and thus to the queue. The queue handles the configure method by
   updating its own data structures. and by setting properties in the
   consumer.

 - The queue uses its list of consumers to delivers messages as they
   arrive and match the consumer criteria and queue round-robinning
   mechanisms.

Consumer Methods
----------------

The consumer defines these request methods:

 - configure - configures a new subscriber using the specified
   arguments. The arguments are: a routing key, an arguments field
   table, and a routing option.  The sink sends a single configure
   method.

 - quality - sets the quality of service for the consumer.  The gateway
   can send zero or more quality methods.

 - ack - acknowledges a set of delivered messages, for consumers that
   use explicit acknowledgements.

 - enable - enables the consumer.

 - disable - disables the consumer.

The consumer defines these response methods:

 - deliver - delivers a message to the gateway.

