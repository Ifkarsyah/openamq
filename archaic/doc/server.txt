gdl
    title     = OpenAMQ Server
    subtitle  = Installation and Use of the OpenAMQ Server
    product   = OpenAMQ
    author    = iMatix Corporation <amq@imatix.com>
    date      = 2006/04/24
    copyright = Copyright (c) 2004-2006 JPMorganChase
    version   = 1.0c
end gdl

Overview
********

Introduction
============

OpenAMQ is a superior implementation of the AMQ middleware protocol
standard (AMQP). It provides a reliable, fast, portable (along with
clients for various languages), industry-standards-compatible (e.g. JMS)
open source platform for service-oriented networks.

AMQ ("Advanced Message Queues") is commodity middleware for use in large-scale
business and financial applications. It consists of:

 1. An industry-standard wire-level protocol (AMQP) that lets application
    clients talk to an AMQ server.

 2. A modular framework (called "Advanced Message Queues", or AMQ).  The AMQ
    framework consists of a set of components that route and store messages
    within a central server, plus a set of rules for wiring these components
    together (all of which defines the semantics of the middleware server).

For more information on AMQ, please visit the openamq.org Open Source community.
This document provides a guide to installing and using the OpenAMQ server.

Functional Description
======================

The current version of OpenAMQ is capable of:

Industry standard messaging models such as topics and queues:
    OpenAMQ implements a high-level protocol which is fully capable of, but not
    limited to, the Java Message Service. A JMS wrapper is provided as part of
    the server package. The JMS wrapper allows for Java applications to join the
    service network easily (and no native libraries are required).

Flexible and extensible high-performance message delivery:
    The exchange is a concept unique to OpenAMQ, it is a kind of plug-in mechanism
    that allows for different message distribution schemes, such as publish-subscribe
    and point-to-point. Different types of exchanges can be created to solve diferent
    needs with high efficiency (For example Broadcast (Fan-out), SQLXX, Load-balancing).

Out-of-band message delivery*:
    Messages can be sent using out-of-band transport. The specific out-of-band
    transport used, and its configuration, is defined when a channel is opened.

High performance transactions:
    OpenAMQ supports distributed* and non-distributed transactions, this gives flexibility
    for different application needs. From the client's point of view there's no difference
    between the non-transacted, transacted, and distributed transactions model. Compatibility
    of AMQ transactions with XA distributed transactions is yet to be implemented.

Clustering and scalability:
    AMQ clustering covers the following features:
    1. Simple to configure, administrater, and use in applications.
    2. Ability to scale to any size.
    3. Ability to use arbitrary storage systems (SAN, RAID, IDE).
    4. A single solution that provides both scalability and reliability,
       albeit targetted towards specific application scenarios.

Persistent and non-persistent messages:
    The server makes a best-effort to hold persistent messages on a reliable 
    storage mechanism.
    
Message prioritisation:
    OpenAMQ implements 10 priority levels per queue.

Restartable message transfer for large messages*:
    This helps on low-quality connections.

Connection heartbeats:
    The heartbeat function allows peers to detect network failure rapidly, otherwise it  
    can be slow to detect that a peer process has gone "offline". 

Message payload capacity from 1 octet to 1.6 teraoctets:
    In practice, the limit is stablished by the current resources, OS and network 
    layers.

Virtual hosts:
    OpenAMQ allows for configuration flexibility and resources optimization by alowing
    virtual host definitions over a single piece of hardware.

Multiplexed AMQP protocol with up to 64k channels per socket (connection):
    The channels per socket limit depends in practice on the hardware resources 
    available. 

Large numbers of readers per queue with configurable dispatching models:
    Dispatching type can be configured using exchanges and bindings (for topics, 
    round-robin, fan-out, etc.). Bindings are the parameters the exchange receives 
    for message subscription (such as in topics).

Extensible security and authentication mechanism*:
    OpenAMQ can use a basic user/password authentication mechanism, or other
    more secure industry-standard authentication mechanisms.

XML-based configuration files:
    The server configuration file controls authentication, connection defaults, 
    virtual host setup, resource limits and logging.  

Remote administration tools:
    The AMQ console is designed to allow remote configuration, control and 
    management of an AMQ server.
    
(* = planned)    

Technical Description
=====================

AMQP classes and methods:
-------------------------

The AMQP methods (the protocol frames) are grouped in classes. There are 
classes that cover basic functionality, such as: connection, channel, basic
(basic message handling), queue. There are also clases for more specialized 
functionality, for example: Access, Transaction. This architecture makes
AMQP open to enhancements/specialization through the addition of new 
functionality classes. 

The included JMS wrapper sends and receives methods from all of the mentioned 
classes and others (through Apache MINA), but JMS does not cover all of the 
features of existing messaging systems, that would be too complicated. If full 
interoperability with some complex legacy system is required, then coding a set 
of specialized classes for that purpose is the straight-forward solution possible 
with AMQP. 
    
AMQ queues and exchanges:
-------------------------

An AMQ "exchange" accepts messages from a client application - the publisher - 
and routes these to queues according to pre-arranged criteria. These criteria
are called "bindings". AMQ exchanges are matching and routing entities. That is,
they inspect messages and using their binding tables, decide how to forward these
messages to AMQ queues or other exchanges. AMQ exchanges never store messages.

For new specialized functionality needs, it will probably suffice to code 
a new exchange class. Exchanges allow for an extensible framework which makes
it possible to add new functionality, in a useful place and in a simple way.

Zero-copy and out-of-band techniques:
-------------------------------------

The message payload (content body) is always placed in separated frames (as 
compared to including the header and body in the protocol method). We want to 
support "zero copy" techniques in which content is never marshalled or encoded, 
and can be sent via out-of-band transport such as shared memory or remote DMA.

Reliability:
------------

OpenAMQ provides a rich set of features and options for scalability and 
reliability. Cluster reliability can be:

- Fully transient: the message is held only in one memory and is lost if that memory 
  is reset.
- Reliable transient: the message is replicated to a second memory and is lost only 
  if both memories are reset.
- Persistent: the message is saved to a single disk system and is lost if that disk 
  system is damaged.
- Reliable persistent: the message is saved to two distinct disk systems and is lost 
  only if both disk systems are damaged.

Reliable distinguishes two types of servers, one acting as primary and one as 
secondary. In normal operation, all clients connect to the primary server. Each 
server maintains its own storage, and the primary server replicates transactions 
to the secondary server. If the primary server fails, the client detects this and 
switches to the backup server.

Persistent messages are held on a reliable storage mechanism; non-persistent messages 
are lost between server starts and when space for persistent/priority messages is 
needed. AMQP allows 10 priority levels per queue. At least 2 priority levels must be 
supported on any AMQ implemenetation.

The client applications can choose between distributed (XA) and not distributed 
transaction models. Non-distributed transactions have higher performace, but do
not meet every application's needs.

Although TCP/IP guarantees that data is not dropped or corrupted it can be slow to
detect that a peer process has gone "offline". The heart beat is a frame that is
sent periodicaly between server and client. Abscence of the signal (timeout) alerts
that at the other side of the connection the process has stopped responding.

Scalability:
------------

The technical description for cluster scalability is beyond the reach of this
document. Please refer to [7], in the references list at the end of this 
document.

Hardware load scalability. Virtual hosts allow to make optimal use of one piece of 
hardware. Virtual hosts are independent server domains that share a common authentication 
and encryption environment. The client chooses a virtual host as the last stage in 
negotiating the connection.

AMQP/Fast is designed to give a useful lifespan of 50 years or more. Our goal is 
that an AMQP/Fast peer will be able to operate continuously with no upgrades or
incompatibility for at least this duration, without requiring "legacy support".

Configuration and administration:
---------------------------------
    
The server uses layered XML configuration files. The layered feature allows for a quick 
start and easy maintenance on upgrades. Please see the server configuration section later 
in this document.

The AMQ remote administration interface covers this features:

- It is portable to any desired user interface technology, including
  web, command-line, JMX, etc. Ideally, end-users should be able to
  make customised operator interfaces, scripts, etc.

- Uses data schemas that clients can refer to, to adapt statically 
  or dynamically as suitable.

- It is generally compatible with conventional console abstractions,
  e.g. Java management beans.
   
- Provides access to all "operable" internals of the server, i.e.
  to any object that may be tuned, configured, or managed; and keeps
  private all aspects of the server that are not "operable" or 
  that if touched may cause harm by misuse.

- Eventually, it will be transactional, so that operations are completed
  fully, or not at all.

Operational Requirements
========================

Basic requirements
------------------

OpenAMQ runs on Solaris, Linux and win32 (Windows 95/98/XP/2000/2003).  The 
server uses about 10-20MB of memory depending on whether it is built with debug
information or not. For production you should provide sufficient memory 
depending on the total estimated number of messages to be held in memory (we 
recommend to start with at least 256MB).

For operation on Solaris/Linux you should build the server from source.  The 
Unix source package should build, but has not been qualified, on other Unix 
systems. For operation on win32 you can either build from source (you then need
MSVC 6 or 7) or use the pre-built binaries.

The OpenAMQ source packages are self-contained. External software is only
needed for optional modules (see below: Optional Software).

Compatability
-------------

The OpenAMQ server is compiled from ANSI C. Most of the code is generated from iCL, 
which uses a simple XML language that is self-descriptive and easy to read and write. 
iCL (the iMatix Class Library) aims to provide portable, fast and operationally stable 
ANSI C applications. iCL is loosely based on object-oriented concepts (desirable for 
very large and very high-quality applications). 

iCL applications make calls to the Apache Runtime library (APR), for certain 
functions. OpenAMQ can be ported easily to any platform where ANSI C is supported
and in which APR runs. However, performance may vary from one platform to another,
depending on the availability of APR assembler optimizations for a given platform.
Compatability, with little or no modifications, over a wide range of systems is not 
only guaranteed by ANSI C and APR, but by iCL's code generation advantages.

Optional Software
-----------------

OpenAMQ's JMS layer requires the following software for building from source packages:

- <http://java.sun.com/j2se/1.5.0/download.jsp: J2SE JDK 1.5>
- <http://ant.apache.org/bindownload.cgi: Apache ANT>

If the JDK or ANT are missing, the JMS layer will not be built or installed.

OpenAMQ's COM objects:

In progress.

Installing OpenAMQ
******************

Binary Distributions
====================

Not yet available.

Source Packages
===============

Getting started
---------------

The first step is to download the OpenAMQ package. By downloading the software 
you confirm that you understand and accept the terms described on the License
agreement.

- <http://www.openamq.org/license.html: License agreement>
- <http://www.openamq.org/download.html: OpenAMQ platform download>

There are packages suitable for both Unix and Windows deployment. The packages contain:

- The OpenAMQ server source code
- The JMS layer source code
- The management console source code
- The client examples source code
- The platform documentation
- Regression and coverage tests

Building and installing
-----------------------

The next step is to setup the environment, then building and installing. It is recommended to 
set up permanently the environment variables (according to the correct procedure for the OS and
shell in use).

    unix:
    export IBASE=<install directory>                # Set the iMatix deployment location
    export PATH=$PATH:$IBASE/bin                    # Set the path to the executables
    
    tar -zxf OpenAMQ-<version>.tar.gz               # Unpack
    cd OpenAMQ-<version> 
    sh build.sh                                     # Build, install and perform auto-testing
    
    windows:
    set IBASE=<install directory>                   # Set the iMatix deployment location
    set PATH=%PATH%;%IBASE%/bin                     # Set the path to the executables
    
    # Unzip OpenAMQ-<version>.zip
    cd OpenAMQ-<version> 
    build                                           # Build, install and perform auto-testing

Public Subversion Access
=========================

Not yet available.

The Messaging Server
********************

Main Server Configuration
=========================

The OpenAMQ server is installed along with a default server configuration 
file. The configuration file is read at startup time, if a configuration change 
needs to be done, the server needs to be restarted before changes will apply. 
The server will not accept connections if it is started outside of the directory 
which contains the server.cfg file.

Configuration Options
---------------------

The amq_server_base.cfg file provides the server with its (default) overall configuration.

    <server
        port = "5672"
        background = "0"
        queue_timeout = "5"
        />

server:port:
    Specifies the port on which the server should open its connections
    (5672 is the default). Note that this value can be overridden on the
    command line using the --port option.

    If you want to run multiple OpenAMQ servers on the same system you can
    assign each one its own port.

server:background:
    Used on Unix/Linux only. If set, the server will automatically
    detatch itself from the console and move into the background when
    started from a console.  This is useful if you have to run the
    server manually.

server:queue_timeout:
    Specifies the delay, in seconds, after which auto-deleted queues
    are effectively deleted, following disconnection of their last
    consumer.  If zero, queues are deleted immediately.

    <resources
        max_memory_mb = "1024"
        monitor = "1"
        dump_state = "0"
        />
        
resources:max_memory_mb:
    Specifies the maximum memory allowed for the server, in MB. When the
    server reaches this limit, it will slow down publishers. If zero, no
    limit is enforced.

resources:monitor:
    Specifies the interval in seconds at which the server will
    report its message rates (e.g. number of messages queued per second, number 
    of messages dispatched per second, etc.).  If zero, no monitoring is shown. 
    The recommended value is 1, if monitoring is desired.

resources:dump_state:
    Specifies the interval at which the server will report its state.
    This shows the number of messages, queues, consumers, etc. used by
    the server. If zero, no state is logged.

    <cluster
        host = "localhost:5672"
        vhost = "/my_vhost"
        state_mb = "32"
        heartbeat = "5"
        rebalance = "5"
        />

cluster:host:
    Specifies the ip-address and port to use for incoming cluster connections
    if the server runs on multiple IP addresses.  If not specified, the
    cluster will connect to this server on its first IP address.

cluster:vhost:
    Specifies the cluster vhost name, which must be identical for
    all servers in a cluster.  Any string, up to 255 chars long,
    can be used.  Note that applications must use the same virtual
    host name when connecting to the cluster.

cluster:state_mb:
    Specifies the maximum amount of memory in MB reserved for the
    cluster state.  Note that this state will grow as the cluster is
    used.  If zero, no limit is enforced (this is not recommended).

cluster:heartbeat:
    Specifies the heartbeat interval in seconds.  Use higher heartbeat
    times only when working across a WAN where rapid heartbeats have a
    visible cost.  Faster heartbeating is generally better if the network
    can handle the traffic.

cluster:rebalance:
    Specifies the accuracy of cluster rebalancing.  A cluster server 
    will redirect clients when it finds another cluster server with
    this amount fewer clients.  When set to zero, the cluster will
    never redirect clients.

    <logging
        log_path = "logs"
        keep_logs = "1"
        archive_path = "archive"
        archive_cmd = ""
        alert_log = "alert.log"
        daily_log = "daily.log"
        debug_log = "debug.log"
        trace_route = "0"
        trace_queue = "0"
        trace_cluster = "0"
        trace = "0"
        />

logging:log_path:
    Specifies the directory path into which active log files are
    placed.

logging:keep_logs:
    Specifies whether or not the server should keep logs.  If zero,
    the server will not keep logs.  If 1, it will keep an alert log,
    a daily log, and a debug log as specified.

logging:archive_path:
    Specifies the directory path into which archived log files are
    placed.  This can be the same as the log path; archived log
    files are renamed to avoid conflict with active log files.

logging:archive_cmd:
    If specified, this command is run on all archived log files. You can
    use this option to compress archived log files, or clean up old and
    unwanted files.  When the command is run, the name of the archived
    log file is provided as an argument to it.

logging:alert_log:
    The name of the alert log file, which records all errors and warnings
    issued by the server.  Note that the server port number is always added
    to the name of the log file.

logging:daily_log:
    The name of the daily log file, which records all normal activity
    as well as errors. Note that the server port number is always added
    to the name of the log file.

logging:debug_log:
    The name of the debug log file, which records all normal activity,
    errors, and debug trace information. Note that the server port number
    is always added to the name of the log file.

logging:trace_route:
    Specifies whether exchange routing is logged or not. Set this
    option when you are debugging a message routing design.  For
    production use, we recommend you do not set this option.

logging:trace_queue:
    Specifies whether queue dispatching is logged or not.  Set this
    option when you are debugging message processing in the server.
    For production use, we recommend you do not set this option.

logging:trace_cluster:
    Specifies whether cluster activity is logged or not.  Set this
    option when you are configuring or debugging a cluster.  For
    production use, we recommend you do not set this option.

logging:trace:
    Specifies the protocol debug level, which can be 0 (no tracing),
    1 (show information and protocol methods), 2 (show protocol
    animation), 3 (show wire-level data).  You should not use any
    tracing on production servers except in low-volume scenarios.

    <tuning
        packio = "0"
        read_timeout = "30"
        write_timeout = "30"
        polling_threads = "4"
        working_threads = "4"
        poll_frequency = "0"
        tcp_nodelay = "1"
        tcp_rcvbuf = "0"
        tcp_sndbuf = "0"
        />

tuning:packio:
    If set, data is packed into larger buffers before writing. This
    can improve performance significantly on some systems, especially
    Windows and Linux with 2.4 kernels. If you disable this setting,
    you should test the performance using a bulk message transfer
    test.

tuning:read_timeout:
    Defines the timeout for network reads.  If a peer does not respond
    within this time, it is considered dead.  If you get unexpected
    timeout errors in the logs, you may want to increase this value.

tuning:write_timeout:
    Defines the timeout for network writes.  If a peer does not accept
    data within this time, it is considered dead.  If you get
    unexpected timeout errors in the logs, you may want to increase
    this value.

tuning:polling_threads:
    On multithreaded builds, defines the number of OS threads dedicated
    to socket polling.

tuning:poll_frequency:
    To experiment with the effect of different socket polling strategies we
    allow the user to set the frequency of non-essential socket polling.
    Zero means no non-essential polling, one means maximal non-essential
    polling, and in general N means do non-essential polling one time in N.
    The maximum valid value for this setting is 1024.

tuning:working_threads:
    On multithreaded builds, defines the number of OS threads dedicated to
    processing, that is, tasks other than socket polling.

tuning:tcp_nodelay:
    If this value is 1, socket data is written immediately, which is
    usually good for latency.  If this value is 0, data is buffered
    until there is a full packet, which is usually good for throughput.

tuning:tcp_rcvbuf:
    If this value is greater than zero, all client connections will use
    the specified value.  Note: setting this value is delicate, do not
    use this option unless you know what you are doing.

tuning:tcp_sndbuf:
    If this value is greater than zero, all client connections will use
    the specified value.  Note: setting this value is delicate, do not
    use this option unless you know what you are doing.

    <internal
        packio = "0"
        auto_crash = "1"
        auto_block = "1"
        kernel_limit = "0"
        />

internal:auto_crash:
    If set, the server will crash at irregular intervals, being some random
    point within the number of seconds specified.  This is used specifically
    to test applications for failover and robustness.  Set to zero for all
    real usage.

internal:auto_block:
    If set, the server will block at irregular intervals, being some random
    point within the number of seconds specified.  This is used specifically
    to test applications for failover and robustness.  Set to zero for all
    real usage.

internal:kernel_limit:
    Sets an action limit for the SMT kernel: after this many steps it will
    exit.  Use this to break the server for failure testing.  Set to zero for
    all real usage.

Layered Configuration Files
---------------------------

To avoid loss of modified configurations, you should not edit the provided
server.cfg file.  Since each release of the server comes with new and
expanded versions of this file, editing it would mean that you had to merge
your changes into each new release of the file.

OpenAMQ uses a technique called "layered configuration files" to avoid this
problem.  Create a new file called "custom.cfg" and place your custom
settings in that file.

For example:

    <config>
        <cluster
            vhost = "/"
            host = ""
            state_mb = "250"
            heartbeat = "5"
            >
            <server name = "cluster-001" host = "localhost:5000" primary = "1" />
            <server name = "cluster-002" host = "localhost:5001" backup = "1" />
        </cluster>
    </config>

OpenAMQ loads its pre-supplied configuration from server.cfg, which
provides default values for all settings, and then loads whatever it finds
in custom.cfg.  Since custom.cfg is not part of the installation,
you can safely update your OpenAMQ versions without losing your custom
settings.

Starting and Stopping the Server
================================

To run the server in a console window, start in the directory containing
the server.cfg file (usually $IBASE/bin) and run the command:

    amq_server

To stop the server either press Control-c or call the AMQ shell and type 
'shutdown'. Try the command:

    amq_shell

The amq_server command accepts several options.  Run 'amq_server -h' to see
a help page. If you expect large numbers of clients, increase the polling_threads 
option (see the 'Main Server Configuration' section). It is recommended to allow 50 
clients per polling thread.

clustering
----------

A cluster consists of 1 primary, 1 secondary and N support servers. Please refer to
the configuration section to find out how to set up the cluster configuration. All 
the servers configured must be present for the cluster to start. All the servers of a 
cluster must share the same cluster configuration section. Clients may connect to any 
of the cluster servers, but they must use the same virtual host as defined in the 
cluster configuration section. After a client connects to a server in the cluster,
it may either be redirected to another server (load balancing), or serviced by the 
same server.

See the example custom configuration file in the 'Layered Configuration Files' section;
a most basic cluster configuration section is shown. With such a configuration, we can start
the cluster with the following commands:

    amq_server -c cluster-001 --port 5000           # Start primary server
    amq_server -c cluster-002 --port 5001           # Start secondary server

Examples and tests
------------------

The last step is to begin using the server. The easiest way by far is to
experiment with the pal example test cases. Pal scripts are easy to read 
(XML specification) and generally simple. Before running test cases, they 
must be compiled:

    pal <script name>.pal                           # It's that easy :)

Plenty of interesting scripts can be found on the following locations:

    cd OpenAMQ-<version>/examples                   # Simple use-cases scripts
    cd OpenAMQ-<version>/doc/tests                  # Coverage tests

To run a full covrage test, do the following:

    unix:
    cd OpenAMQ-<version>/doc/tests
    sh run
    
    windows (not yet available):
    cd OpenAMQ-<version>/doc/tests
    run


The C Client API - C
********************

The standard C client API is built using the same technology as the
OpenAMQ server, and provides a component-based interface to the AMQ
protocol from the client side.

Unlike other messaging systems where JMS is fully supported, OpenAMQ's C API 
is NOT meant as a secondary API, used for special cases such as legacy support.
The C API is OpenAMQ's main API, it is very fast, simple and provides some additional 
functionality that is not present in JMS. Please refer to [5] for the C client API 
full documentation.

The C++ Client API
******************

In progess.

The JMS Client API
******************

The JMS client API is still under development, the aim is to have a complete,
fully JMS-compatible implementation. See [4] for details on the official JMS API
and documentation.

Protocol Automation Language (PAL)
**********************************

PAL is a scripting system for AMQP clients. Mainly, we built PAL to make it 
simple to write test cases for OpenAMQ. Cheap large-scale testing is the problem 
that PAL solves. Please refer to [6] for the PAL documentation. 

Troubleshooting
***************

Client application behaves erratically
======================================

Please make sure that you have compiled both the server and the client with the 
same build-time options. E.g. a threading model mismatch between client and server
can lead to the client behaving erratically or crashing.
 
You can check the build-time options with the '-v' switch, e.g.:

    amq_server -v

Can't build from svn
====================

Please get the latest bootstrap packages from:

- <http://www.imatix.net/pub/: iMatix Technology Packages>

Then build each one of the bootstrap packages (base, foreign, gsl). Finally, try 
again to rebuild the OpenAMQ directories in the following order (using boom all):

base, gsl4, foreign, base2, openamq

Command not found
=================

Please set the IBASE and PATH variables to point to the directory that was used 
for deployment. See the section:

Installing OpenAMQ/Building and installing.

Reference Information
*********************

 1. <http://www.openamq.org: OpenAMQ Open Source community>
 2. <http://www.openamq.org/library.html: OpenAMQ Documentation>
 3. <http://wiki.openamq.org/cgi-bin/wiki: OpenAMQ Wiki>
 4. <http://java.sun.com/products/jms/docs.html: JMS Documentation>
 5. <http://wiki.openamq.org/cgi-bin/wiki/StdCapi: Standard C API Documentation>
 6. <http://wiki.openamq.org/cgi-bin/wiki/PalGuide: PAL documentation>
 7. <http://wiki.openamq.org/cgi-bin/wiki/AmqClustering: AMQ Clustering documentation>
