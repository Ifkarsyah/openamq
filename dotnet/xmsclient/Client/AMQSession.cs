using System;
using System.Collections;
using System.Threading;
using JPMorgan.Collections;
using jpmorgan.mina.common;
using log4net;
using OpenAMQ.Framing;
using IBM.XMS;
using OpenAMQ.XMS.Client.Message;
using OpenAMQ.XMS.Client.Protocol;
using OpenAMQ.XMS.Client.State.Listener;

namespace OpenAMQ.XMS.Client
{
    public class AMQSession : Closeable, IBM.XMS.ISession
    {
        private static readonly ILog _logger = LogManager.GetLogger(typeof(AMQSession));

        private const int DEFAULT_PREFETCH = 1;

        private AMQConnection _connection;

        private bool _transacted;

        private AcknowledgeMode _acknowledgeMode;

        private ushort _channelId;

        private int _defaultPrefetch = DEFAULT_PREFETCH;

        private BlockingQueue _queue = new LinkedBlockingQueue();

        private Dispatcher _dispatcher;

        private MessageFactoryRegistry _messageFactoryRegistry;

        /// <summary>
        /// Set of all producers created by this session
        /// </summary>
        private Hashtable _producers = Hashtable.Synchronized(new Hashtable());

        /// <summary>
        /// Maps from consumer tag to JMSMessageConsumer instance
        /// </summary>
        private Hashtable _consumers = Hashtable.Synchronized(new Hashtable());

        /// <summary>
        /// The counter of the next producer id. This id is generated by the session and used only to allow the
        /// producer to identify itself to the session when deregistering itself.
        ///
        /// Access to this id does not require to be synchronized since according to the JMS specification only one
        /// thread of control is allowed to create producers for any given session instance.
        /// </summary>
        private long _nextProducerId;

        /// <summary>
        /// Responsible for decoding a message fragment and passing it to the appropriate message consumer.
        /// </summary>
        private class Dispatcher
        {
            private int _stopped = 0;

            private AMQSession _containingSession;
            
            public Dispatcher(AMQSession containingSession)
            {
                _containingSession = containingSession;
            }
            
            /// <summary>
            /// Runs the dispatcher. This is intended to be run in a separate thread.
            /// </summary>
            public void RunDispatcher()
            {
                UnprocessedMessage message;

                
                while (_stopped == 0 && (message = (UnprocessedMessage)_containingSession._queue.DequeueBlocking()) != null)
                {
                    //_queue.size()
                    DispatchMessage(message);
                }                

                _logger.Info("Dispatcher thread terminating for channel " + _containingSession._channelId);
            }

            private void DispatchMessage(UnprocessedMessage message)
            {
                if (message.DeliverBody != null)
                {
                    BasicMessageConsumer consumer = (BasicMessageConsumer) _containingSession._consumers[message.DeliverBody.ConsumerTag];

                    if (consumer == null)
                    {
                        _logger.Warn("Received a message from queue " + message.DeliverBody.ConsumerTag + " without a handler - ignoring...");
                    }
                    else
                    {
                        consumer.NotifyMessage(message, _containingSession.AcknowledgeMode, _containingSession.ChannelId);
                    }
                }
                else
                {
                    try
                    {
                        // Bounced message is processed here, away from the mina thread
                        AbstractXMSMessage bouncedMessage = _containingSession._messageFactoryRegistry.
                                                                CreateMessage(0, false, message.ContentHeader, message.Bodies);

                        int errorCode = message.BounceBody.ReplyCode;
                        string reason = message.BounceBody.ReplyText;
                        _logger.Debug("Message returned with error code " + errorCode + " (" + reason + ")");

                        _containingSession._connection.ExceptionReceived(new AMQUndeliveredException(errorCode, "Error: " + reason, bouncedMessage));
                    }
                    catch (Exception e)
                    {
                        _logger.Error("Caught exception trying to raise undelivered message exception (dump follows) - ignoring...", e);
                    }
                }
            }

            public void StopDispatcher()
            {
                Interlocked.Exchange(ref _stopped, 1);                
                //interrupt(); // TODO: change this to .Net threading style
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AMQSession"/> class.
        /// </summary>
        /// <param name="con">The con.</param>
        /// <param name="channelId">The channel id.</param>
        /// <param name="transacted">if set to <c>true</c> [transacted].</param>
        /// <param name="acknowledgeMode">The acknowledge mode.</param>
        /// <param name="messageFactoryRegistry">The message factory registry.</param>
        internal AMQSession(AMQConnection con, ushort channelId, bool transacted, AcknowledgeMode acknowledgeMode,
                            MessageFactoryRegistry messageFactoryRegistry)
        {
            _connection = con;
            _transacted = transacted;
            if (transacted)
            {
                _acknowledgeMode = AcknowledgeMode.SessionTransacted;
            }
            else
            {
                _acknowledgeMode = acknowledgeMode;
            }
            _channelId = channelId;
            _messageFactoryRegistry = messageFactoryRegistry;
        }

        internal AMQSession(AMQConnection con, ushort channelId, bool transacted, AcknowledgeMode acknowledgeMode)
            : this(con, channelId, transacted, acknowledgeMode, MessageFactoryRegistry.NewDefaultRegistry())
        {            
        }

        internal AMQConnection AMQConnection
        {
            get
            {
                return _connection;
            }
        }

        public IBytesMessage CreateBytesMessage()
        {
            CheckNotClosed();
            try
            {
                return (IBytesMessage) _messageFactoryRegistry.CreateMessage("application/octet-stream");
            }
            catch (AMQException e)
            {
                throw new XMSException("Unable to create message: " + e);
            }
        }

        public IMapMessage CreateMapMessage()
        {
            CheckNotClosed();
            try
            {
                return (IMapMessage) _messageFactoryRegistry.CreateMessage("jms/map-message");
            }
            catch (AMQException e)
            {
                throw new XMSException("Unable to create message: " + e);
            }
        }

        public IMessage CreateMessage()
        {
            CheckNotClosed();
            try
            {
                // TODO: this is supposed to create a message consisting only of message headers
                return (IBytesMessage) _messageFactoryRegistry.CreateMessage("application/octet-stream");
            }
            catch (AMQException e)
            {
                throw new XMSException("Unable to create message: " + e);
            }
        }

        public IObjectMessage CreateObjectMessage()
        {
            CheckNotClosed();
            try
            {
                return (IObjectMessage) _messageFactoryRegistry.CreateMessage("application/java-object-stream");
            }
            catch (AMQException e)
            {
                throw new XMSException("Unable to create message: " + e);
            }
        }        

        public IStreamMessage CreateStreamMessage()
        {
            CheckNotClosed();
            // TODO Auto-generated method stub
            throw new Exception("Not implemented");
            return null;
        }

        public ITextMessage CreateTextMessage()
        {
            CheckNotClosed();

            try
            {
                return (ITextMessage) _messageFactoryRegistry.CreateMessage("text/plain");
            }
            catch (AMQException e)
            {
                throw new XMSException("Unable to create message: " + e);
            }
        }

        public ITextMessage CreateTextMessage(string text)
        {
            CheckNotClosed();
            try
            {
                ITextMessage msg = (ITextMessage) _messageFactoryRegistry.CreateMessage("text/plain");
                msg.Text = text;
                return msg;
            }
            catch (AMQException e)
            {
                throw new XMSException("Unable to create message: " + e);
            }
        }

        public bool Transacted
        {
            get
            {
                CheckNotClosed();
                return _transacted;
            }
        }

        public AcknowledgeMode AcknowledgeMode
        {
            get
            {
                CheckNotClosed();
                return _acknowledgeMode;
            }
        }

        public void Commit()
        {
            CheckNotClosed();
            CheckTransacted(); // throws IllegalOperationException if not a transacted session

            /*Channel.Commit frame = new Channel.Commit();
            frame.channelId = _channelId;
            frame.confirmTag = 1;*/

    //        try
    //        {
    //            _connection.getProtocolHandler().writeCommandFrameAndWaitForReply(frame, new ChannelReplyListener(_channelId));
    //        }
    //        catch (AMQException e)
    //        {
    //            throw new JMSException("Error creating session: " + e);
    //        }
            throw new Exception("Not implemented");
            _logger.Info("Transaction commited on channel " + _channelId);
        }

        public void Rollback()
        {
            CheckNotClosed();
            CheckTransacted(); // throws IllegalOperationException if not a transacted session

            /*Channel.Rollback frame = new Channel.Rollback();
            frame.channelId = _channelId;
            frame.confirmTag = 1;*/

    //        try
    //        {
    //            _connection.getProtocolHandler().writeCommandFrameAndWaitForReply(frame, new ChannelReplyListener(_channelId));
    //        }
    //        catch (AMQException e)
    //        {
    //            throw new JMSException("Error rolling back session: " + e);
    //        }
             throw new Exception("Not implemented");
            _logger.Info("Transaction rolled back on channel " + _channelId);
        }

        public override void Close()
        {
            // We must close down all producers and consumers in an orderly fashion. This is the only method
            // that can be called from a different thread of control from the one controlling the session

            lock (_closingLock)
            {
                Interlocked.Exchange(ref _closed, CLOSED);

                // we pass null since this is not an error case
                CloseProducersAndConsumers(null);

                try
                {
                    _connection.ProtocolHandler.CloseSession(this);
                }
                catch (AMQException e)
                {
                    throw new XMSException("Error closing session: " + e);
                }
                finally
                {
                    _connection.DeregisterSession(_channelId);
                }
            }
        }

        /// <summary>
        /// Close all producers or consumers. This is called either in the error case or when closing the session normally.
        /// <param name="amqe">the exception, may be null to indicate no error has occurred</param>
        ///
        private void CloseProducersAndConsumers(AMQException amqe)
        {
            try
            {
                CloseProducers();
            }
            catch (XMSException e)
            {
                _logger.Error("Error closing session: " + e, e);
            }
            try
            {
                CloseConsumers(amqe);
            }
            catch (XMSException e)
            {
                _logger.Error("Error closing session: " + e, e);
            }
        }

        /// <summary>
        /// Called when the server initiates the closure of the session
        /// unilaterally.
        /// </summary>
        /// <param name="e">the exception that caused this session to be closed</param>
        ///         
        public void Closed(Exception e)
        {
            // An AMQException has an error code and message already and will be passed in when closure occurs as a
            // result of a channel close request
            AMQException amqe;
            if (e is AMQException)
            {
                amqe = (AMQException) e;
            }
            else
            {
                amqe = new AMQException(_logger, "Closing session forcibly", e);
            }
            _connection.DeregisterSession(_channelId);
            CloseProducersAndConsumers(amqe);
        }

        /// <summary>
        /// Called to close message producers cleanly. This may or may <b>not</b> be as a result of an error. There is
        /// currently no way of propagating errors to message producers (this is a JMS limitation).
        /// </summary>
        private void CloseProducers()
        {
            // we need to clone the list of producers since the close() method updates the _producers collection
            // which would result in a concurrent modification exception
            ArrayList clonedProducers = new ArrayList(_producers.Values);
            
            foreach (BasicMessageProducer prod in clonedProducers)
            {
                prod.Close();
            }
            // at this point the _producers map is empty
        }

        /// <summary>
        /// Called to close message consumers cleanly. This may or may <b>not</b> be as a result of an error.
        /// <param name="error">not null if this is a result of an error occurring at the connection level</param>
        ///
        private void CloseConsumers(Exception error)
        {
            if (_dispatcher != null)
            {
                _dispatcher.StopDispatcher();
            }
            // we need to clone the list of consumers since the close() method updates the _consumers collection
            // which would result in a concurrent modification exception
            ArrayList clonedConsumers = new ArrayList(_consumers.Values);

            foreach (BasicMessageConsumer con in clonedConsumers)
            {             
                if (error != null)
                {
                    con.NotifyError(error);
                }
                else
                {
                    con.Close();
                }
            }
            // at this point the _consumers map will be empty
        }

        public void Recover()
        {
            CheckNotClosed();
            CheckNotTransacted(); // throws IllegalOperationException if not a transacted session

            // TODO: This cannot be implemented using 0.8 semantics
        }                

        public void Run()
        {
            // TODO Auto-generated method stub

        }

        public IBM.XMS.IMessageProducer CreateProducer(IDestination destination)
        {
            return CreateProducerImpl(destination);
        }

        private IMessageProducer CreateProducerImpl(IDestination destination)                
        {
            lock (_closingLock)
            {
                CheckNotClosed();

                AMQDestination amqd = (AMQDestination)destination;

                BasicMessageProducer producer = null;
                try
                {
                    producer = new BasicMessageProducer(amqd, _transacted, _channelId,
                                                        this, _connection.ProtocolHandler,
                                                        GetNextProducerId());
                }
                catch (AMQException e)
                {
                    _logger.Error("Error creating message producer: " + e, e);
                    XMSException jmse = new XMSException("Error creating message producer");
                    jmse.LinkedException = e;
                    throw jmse;
                }
                return producer;
            }
        }

        public IBM.XMS.IMessageConsumer CreateConsumer(IDestination destination)
        {
            return CreateConsumer(destination, _defaultPrefetch, false, false, null);
        }

        public IBM.XMS.IMessageConsumer CreateConsumer(IDestination destination, string messageSelector)
        {
            return CreateConsumer(destination, _defaultPrefetch, false, false, messageSelector);
        }

        public IBM.XMS.IMessageConsumer CreateConsumer(IDestination destination, string messageSelector, bool noLocal)
        {
            return CreateConsumer(destination, _defaultPrefetch, noLocal, false, messageSelector);
        }

        public IMessageConsumer CreateConsumer(IDestination destination,
                                               int prefetch,
                                               bool noLocal,
                                               bool exclusive,
                                               string selector)
        {
            return CreateConsumer(destination, prefetch, noLocal, exclusive, selector, null);
        }

        public IMessageConsumer CreateConsumer(IDestination destination,
                                               int prefetch,
                                               bool noLocal,
                                               bool exclusive,
                                               string selector,
                                               FieldTable rawSelector)
        {
            return CreateConsumerImpl(destination, prefetch, noLocal, exclusive,
                                      selector, rawSelector);
        }

        protected IMessageConsumer CreateConsumerImpl(IDestination destination,
                                                      int prefetch,
                                                      bool noLocal,
                                                      bool exclusive,
                                                      string selector,
                                                      FieldTable rawSelector)
        {
            lock (_closingLock)
            {
                CheckNotClosed();

                AMQDestination amqd = (AMQDestination)destination;

                AMQProtocolHandler protocolHandler = _connection.ProtocolHandler;
                BasicMessageConsumer consumer = new BasicMessageConsumer(_channelId, amqd, selector, noLocal,
                                                                         _messageFactoryRegistry, this, protocolHandler);

                string consumerTag = null;
                try
                {
                    // Declare exchange
                    AMQFrame exchangeDeclare = ExchangeDeclareBody.CreateAMQFrame(_channelId, 0, amqd.ExchangeName,
                                                                                  amqd.ExchangeClass, false, false,
                                                                                  false, false, null);

                    protocolHandler.WriteCommandFrameAndWaitForReply(exchangeDeclare,
                                                new SpecificMethodFrameListener(_channelId, typeof(ExchangeDeclareOkBody)));

                    AMQFrame queueDeclare = QueueDeclareBody.CreateAMQFrame(_channelId, 0,
                                                                            amqd.QueueName,
                                                                            false, false, amqd.Exclusive,
                                                                            amqd.AutoDelete, null);

                    AMQMethodEvent evt = protocolHandler.WriteCommandFrameAndWaitForReply(queueDeclare,
                                                 new SpecificMethodFrameListener(_channelId, typeof(QueueDeclareOkBody)));
                    QueueDeclareOkBody qdb = (QueueDeclareOkBody) evt.Method;
                    amqd.QueueName = qdb.Queue;

                    // Bind exchange to queue
                    // TODO: construct the rawSelector from the selector string if rawSelector == null
                    FieldTable ft = new FieldTable();
                    //if (rawSelector != null)
                    //    ft.put("headers", rawSelector.getDataAsBytes());
                    if (rawSelector != null)
                    {
                        ft.AddAll(rawSelector);
                    }
                    AMQFrame queueBind = QueueBindBody.CreateAMQFrame(_channelId, 0,
                                                                      amqd.QueueName, amqd.ExchangeName,
                                                                      amqd.RoutingKey, ft);

                    protocolHandler.WriteCommandFrameAndWaitForReply(queueBind,
                                                  new SpecificMethodFrameListener(_channelId, typeof(QueueBindOkBody)));

                    // Consume from queue
                    AMQFrame jmsConsume = BasicConsumeBody.CreateAMQFrame(_channelId, 0,
                                                                          qdb.Queue, null, 0,
                                                                          (ushort)prefetch, noLocal, true, exclusive);

                    AMQMethodEvent consumeOkEvent = protocolHandler.WriteCommandFrameAndWaitForReply(jmsConsume,
                                                     new SpecificMethodFrameListener(_channelId,
                                                                                     typeof(BasicConsumeOkBody)));

                    consumerTag = ((BasicConsumeOkBody) consumeOkEvent.Method).ConsumerTag;
                    consumer.ConsumerTag = consumerTag;
                    RegisterConsumer(consumerTag, consumer);
                }
                catch (AMQException e)
                {
                    if (consumerTag != null)
                    {
                        DeregisterConsumer(consumerTag);
                    }
                    throw new XMSException("Error creating consumer: " + e);
                }

                return consumer;
            }
        }

        public IDestination CreateQueue(string queueName)
        {
            // TODO Auto-generated method stub
            return null;
        }       

        public IDestination CreateTopic(String topicName)
        {
            // TODO Auto-generated method stub
            return null;
        }        

        public IBM.XMS.IMessageConsumer CreateDurableSubscriber(IDestination topic, string name)
        {
            throw new Exception("Not implemented");
            return null;
        }

        public IBM.XMS.IMessageConsumer CreateDurableSubscriber(IDestination topic, string name, string messageSelector, bool noLocal)                
        {
            throw new Exception("Not implemented");
            return null;
        }

        public IQueueBrowser CreateBrowser(IDestination queue)
        {
            throw new Exception("Not implemented");
            return null;
        }

        public IQueueBrowser CreateBrowser(IDestination queue, string messageSelector)
        {
            throw new Exception("Not implemented");
            return null;
        }

        public IDestination CreateTemporaryQueue()
        {
            throw new Exception("Not implemented");
            return null;
        }

        public IDestination CreateTemporaryTopic()
        {
            throw new Exception("Not implemented");
            return null;
        }

        public void Unsubscribe(String name)
        {
            throw new Exception("Not implemented");            
        }

        private void CheckTransacted()
        {
            if (!Transacted)
            {
                throw new IllegalStateException("Session is not transacted");
            }
        }

        private void CheckNotTransacted()
        {
            if (Transacted)
            {
                throw new IllegalStateException("Session is transacted");
            }
        }

        public void MessageReceived(UnprocessedMessage message)
        {
            if (_logger.IsDebugEnabled)
            {
                _logger.Debug("Message received in session with channel id " + _channelId);
            }            
            _queue.EnqueueBlocking(message);         
        }

        public int DefaultPrefetch
        {
            get
            {
                return _defaultPrefetch;
            }
            set
            {
                _defaultPrefetch = value;
            }
        }        

        public ushort ChannelId
        {
            get
            {
                return _channelId;
            }
        }

        public AMQConnection Connection
        {
            get
            {
                return _connection;
            }
        }
        
        /// <summary>
        /// Send an acknowledgement for all messages up to a specified number on this session.
        /// <param name="messageNbr">the message number up to an including which all messages will be acknowledged.</param>
        /// </summary>
        public void SendAcknowledgement(ulong messageNbr)
        {
            if (_logger.IsDebugEnabled)
            {
                _logger.Debug("Channel Ack being sent for channel id " + _channelId + " and message number " + messageNbr);
            }
            /*Channel.Ack frame = new Channel.Ack();
            frame.channelId = _channelId;
            frame.messageNbr = messageNbr;
            _connection.getProtocolHandler().writeFrame(frame);*/
        }

        internal void Start()
        {
            _dispatcher = new Dispatcher(this);
            Thread dispatcherThread = new Thread(new ThreadStart(_dispatcher.RunDispatcher));
            dispatcherThread.IsBackground = true;
            dispatcherThread.Start();
        }

        internal void RegisterConsumer(string consumerTag, IMessageConsumer consumer)
        {
            _consumers[consumerTag] =  consumer;
        }

        /// <summary>
        /// Called by the MessageConsumer when closing, to deregister the consumer from the
        /// map from consumerTag to consumer instance.
        /// </summary>
        /// <param name="consumerTag">the consumer tag, that was broker-generated</param>        
        internal void DeregisterConsumer(string consumerTag)
        {
            _consumers.Remove(consumerTag);
        }

        internal void RegisterProducer(long producerId, IMessageProducer producer)
        {
            _producers[producerId] = producer;
        }

        internal void DeregisterProducer(long producerId)
        {
            _producers.Remove(producerId);
        }

        private long GetNextProducerId()
        {
            return ++_nextProducerId;
        }               
    }
}
