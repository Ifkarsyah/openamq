<class
    name = "AMQ"
    libid = "B9EDF8A0-CAAF-11D3-B3AF-00EFA87EF001"
    version_major = "1"
    version_minor = "0"
    description = "OpenAMQ Client Components">

    <include name = "base.h"                  local = "yes" location = "cpp" />
    <include name = "amq_client_connection.h" local = "yes" location = "cpp" />
    <include name = "amq_client_session.h"    local = "yes" location = "cpp" />

    <interface
        name = "IAMQConnection"
        dual = "yes"
        source = "no"
        iid = "876FAFB0-AEF8-F2DF-AFBA-49AC41AEF001">
    
        <method name="Connect">
            <argument type = "BSTR" name = "server"/>
            <argument type = "BSTR" name = "vhost"/>
            <argument type = "BSTR" name = "login"/>
            <argument type = "BSTR" name = "password"/>
            <argument type = "long" name = "timeout"/>
        </method>
      
        <method name = "Publish">
            <argument type = "BSTR" name = "content"/>
            <argument type = "BSTR" name = "exchange"/>
            <argument type = "BSTR" name = "routing_key"/>
            <argument type = "long" name = "mandatory"/>
            <argument type = "long" name = "immediate"/>
        </method>

        <method name = "Consume" type = "long">
            <argument type = "BSTR" name = "queue"/>
            <argument type = "long" name = "prefetch_size"/>
            <argument type = "long" name = "prefetch_count"/>
            <argument type = "long" name = "no_local"/>
            <argument type = "long" name = "auto_ack"/>
            <argument type = "long" name = "exclusive"/>
        </method>
        
        <method name = "Cancel">
            <argument type = "long" name = "consumer_tag"/>
        </method>
        
        <method name = "FireEvents">
        </method>

    </interface>
    
    <interface
        name = "_IAMQConnectionEvents"
        source = "yes"
        iid = "4C8A1B9F-43C6-4bfb-8327-14C57DDAB22A">

        <method name = "MessageArrived">
        </method>
        
        <method name = "MessageReturned">
        </method>

    </interface>

    <interface
        name = "IAMQControl"
        dual = "yes"
        source = "no"
        iid = "FBF315E4-DE69-4569-8F69-7DCB291BE20E">

        <property name = "Period" type = "long" get = "yes" put = "yes" />
        <property name = "Source" type = "IDispatch*" get = "yes" put = "yes" />

    </interface>

<!--
        <custom location = "h">
#define REPORT_AMQ_ERROR(client, class_name, interface_name)\
    {\
        USES_CONVERSION;\
        wchar_t buffer[32];\
        CComBSTR errmsg (_itow (client->reply_code, buffer, 10) );\
        errmsg += L" : ";\
        errmsg += A2OLE (client->reply_text);\
        return AtlReportError (__uuidof (class_name), errmsg, __uuidof (interface_name), E_FAIL);\
    }
        </custom>
-->        

    <object
        name = "AMQConnection"
        clsid = "876FAFB1-AEF8-F2DF-AFBA-49AC41AEF001"
        control = "no"
        creatable = "yes"
        threading_model = "Apartment"
        version = "1">
        
        <fires interface = "_IAMQConnectionEvents" />

        <context>
            <field name = "connection"  type = "amq_client_connection_t*" />
            <field name = "session"  type = "amq_client_session_t*" />
        </context>

        <constructor>
    m_connection = NULL;
    m_session = NULL;
        </constructor>

        <destructor>
    if (m_session)
        amq_client_session_destroy (&m_session);
    if (m_connection)
        amq_client_connection_destroy (&m_connection);
        </destructor>
    
        <implements interface = "IAMQConnection" errorinfo = "yes">

            <method name = "Connect">
    char
        *my_server,
        *my_vhost,
        *my_login,
        *my_password;
    icl_longstr_t
        *auth_data;
    
    USES_CONVERSION;
        
    my_server = OLE2A(server);
    my_vhost = OLE2A (vhost);
    my_login = OLE2A (login);
    my_password = OLE2A (password);

    if (m_session)
        amq_client_session_destroy (&m_session);
    if (m_connection)
        amq_client_connection_destroy (&m_connection);
    
    auth_data = amq_client_connection_auth_plain (my_login, my_password);
    assert (auth_data);
    m_connection = amq_client_connection_new (my_server, my_vhost, auth_data,
        0, timeout);
    assert (m_connection);
    icl_longstr_destroy (&auth_data);
    m_session = amq_client_session_new (m_connection);
    assert (m_session);
    
    return S_OK;
            </method>
                
            <method name = "Publish">
    char
        *my_exchange,
        *my_routing_key;
    int
        result;
    amq_content_basic_t
        *msg;
    
    USES_CONVERSION;

    my_exchange = OLE2A (exchange);
    my_routing_key = OLE2A (routing_key);

    msg = amq_content_basic_new ();
    assert (msg);
    result = amq_content_basic_set_body (msg, (void*) content,
        ::SysStringByteLen (content), icl_mem_free);
    if (result)
        assert (0);
    
    result = amq_client_session_basic_publish (m_session,
        msg, 0, my_exchange, my_routing_key, (Bool) mandatory,
        (Bool) immediate);
    if (result)
        assert (0);
    amq_content_basic_destroy (&msg);

    return S_OK;
            </method>

            <method name = "Consume">    
    char
        *my_queue;
    int
        result;
    
    USES_CONVERSION;

    my_queue = OLE2A (queue);
    result = amq_client_session_basic_consume (m_session, 0, my_queue,
        (dbyte) prefetch_size, (dbyte) prefetch_count,  no_local, auto_ack,
        exclusive);
    if (result)
        assert (0);
        
    if(pVal)
        *pVal = m_session->consumer_tag;
        
    return S_OK;
            </method>
                
            <method name = "Cancel">
    int
        result;
        
    result = amq_client_session_basic_cancel (m_session, (dbyte) consumer_tag);
    if (result)
        assert (0);
        
    return S_OK;
            </method>
                
            <method name = "FireEvents">
    amq_content_basic_t
        *msg;

    while (true) {
        msg = amq_client_session_basic_returned (m_session);
        if (!msg)
            break;
        Fire_MessageReturned ();
        amq_content_basic_destroy (&msg);
    }
    while (true) {
        msg = amq_client_session_basic_arrived (m_session);
        if (!msg)
            break;
        Fire_MessageArrived ();
        amq_content_basic_destroy (&msg);
    }
    
    return S_OK;
            </method>
            
        </implements>

    </object>

    <object
        name = "AMQControl"
        clsid = "10BB5D68-4877-41cc-BC7B-289788AB4228"
        control = "yes"
        creatable = "yes"
        threading_model = "Apartment"
        version = "1">

        <fires interface = "_IAMQConnectionEvents" />

        <context>
            <field name = "period" type = "long" />
            <field name = "source" type = "CComPtr<IAMQConnection>" noinit = "" />
            <field name = "cookie" type = "DWORD" />
        </context>

        <constructor>
    m_bWindowOnly = TRUE;
        </constructor>

        <implements interface = "IAMQControl" errorinfo = "yes">

            <property name = "Period">
                <get>
    *pVal = m_period;
    return S_OK;
                </get>
                <put>
    m_period = newVal;
    SetTimer (1, m_period);
    return S_OK;
                </put>
            </property>

            <property name = "Source">
                <get>
    *pVal = m_source;
    if (m_source) m_source.p->AddRef();
    return S_OK;
                </get>
                <put>
    HRESULT hr;
    if (m_source) {
        hr = DispEventUnadvise (m_source);
        if (!SUCCEEDED (hr) ) return hr;
        m_source.Release();
    }
    if (newVal) {
        hr = newVal->QueryInterface(__uuidof(IAMQConnection), (void**)&m_source);
        if (!SUCCEEDED (hr) ) return hr;
        return CAMQControlSink1::DispEventAdvise(m_source);
    }
    else {
        m_source = NULL;
        return S_OK;
    }
                </put>
            </property>
    
        </implements>

        <handler message = "WM_TIMER">
    if(m_source)
        m_source->FireEvents ();        
    return 0;
        </handler>  

        <sink id = "1" interface = "_IAMQConnectionEvents">
            <event name="MessageArrived">
    Fire_MessageArrived ();
    return S_OK;
            </event>
            <event name="MessageReturned">
    Fire_MessageReturned ();
    return S_OK;
            </event>
        </sink>  

        <function name = "OnDraw" type = "HRESULT">
            <argument type = "ATL_DRAWINFO&" name = "di" />
    RECT& rc = *(RECT*)di.prcBounds;
    Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
    SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
    LPCTSTR pszText = _T("AMQ Control");
    TextOut(
        di.hdcDraw, 
        (rc.left + rc.right) / 2, 
        (rc.top + rc.bottom) / 2, 
        pszText, 
        lstrlen(pszText));
    return S_OK;
        </function>

    </object>
    
</class>

<library target = "libasl.lib" debugtarget = "libasl.lib" />
<library target = "libamq.lib" debugtarget = "libamq.lib" />
<library target = "libsmt.lib" debugtarget = "libsmt.lib" />
<library target = "libipr.lib" debugtarget = "libipr.lib" />
<library target = "libicl.lib" debugtarget = "libicl.lib" />
<library target = "libsfl.lib" debugtarget = "libsfl.lib" />
<library target = "libapr.lib" debugtarget = "libapr.lib" />
<library target = "libpcre.lib" debugtarget = "libpcre.lib" />
<library target = "ws2_32.lib" debugtarget = "ws2_32.lib" />
<library target = "mswsock.lib" debugtarget = "mswsock.lib" />