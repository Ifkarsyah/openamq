<class
    name = "AMQ"
    libid = "B9EDF8A0-CAAF-11D3-B3AF-00EFA87EF001"
    version_major = "1"
    version_minor = "0"
    description = "OpenAMQ Client Components">

    <include name = "base.h" local = "yes" location = "h" />
    <include name = "amq_client_connection.h" local = "yes" location = "h" />
    <include name = "amq_client_session.h"    local = "yes" location = "h" />
    
    <interface
        name = "IAMQConnection"
        dual = "yes"
        source = "no"
        iid = "876FAFB0-AEF8-F2DF-AFBA-49AC41AEF001">
    
        <method name="Connect">
            <argument type = "BSTR" name = "server"/>
            <argument type = "BSTR" name = "vhost"/>
            <argument type = "BSTR" name = "login"/>
            <argument type = "BSTR" name = "password"/>
            <argument type = "long" name = "timeout"/>
        </method>
        
        <method name = "CreateQueue">
            <argument type = "BSTR" name = "name"/>
        </method>
      
        <method name = "Publish">
            <argument type = "BSTR" name = "content"/>
            <argument type = "BSTR" name = "routing_key"/>
            <argument type = "long" name = "mandatory"/>
            <argument type = "long" name = "immediate"/>
        </method>

        <method name = "Consume" type = "BSTR">
            <argument type = "BSTR" name = "queue"/>
            <argument type = "long" name = "prefetch_size"/>
            <argument type = "long" name = "prefetch_count"/>
            <argument type = "long" name = "no_local"/>
            <argument type = "long" name = "auto_ack"/>
            <argument type = "long" name = "exclusive"/>
        </method>
        
        <method name = "Cancel">
            <argument type = "BSTR" name = "consumer_tag"/>
        </method>
        
        <method name = "FireEvents">
        </method>

    </interface>
    
    <interface
        name = "_IAMQEvents"
        source = "yes"
        iid = "EFD60ECE-5B91-477e-A29B-639B65A29FC7">

        <method name = "MessageArrived">
            <argument type = "BSTR" name = "content"/>
        </method>
        
        <method name = "MessageReturned">
            <argument type = "BSTR" name = "content"/>
        </method>

    </interface>

    <interface
        name = "IAMQControl"
        dual = "yes"
        source = "no"
        iid = "FBF315E4-DE69-4569-8F69-7DCB291BE20E">

        <property name = "Period" type = "long" get = "yes" put = "yes" />
        <property name = "Source" type = "IDispatch*" get = "yes" put = "yes" />

    </interface>        

    <object
        name = "AMQConnection"
        clsid = "876FAFB1-AEF8-F2DF-AFBA-49AC41AEF001"
        control = "no"
        creatable = "yes"
        threading_model = "Apartment"
        version = "1">
        
        <fires interface = "_IAMQEvents" />

        <context>
            <field name = "connection"  type = "amq_client_connection_t*" />
            <field name = "session"  type = "amq_client_session_t*" />
        </context>

        <custom location = "cpp">
	HRESULT create_error (const wchar_t *description)
	{
	    HRESULT
		    hr;
		CComPtr &lt;ICreateErrorInfo>
		    info;
		CComPtr &lt;IErrorInfo>
		    error_info;
	    
		hr = ::CreateErrorInfo (&info);
		if (!SUCCEEDED (hr))
		    return hr;
		hr = info->SetGUID (__uuidof (IAMQConnection));
		if (!SUCCEEDED (hr))
		    return hr;
		hr = info->SetSource (L"AMQ");
		if (!SUCCEEDED (hr))
		    return hr;
		hr = info->SetDescription ((wchar_t*) description);
		if (!SUCCEEDED (hr))
		    return hr;
        hr = info->QueryInterface (__uuidof (IErrorInfo), (void**) &error_info);
		if (!SUCCEEDED (hr))
		    return hr;		
		hr = ::SetErrorInfo (0, error_info);
		if (!SUCCEEDED (hr))
		    return hr;
		return E_FAIL;
	}

    BSTR read_content (amq_content_basic_t *content)
    {
        asl_reader_t
            reader;
        ipr_bucket_t
            *buf;
        byte
            *body = NULL;
        size_t
            cur_size = 0;
        BSTR
            result;
            
        amq_content_basic_set_reader (content, &reader, 4096);
        while ((buf = amq_content_basic_replay_body (content, &reader))) {
            body = (byte*) icl_mem_realloc (body, cur_size + buf->cur_size);
			if (!body)
                return NULL;
            memcpy (body + cur_size, buf->data, buf->cur_size);
            cur_size += buf->cur_size;
        }   
        ipr_bucket_destroy (&buf);
        result = ::SysAllocStringByteLen ((LPCSTR) body, cur_size);
        if (!result)
		    return NULL;
        icl_mem_free (body);
        return result;
    }
        </custom>

        <constructor>
    m_connection = NULL;
    m_session = NULL;
    icl_system_initialise (0, NULL);
        </constructor>

        <destructor>
    if (m_session)
        amq_client_session_destroy (&m_session);
    if (m_connection)
        amq_client_connection_destroy (&m_connection);
    // icl_system_terminate ();
        </destructor>
    
        <implements interface = "IAMQConnection" errorinfo = "yes">

            <method name = "Connect">
    char
        *my_server,
        *my_vhost,
        *my_login,
        *my_password;
    icl_longstr_t
        *auth_data;
    
    USES_CONVERSION;
        
    my_server = OLE2A(server);
    my_vhost = OLE2A (vhost);
    my_login = OLE2A (login);
    my_password = OLE2A (password);

    if (m_session)
        amq_client_session_destroy (&m_session);
    if (m_connection)
        amq_client_connection_destroy (&m_connection);
    
    auth_data = amq_client_connection_auth_plain (my_login, my_password);
    if (!auth_data)
	    return create_error (L"Cannot create authentication data");
    m_connection = amq_client_connection_new (my_server, NULL, my_vhost, auth_data,
        0, timeout);
    if (!m_connection)
		return create_error (L"Cannot open connection to AMQ server");
    icl_longstr_destroy (&auth_data);
    m_session = amq_client_session_new (m_connection);
    if (!m_session)
		return create_error (L"Cannot open AMQ session");
    
    return S_OK;
            </method>
            
            <method name = "CreateQueue">
    int
        result;
    char
        *my_name;
        
    USES_CONVERSION;
    
    my_name = OLE2A (name);
        
    result = amq_client_session_queue_declare (m_session, 0, my_name, 0, 1, 0, 0, NULL);
    if (result)
        return create_error (L"Cannot decllare the queue");
    result = amq_client_session_queue_bind (m_session, 0, my_name, "amq.direct", my_name, NULL);
    if (result)
        return create_error (L"Cannot bind the queue to the amq.direct exchange");
         
    return S_OK;
            </method>    
            
            <method name = "Publish">
    char
        *my_routing_key;
    int
        result;
    amq_content_basic_t
        *msg;
    void
        *body;
    
    USES_CONVERSION;

    my_routing_key = OLE2A (routing_key);

    msg = amq_content_basic_new ();
    if (!msg)
		return create_error (L"Cannot create content object");
    body = icl_mem_alloc (::SysStringByteLen (content));
	if (!body)
        return create_error (L"Not enough memory for the content");
	memcpy (body, (byte*) content, ::SysStringByteLen (content));
    result = amq_content_basic_set_body (msg, body,
        ::SysStringByteLen (content), icl_mem_free);
	if (result)
        return create_error (L"Setting body of the content failed");
    
    result = amq_client_session_basic_publish (m_session,
        msg, 0, "amq.direct", my_routing_key, (Bool) mandatory,
        (Bool) immediate);
    if (result)
        return create_error (L"Cannot publish message");
    amq_content_basic_destroy (&msg);

    return S_OK;
            </method>

            <method name = "Consume">    
    char
        *my_queue;
    int
        result;
    
    USES_CONVERSION;

    my_queue = OLE2A (queue);
    result = amq_client_session_basic_consume (m_session, 0, my_queue, NULL,
        (dbyte) prefetch_size, (dbyte) prefetch_count,  no_local, auto_ack,
        exclusive);
    if (result)
        return create_error (L"Cannot consume from the queue");
        
    if(pVal)
        *pVal = ::SysAllocString (A2W (m_session->consumer_tag));
        
    return S_OK;
            </method>
                
            <method name = "Cancel">
    int
        result;

    USES_CONVERSION;
        
    result = amq_client_session_basic_cancel (m_session, W2A (consumer_tag));
    if (result)
        return create_error (L"Cannot cancel consuming from the queue");
        
    return S_OK;
            </method>
                
            <method name = "FireEvents">
    amq_content_basic_t
        *msg;
    int
        result;

    result = amq_client_session_wait (m_session, 100);
    if (result)
        return create_error (L"Waiting for message failed");
        
    while (true) {
        msg = amq_client_session_basic_returned (m_session);
        if (!msg)
            break;
        Fire_MessageReturned (read_content (msg));
        amq_content_basic_destroy (&msg);
    }
    while (true) {
        msg = amq_client_session_basic_arrived (m_session);
        if (!msg)
            break;
        Fire_MessageArrived (read_content (msg));
        amq_content_basic_destroy (&msg);
    }
    
    return S_OK;
            </method>
            
        </implements>

    </object>

    <object
        name = "AMQControl"
        clsid = "44CC0A42-58E2-4ba8-8DC5-9488E911911C"
        control = "yes"
        creatable = "yes"
        threading_model = "Apartment"
        version = "1">

        <fires interface = "_IAMQEvents" />

        <context>
            <field name = "period" type = "long" />
            <field name = "source" type = "CComPtr<IAMQConnection>" noinit = "" />
            <field name = "cookie" type = "DWORD" />
        </context>

        <constructor>
    m_bWindowOnly = TRUE;
        </constructor>

        <implements interface = "IAMQControl" errorinfo = "yes">

            <property name = "Period">
                <get>
    *pVal = m_period;
    return S_OK;
                </get>
                <put>
    m_period = newVal;
    SetTimer (1, m_period);
    return S_OK;
                </put>
            </property>

            <property name = "Source">
                <get>
    *pVal = m_source;
    if (m_source) m_source.p->AddRef();
    return S_OK;
                </get>
                <put>
    HRESULT hr;
    if (m_source) {
        hr = DispEventUnadvise (m_source);
        if (!SUCCEEDED (hr) ) return hr;
        m_source.Release();
    }
    if (newVal) {
        hr = newVal->QueryInterface(__uuidof(IAMQConnection), (void**)&m_source);
        if (!SUCCEEDED (hr) ) return hr;
        return CAMQControlSink1::DispEventAdvise(m_source);
    }
    else {
        m_source = NULL;
        return S_OK;
    }
                </put>
            </property>
    
        </implements>

        <handler message = "WM_TIMER">
    if(m_source)
        m_source->FireEvents ();        
    return 0;
        </handler>  

        <sink id = "1" interface = "_IAMQEvents">
            <event name="MessageArrived">
    Fire_MessageArrived (content);
    return S_OK;
            </event>
            <event name="MessageReturned">
    Fire_MessageReturned (content);
    return S_OK;
            </event>
        </sink>  

        <function name = "OnDraw" type = "HRESULT">
            <argument type = "ATL_DRAWINFO&" name = "di" />
    RECT& rc = *(RECT*)di.prcBounds;
    Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
    SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
    LPCTSTR pszText = _T("AMQ Control");
    TextOut(
        di.hdcDraw, 
        (rc.left + rc.right) / 2, 
        (rc.top + rc.bottom) / 2, 
        pszText, 
        lstrlen(pszText));
    return S_OK;
        </function>

    </object>
    
</class>

<library target = "libasl.lib" debugtarget = "libasl.lib" />
<library target = "libamq.lib" debugtarget = "libamq.lib" />
<library target = "libsmt.lib" debugtarget = "libsmt.lib" />
<library target = "libipr.lib" debugtarget = "libipr.lib" />
<library target = "libicl.lib" debugtarget = "libicl.lib" />
<library target = "libsfl.lib" debugtarget = "libsfl.lib" />
<library target = "libapr.lib" debugtarget = "libapr.lib" />
<library target = "libpcre.lib" debugtarget = "libpcre.lib" />
<library target = "ws2_32.lib" debugtarget = "ws2_32.lib" />
<library target = "mswsock.lib" debugtarget = "mswsock.lib" />
