5. The Functional Layer
    functional objects & lifecycle
    all functional commands


The AMQ Queue
-------------

The term "AMQ queue" is self-redundant, but it is for now the clearest
term we have found when discussing the message-holding FIFO entities
that an AMQ broker manages.

An AMQ "queue" stores messages in memory or on disk, and delivers these
in sequence to one or more consumers. Each consumer represents one
client application. AMQ queues are intelligent message storage and
distribution entities.  Each AMQ queue is entirely independent and is
a reasonably clever object.

An AMQ queue has flexible properties: private or shared, durable or
temporary, client-named or broker-named, etc. An AMQ queue serves to
implement a number of basic middleware entities:

- a standard "store and forward" queue, which holds messages and
  distributes these between multiple consumers on a round-robin basis.
  Standard queues are typically durable, named through configuration
  and shared between multiple consumers.

- a temporary reply queue, which holds messages and forwards these to a
  single consumer. Reply queues are typically temporary, broker-named,
  and private to one consumer.

- a "pub-sub" subscription queue, which holds messages collected from
  various "subscribed" sources, and forwards these to a single consumer.
  Subscription queues are typically temporary, broker-named, and private
  to one consumer.

These categories are not formally defined in AMQ, they are just specific
ways of using AMQ queues.  It is trivial to create new entities such as
durable, shared subscription queues, by adjusting the options used when
creating an AMQ queue.

The AMQ Exchange
----------------

An AMQ "exchange" accepts messages from a client application - the
publisher - and routes these to queues according to pre-arranged criteria.
These criteria are called "bindings". AMQ exchanges are matching and
routing entities. That is, they inspect messages and using their binding
tables, decide how to forward these messages to AMQ queues or other
exchanges. AMQ exchanges never store messages.

There are two main reasons why we don't just have one type of exchange that
does everything (a classic middleware solution):

1. Different types of matching demand different exchange implementations.
   A general-purpose matching engine is too slow for common cases, and
   too complex to extend easily.  For example, content-based routing
   can (or must) be done in different ways, depending on the application.

2. Designing exchanges as an extensible framework makes it possible to
   add new functionality to the process, in a useful place, and in a
   simple way.

An AMQ exchange exists in two forms. First, there is the code itself.
When we discuss what an exchange can or cannot do, we speak of the code.
Secondly, there is the running instance. When we send a message to an
exchange, we send it to a running instance.

In some contexts this separation between the code and the instance is
obvious - for instance, the term "AMQ broker" means both the static code
and the active running process. However, when speaking of an AMQ
exchange as an entity inside the AMQ broker, the separation is less
clear. To clarify it, we use some rules and terminology:

 1. The algorithm for an exchange - its code - is the "exchange class".
 2. All exchanges must be started as instances before they can be used.
 3. All exchange instances are explicitly named.

Let's take an example.  We imagine a new exchange class, "filter", capable
of recognizing illegal messages - e.g. too large - and rejecting these.
To use the filter exchange class, we create a new exchange instance called
"my.filter".  When applications use this exchange, they will refer to
"my.filter", not "filter".

Multiple Exchange Instances
---------------------------

When we speak of "an exchange" as an active entity, we mean the instance,
not the class.  There are various reasons why we would want multiple
exchange instances of single class:

1. Scalability - exchanges may be scalable to certain limits, and to
   avoid passing those limits, it may be useful to split a heavily
   used exchange into two instances.

2. Distribution - it may be useful to run separate exchanges in their
   own threads to better use a multi-processor system.

3. Security - we plan to apply access controls to the data entering
   and leaving an exchange.  This would require one exchange per access
   control realm.

In a normal scenario we would expect an AMQ broker to have a small
number - less than a dozen - exchange instances.  Any configuration
that created hundreds or thousands of exchange instances would be
unusual or simply wrongly designed.

The Routing Key
---------------

In the general case an exchange examines a message's properties, its
header fields, and its body content, and using this and possibly
other data, decides how to route the message.

In the majority of simple cases the exchange examines a single key
field, which we call the "routing key".  The routing key is a virtual
address that the exchange uses to decide how to route the message.

We define the routing key as a special case - rather than simply
stating, "the header fields act as 1..N routing keys" because it
covers a majority of cases very simply.

For point-to-point routing, the routing key is the name of a queue.

For topic pub-sub routing, the routing key is the topic hierarchy
value.

In more complex cases the routing key may be combined with routing
on message header fields and/or its content.

Note: this field was previously called "destination" but that term
is more accurately used externally to define the combination of exchange
and routing key within a specific virtual host and broker.  We write
AMQP destinations as URLs, but routing keys are arbitrary text strings.

Comparing to Email
------------------

If we make an analogy with an email system we see that the AMQ concepts
are not radical:

 - an AMQ message is like an email.
 - an AMQ queue is like a mailbox.
 - an AMQ consumer is like a mail client that fetches and deletes email.
 - an AMQ exchange is like a MTA (mail transfer agent) that inspects email
   and decides, on the basis of routing keys and tables, how to send the
   email to one or more mailboxes.
 - an AMQ routing key corresponds to an email To: address, without the
   broker information (routing is entirely internal to an AMQ broker).
 - each AMQ exchange instance is like a separate MTA process, handling some
   email subdomain, or particular type of email traffic.
 - an AMQ binding is like an entry in a MTA routing table.

The power of AMQ comes from our ability to create queues (mailboxes),
exchanges (MTA processes), and bindings (routing entries), at runtime, and
to chain these together in ways that go far beyond a simple mapping from
"to" address to mailbox name.

We should not take the email-AMQP analogy too far: there are fundamental
differences.  The challenge in AMQP is to route and store messages within
a broker.  The challenge in email is to route messages between brokers.
The addressing models are thus fundamentally different.  Routing within a
broker and between brokers are distinct problems and have distinct
solutions, if only for banal reasons such as maintaining transparent
performance.

What The Publisher Sees
-----------------------

We use the informal term "publisher" to mean an AMQ client application
that sends messages to an AMQ broker.

By analogy with the email system, we can see that a publisher will never
send messages directly to an AMQ queue. Allowing this would break all
abstraction in the model. It would be like allowing email to bypass the
MTA's routing tables and arrive directly in a mailbox. This would make
it impossible to insert intermediate filtering and processing, spam
detection, for instance.

The AMQ model uses the same principle as an email system: all messages
are sent to a single point, the exchange or MTA, which inspects the
messages based on rules and information that are hidden from the sender,
and routes them to drop-off points that are also hidden from the sender.

A classic message-oriented middleware semantic is "send to queue X", and
when we say, "AMQ does not support this, indeed, it deliberately forbids
it", some confusion is understandable.  However, what we are saying is,
"you cannot send directly to a queue, you can only send to all queues
that have asked for messages for a specific routing key.  Just as one
can configure a mail system so that each To: address corresonds
exactly to one mailbox, we can configure an AMQ system to support the
classic semantics.

What The Reader Sees
---------------------

We use the informal term "reader" to mean an AMQ client application that
reads and removes messages from an AMQ broker.

Our analogy with email starts to lose focus when we look at readers.
Email clients are passive - they can read their mailboxes, but they do
not have any influence on how these mailboxes are filled. AMQ readers
can also be passive, just like email clients. That is, we can write an
application that expects a particular AMQ queue to be ready and bound,
and which will simply process messages off that queue.

However, we also allow AMQ client applications to:

 - create or destroy AMQ queues
 - define the way these queues are filled, by making bindings

For standard queues, this work would normally not be done by the reader
but by an administrative client, or as part of the broker configuration.
For reply queues and subscription queues, it is convenient that the
reader also does the binding immediately after creating the queue.

This is like having an email system where one can, via the protocol:

 - create a new mailbox.
 - tell the MTA that all messages with a specific header field should
   be copied into this mailbox.

We see that AMQ is more like a language for wiring pieces together than
a system. Like all languages, the problems start when we try to find
good and self-explanatory names for things.

Basic AMQ Bindings
------------------

A binding is a relationship between an AMQ exchange and an AMQ queue
that tells the exchange how to route messages.  Bindings are constructed
from commands from the client application (the one owning and using the
queue) to an exchange.  While we will usually execute these commands
via protocol methods, they could equally come from a configuration file
or other places.  We can express a binding command in pseudo-code as
follows:

    BIND <queue> TO <exchange> WHERE <condition>

Let's look at each of the three main cases - standard queues, reply
queues, pub-sub subscriptions - in turn.

Constructing a Standard Queue
.............................

Standard queues correspond to the classic email routing where To address
address equals mailbox name: AMQ queue name equals routing key.  We need
an exchange class capable of matching on the routing key.  In AMQ this exchange
class is called "direct".

At some point, we must create an instance of the direct exchange class.
Note that this kind of thing would be done in the broker at start-up, or
via some administration process.  We will call the exchange "amq.direct":

    CREATE
        exchange=amq.direct
        class=direct

Let's assume our queue is called "my.svc01", and publishers will send to
the routing key "svc01".  Here is the pseudo-code for creating and binding
the queue:

    CREATE
        queue=my.svc01
        private=FALSE
    BIND
        queue=my.svc01
        TO exchange=amq.direct
        WHERE routing_key=my.svc01

We may have many readers on this queue. To consume from the queue, each
reader does this:

    CONSUME
        queue=my.svc01

To publish to the queue, each publisher does this:

    SEND
        exchange=amq.direct
        routing_key=my.svc01

Constructing a Reply Queue
..........................

Reply queues are usually temporary, with broker-assigned names.  They
are also usually private, i.e. read by a single consumer.  Apart from
these particularities, reply queues use the same matching criteria as
standard queues, so we can use the same amq.direct exchange.

Here is the pseudo-code for creating and binding a reply queue, where
S: indicates a broker reply:

    CREATE
        queue=<empty>
        private=TRUE
        autodelete=TRUE
    S:CREATE-OK
        queue=tmp.1
    BIND
        queue=tmp.1
        TO exchange=my.direct
        WHERE routing_key=tmp.1

To consume from, and publish to the queue we do the same as for the
standard queue (using the reply queue name, of course).

Constructing a Pub-Sub Subscription Queue
.........................................

In classic middleware the term "subscription" is vague and refers to
three different pieces: the set of matching criteria, the temporary
queue that holds matched messages, and the consumer that feeds these
messages to a client application. AMQ separates these concepts into
their atomic pieces, into bindings, AMQ queues, and consumers. There
is no AMQ entity called "subscription".

Let's make sure we agree on what a pub-sub subscription queue is:

- it holds messages for a single consumer (or in some cases for
  multiple consumers).

- it collects messages from multiple sources, through a set of
  bindings that match topics, message fields, or content in different
  ways.

The key difference between a subscription queue and a standard or
reply queue is that the subscription queue name is irrelevant for
the purposes of routing, and routing is done on abstracted matching
criteria rather than a 1-to-1 matching of the routing key field.

Let's take a common pub-sub model - topic trees - and implement this.
We'll look at combinations (e.g. topics plus header fields) later. We
need an exchange class capable of matching on a topic tree. In AMQ this
exchange class is called "amq.topic".  The topic exchange matches wildcards
like "STOCK.USD.*" against routing key values like "STOCK.USD.IBM".

At some point, we must create an exchange instance of the "topic"
class.  Let's call this exchange "amq.topic":

    CREATE
        exchange=amq.topic
        class=topic

Here is the pseudo-code for creating and binding the pub-sub
subscription queue:

    CREATE
        queue=<empty>
        autodelete=TRUE
    S:CREATE-OK
        queue=tmp.2
    BIND
        queue=tmp.2
        TO exchange=amq.topic
        WHERE routing_key=STOCK.USD.*

To consume from the queue, the reader does this:

    CONSUME
        queue=tmp.2

When publishing a message, we do something like this:

    SEND
        exchange=amq.topic
        routing_key=STOCK.USD.IBM

The topic exchange processes the incoming routing key ("STOCK.USD.IBM")
with its binding table, and finds one match, for tmp.2. It then routes
the message to that queue.

Advanced AMQ Bindings
---------------------

The basic structures explained above are enough to implement standard
queues and standard pub-sub topics. However, applications need more than
this: they need to be able to combine matching algorithms so that
messages are matched several times before they reach a client
application.

Note: the following semantics are not implemented in OpenAMQ/0.9b -
this part of the discussion is a semi-formal proposal for OpenAMQ/0.9c.

Chained Bindings
................

The first problem is how to combine exchange algorithms. We want to
provide the following semantic:

    BIND <queue> TO <exchange1> WHERE <condition>
             AND TO <exchange2> WHERE <condition>

(Note that the "OR" semantic is trivial, we simply make two separate
bindings for the same queue.)

For performance reasons, AMQP does not provide an extensible language in
which to express such semantics. Rather we will construct the combined
semantic from individual commands:

    BIND <queue> TO <exchange1> WHERE <condition>
    BIND <queue> TO <exchange2> VIA <exchange1> WHERE <condition>

We call this a "chained binding". To see how this would work in
practice, let's take two such algorithms as examples: one is "topic",
which matches the routing key against a wildcard pattern, and the other
is "filter", which detects illegally large or otherwise dangerous
messages. (Note, "filter" is not real, just an example.) We have two
exchange instances, amq.topic and amq.filter.

We want to match all messages with routing key like "STOCK.USD.*" and
which have a PDF file in their content (one of the abilities of the
imaginary filter exchange is to filter according to the content types
of messages).

We can assume that someone has already created the two exchanges.  We
create a temporary queue and bind it as follows:

    CREATE
        queue=<empty>
        autodelete=TRUE
    S:CREATE-OK
        queue=tmp.3
    BIND
        queue=tmp.3
        TO exchange=amq.topic
        WHERE routing_key=STOCK.USD.*
    BIND
        queue=tmp.3
        TO exchange=amq.filter
        VIA exchange=amq.topic
        WHERE content-type=application/x-pdf

To publish a message, we send to the amq.topic as before:

    SEND
        exchange=amq.topic
        routing_key=STOCK.USD.IBM
        content-type=application/x-pdf

Significance of Wiring Order
............................

When we make chained bindings, we get an ordered graph of exchanges
starting with the "root" exchange to which the publisher sends the
messages.

Functionally, these two sets of statements are equivalent:

    BIND <queue> TO <exchange1> WHERE <condition>
    BIND <queue> TO <exchange2> VIA <exchange1> WHERE <condition>

and:

    BIND <queue> TO <exchange2> WHERE <condition>
    BIND <queue> TO <exchange1> VIA <exchange2> WHERE <condition>

That is, chained bindings are like the Boolean AND operator, where order
has no effect on the output result. However, order does have an effect
on the internal processing flow and thus the performance. In general
messages should pass through the most selective exchanges first.

In most pub-sub scenarios it would make sense to use a topic exchange as
the main exchange, and then use topics as a primary selection mechanism
for messages.

Late Bindings
.............

The second problem we have to solve is how to support the existing
middleware (JMS, specifically) semantics whereby a client can select
messages at the same time as consuming them.

At first sight this may not seem so different from a normal binding.
It is thus worth explaining the subtlety.

- A normal binding routes messages into an AMQ queue after which they
  are dispatched to N consumers on a round-robin basis. For example,
  we may route print jobs to different queues based on where the printed
  documents must go.

- The select-on-consume semantic works on a single AMQ queue for N
  consumers, but where each consumer may have an independent set of
  criteria for the messages it wants to process. For example, one of a
  group of printers servicing a single print queue might ask to receive
  all oversized documents, by preference.

The main difference is that (a) the round-robin nature of message
delivery remains in force, so if multiple consumers have the same late
binding criteria, they will share the messages, and (b) the delivery of
messages remains ordered. Using normal bindings, this is not possible.

So late bindings apply when the broker searches for a consumer for the
next message. They are inherently slower than normal bindings, because a
message will be matched multiple times rather than just once.

We can express a late binding command in pseudo-code as follows:

    CONSUME FROM <queue> WHERE <condition>

Protocol Changes
----------------

To implement the above revised wiring scheme, we need to:

1. Add a queue name to the exchange.bind method so that we can implement
   chained bindings using this method.  (Or alternatively, add an exchange
   name to the queue.bind method and remove the exchange.bind method.)

2. Add an exchange name and binding arguments to the jms.consume method.
   If we want to allow chained late bindings, this would mean adding a
   further field.

These are trivial protocol changes.

broker Exchange Changes
-----------------------

To implement chained bindings, we need to modify the way exchanges build
and use their binding tables.  Today, an exchange resolves an incoming
message into a set of bindings to publish to, each binding representing
N queues that have registered (the same binding arguments).  For a
chained binding, each binding would either represent a set of queues
(normal bindings), or a further exchange plus a set of queues (chained
bindings).  The message would be passed to that further exchange, and
the set of queues intersected with the result of that matching, so on,
until we reached the end of the chain.

To implement late bindings, we need to create an exchange instance
(with no name) per queue that has one or more late bindings.  We
compile the bindings onto this exchange (this is the process by which
the binding requests are turned into routing tables) so that when we
decide to dispatch a message, we can pass it to the exchange and get
as result the next consumer to receive the message.

The Abstract Routing Model
==========================

AMQ defines an abstract model which all AMQP brokers and clients must
adhere to.  The abstract routing model provides a formal and run-time
configurable definition of how messages are stored and forwarded.

Introduction to the Abstract Routing Model
------------------------------------------

Restatement of Goals
....................

AMQ is designed to carry data ("messages") between applications
("clients") written in arbitrary languages and running on arbitrary
platforms spread across a fully-addressable network.

AMQ is designed to support many different types of application, each
with its own requirements as to:

- Message size, from zero bytes up to many gigabytes.
- Number of clients, from one up to many thousands.
- Volume of messages crossing the network, from a few per day to hundreds
  of thousands per second.
- Critical latency of a message, from a millisecond to an hour.
- Reliability of delivery, from "as reliable as possible, whatever the
  cost" to "best-effort delivery".
- Use of network, memory, CPU, and disk resources.

The same AMQ architecture must be able to work efficiently on a small
embedded message router, as well as on a supercluster with dozens of
CPUs and tens of gigabytes of memory.

General Design Method
.....................

Our design method relies on these principles:

1. Give the functional architect (the person responsible for designing
   an AMQ network, using AMQ technology) as much control as possible over
   the choices and tradeoffs required for a specific functional scenario.

2. Design the architecture using abstract general models that the
   functional architect can combine as needed.

That is: rather than embed assumptions and decisions in the architecture
we create abstract general-purpose constructs that can be reused in
scenarios that we do not pretend to fully understand ourselves.

Main Insights
.............

The main insights that led to our design (which is the third major
refactoring of the AMQ protocol) were:

1. Subscriptions can be designed as a special case of queues.  That is,
   subscriptions and queues can be designed to support exactly the same
   set of properties and access methods.  In the topic/subscription
   model subscriptions are simply queues that have a special matching
   technique and a private name space.

2. Matching can be abstracted.  That is, everything from matching on a
   specific routing key to matching on an SQL-like selector can be
   abstracted into a single concept.

3. Messages can have multiple instances.  That is, a message can be in
   many queues at the same time.  We do not copy message content, rather
   we use message reference counting.  Queues store references to
   messages rather than messages.  This applies both to persistent and
   non-persistent messages.

4. Queues and matching can be loosely-coupled.  That is, while one
   client "writes to queue X" and a second client "reads from queue
   X", this can be done using a less tightly-coupled relationship than
   the obvious "producer writes to queue".  Loose coupling is often
   desirable because it allows abstraction in which one side of a
   relationship can be reorganised without affecting the other.

We use these insights to define a set of building blocks that achieve
much wider functionality than classic messaging middleware (like JMS)
at no significant extra cost.

Overall Architecture
--------------------

Note: this section is out of date.  Current documentation is at:

http://wiki.openamq.org/cgi-bin/wiki/AmqQueuesAndExchanges

Classic Message-Oriented Middleware
...................................

A classic message-oriented middleware broker provides two types of
service: a "queue" service in which producers and consumers interact
via shared named queues, and a "topic" service which allows clients to
subscribe to a tree of topics. Clients subscribe with citeria such as
the topic name, or a pattern representing a set of topics, e.g.
"FOREX.*". The middleware explicitly provides functionality to
subscribe, manage topics, and so on.

AMQ does not provide these services directly: the protocol and broker
make no mention of "topics" or "subscriptions". Rather, AMQ provides
more general building blocks that can easily be used to build a topic
service, a queue service, a mix of the two, and new kinds of service
that fall outside the classic definitions.

Message, Queue, and Exchange
.........................

We define the "MESSAGE": a message is self-contained package of data
that passes through the broker. The broker will not modify or separate
the data in a message. The message is the basic unit of data transfer
between clients and brokers.

We define the "QUEUE": a queue holds messages and distributes these to
clients. Queues are highly configurable objects that implement most of
the quality of service aspects of an AMQP broker. Queues can be private
or shared, created by the broker administrator, or by applications.
Queues can holding their messages on disk or in memory, or a combination
(working in memory and overflowing to disk when necessary). Queues can
be durable (remaining active when the broker stops and restarts) or
transient (automatically deleted when no longer used).

Queues have public names, and when a client wants to get messages from a
broker it says, "give me messages from queue such-and-such".

We define the "EXCHANGE": an exchange is a named object that accepts
messages and distributes them to queues. A message can exist on many
queues at once.  Clients that want to send messages to a broker always
send them to a specific exchange on that broker.

Basic Architecture
..................

The basic architecture is thus (showing a set of producer applications
sending messages to a set of consumer applications):

                 +--------+        +--------+
    Producers    | Client |        | Client |
                 +--------+        +--------+
                     |                  |
                     V                  V
    Messages     +----\-----broker-----/----+
        |        |     \              /     |
        |        |      +------------+      |
        |        |      |  Exchange  |      |
        |        |      +------------+      |
        |        |         /      \         |
        |        |  +-------+    +-------+  |
      __|__      |  | Queue |    | Queue |  |
      \ | /      |  +-------+    +-------+  |
       \|/       |     /              \     |
        V        +----/----------------\----+
                     |                  |
                     V                  V
                 +--------+        +--------+
     Consumers   | Client |        | Client |
                 +--------+        +--------+

Note that:

1. The producers do not write directly to the consumers' queues.
2. The consumers do not read directly from the exchange.

Queue Consumers
...............

While exchanges copy messages across queues, queues distribute messages
between consumers.  A queue can have one consumer:

        +-------+
        | Queue |
        +-------+
            |
            V
        +--------+
        | Client |
        +--------+

A queue can also have many consumers:

                        +-------+
                        | Queue |
                        +-------+
                            |
           .----------.-----------.-----------.
           |          |           |           |
           V          V           V           V
      +--------+  +--------+  +--------+  +--------+
      | Client |  | Client |  | Client |  | Client |
      +--------+  +--------+  +--------+  +--------+

The queue distributes messages to the consumers according to a
configurable traffic control model that is adjustable per consumer:

- Each consumer specifies whether it is going to acknowledge
  messages or not.  Acknowledgements improve reliability but
  slow-down performance.

- Each consumer specifies how many messages the broker should
  send it in advance of acknowledgements.  This "prefetch"
  window improves latency but can mean that consumers are not
  perfectly balanced.

Given these two parameters the queue will distribute messages to the
consumers on a quasi-round-robin basis (i.e. to each consumer in turn,
but without a guarantee of visting each consumer in any particular
order).

Relationship between Queues and Exchanges
.......................................

A queue "registers" with an exchange, asking: "give me a copy of all
messages that look like this".

AMQ has a formal definition of a message which includes:

- the "routing key" for the message.  This is a name that the client
  application uses.  The routing key may (or may not) map directly
  to a queue name.

- the "properties" for the message.  These are a set of fields with
  a name, type, and value.  The field properties may (or may not) be
  used by the exchange to decide which queues receive the messages.

The Exchange Design
-------------------

Exchange Types
..............

These are the basic set of exchanges that an AMQP broker MAY support:

1. "fanout" routes all messages to all registered queues.  Fanout
   exchanges are used to create arbitrary routing flows within the
   broker.  For example, fanout exchanges might be used to replicate
   data within a cluster.

2. "direct" routes messages on their routing key using a direct
   comparison.

3. "topic" routes messages on their routing key name using a
   wildcard comparison.

4. "header" routes messages on the value and presence of content
   properties.

Guidelines for implementors:

- An AMQP broker MUST implement at least the fanout and direct
  exchanges.  An AMQP broker MAY implement the other exchange types.

Multiple Registrations
......................

A queue can register with the same exchange several times:

    Register with dest-name: messages for routing key X
    Register with dest-name: messages for routing key Y
    Register with dest-name: messages for routing key Z

The meaning of this is obvious and does not need much explaining: the
registrations are acummulated so the queue will get messages for any of
the three routing keys:

         +-----------+
         | dest-name |
         +-----------+
             | | |  "messages for routing keys X, Y, Z"
           +-------+
           | Queue |
           +-------+

On-Demand Wiring
................

To provide maximum flexibilty we split the definition of a broker's
wiring (i.e. the exchanges, queues, and relationships between them) into
three layers:

1. The set of exchange classes and how they are implemented.  This layer
   is defined in the broker's software.

2. A set of pre-defined exchanges and queue templates.  This layer is
   defined in the broker's configuration files.

3. The final set of exchanges, queues and registrations. This layer is
   defined at runtime by the application.

        +--------------------------+
     1  |  Software constructions  |   E.g. what exchange classes exist?
        +--------------------------+
                     |
                     V
        +--------------------------+
     2  |   Configured defaults    |   E.g. what queue templates exist?
        +--------------------------+
                     |
                     V
        +--------------------------+
     3  |     On-demand wiring     |   E.g. create exchanges & queues
        +--------------------------+
                     |
                     V
               Actual Wiring

Thus the protocol provides functionality to create and destroy exchanges
and queues, and register queues with exchanges.

Guidelines for implementors:

- An AMQP broker SHOULD support queue templating in which queues
  created at runtime can be configured by reference to a
  pre-configured template.

Durable Wiring
..............

An AMQ broker may hold purely transient data, but may equally hold
persistent data. In the first case we want a "clean restart" if a broker
is stopped and restarted. I.e. all dynamically-created exchange and queue
definitions should be wiped. In the second case we want a "reliable
restart" so that queues keep their contents safely.

We use the concept of a "durable resource". This is a resource created
by the client application but held by the broker as if it was a
configured resource. We need durable exchanges, durable queues, and
durable registrations. The opposite of "durable" is "transient".

The actual or required durability of a resource is defined as follows:

1. If a resource is part of the broker's configuration, it is always
   durable.  For example, an exchange defined in the broker configuration
   is always durable.

2. When a resource is created the client application may ask for it to
   be durable.  For example, a queue can be created as "durable".

3. If the client application attempts to create a dependency from a
   durable resource onto a transient resource, this causes a channel
   exception.  For example, if a client attempts to register a durable
   queue with a transient exchange the broker will close the channel with
   an appropriate error.
   
Worked Examples
---------------

Reconstructing Store and Forward
................................

Let us reconstruct queue-based "store and forward" using these building
blocks:

- We create a dest-name exchange called "queue".
- We agree that queue names are equal to the destination name placed
  in each message.
- We create a set of queues and register these with the "queue" exchange.
- Publishers send their messages to the "queue" exchange, specifying a
  destination name with each message.
- The "queue" exchange does a lookup on the destination name and passes
  the message to the matching queue.
- Consumers get their messages from each named queue.

Reconstructing Topics and Subscriptions
.......................................

Let us reconstruct topic-based "subscribe and publish" using these
building blocks:

- We create a dest-wild exchange called "topic".
- We agree that queue names are subscription names.
- We create one queue per subscription and attach these queues to
  the "topic" exchange.
- Publishers send their messages to the "topic" exchange, specifying a
  destination name with each message.
- The "topic" exchange does a topic-name match on the destination name
  and passes the message to all queues that match.
- Consumers get their messages from each named queue.

Reconstructing Temporary Destinations
.....................................

- A temporary queue is simply a queue created by a client, and flagged
  for automatic deletion when the client disconnects.

- A temporary topic has no meaning: topics do not exist except as values
  on which to match.

Implementation Details
----------------------

Queue Namespaces
................

We want to provide the client application with a consistent way to
distinguish different types of queue, for example "subscriptions" and
"private reply queues". These types have no meaning to the broker but to
avoid non-standard naming conventions we introduce the concept of a
"queue namespace", which is a type name. The broker simply prefixes the
queue name with the namespace to create a unique internal name.

By convention in many scenarios, the namespace will be the same as the
exchange name.

Thus a publisher may send to an exchange called "queue", while the consumer
might read messages from a queue in namespace "queue".

Queue Templating and Tuning
...........................

Templating is a normalisation technique: rather than define many objects
with similar properties we define a set of templates, and then refer to
these when we define new objects. In object-oriented development this
may be called a "class".

A queue template provides different types of information:

1. Organisation and tuning: file system criteria, maximum queue size,
   dead-letter queue, etc.
2. Constraints: e.g. max consumers.

Queue templating could be used to simplify the protocol. For example it
is useful to be able to specify "this queue must be deleted when there
are no more consumers". This could be a protocol flag or it could be a
template property, understood by the broker but not part of the explicit
protocol.

We have to decide which queue properties are made visible in the
protocol, and which can be configured in templates. Our choice is based
on the requirement for interoperability:

- A property that has an impact on interoperability must be visible
  in the protocol.
  
- A property that must be tunable by the administrator must be part
  of the template.

Thus the "delete this queue when there are no more consumers" must be
specified in the protocol, since it is necessary for interoperability.
The fact that a queue automatically disappears when it is no longer
needed is a vital part of some architectures. In contrast, a queue limit
such as the maximum number of messages allowed in memory before the
queue overflows onto disk is an adminisration concern, so must be part
of templated configuration.

Exchange Reference Design
.........................

We propose a reference design for the exchange concept. While this does
not form part of the protocol specification, and while each broker
implementation may implement exchanges as suitable, this reference
design may help to clarify the exchange concept.

We design each exchange as a processing class in the broker, with
properties and methods that allow it to operate. All exchanges have a
common abstract structure:

    +------+-------+-------------------+------------------------------+
    | Name | Class | Registration list | Class-specific properties... |
    +------+-------+-------------------+------------------------------+
                            :
                     +--------------+    +-------+
                     | Registration |--->| Queue |
                     +--------------+    +-------+
                            :
                     +--------------+    +-------+
                     | Registration |--->| Queue |
                     +--------------+    +-------+
                            :
                           ...

In some scenarios many queues will register with the same exchanges
using identical registrations. We can foresee that this will create
problems in high-volume scenarios - e.g. when several thousands of
queues register with the same exchange. Our class design therefore
normalises identical registrations, using a list of queues per
registration:

    +------+-------+-------------------+------------------------------+
    | Name | Class | Registration list | Class-specific properties... |
    +------+-------+-------------------+------------------------------+
                            :
                     +--------------+    +-------+    +-------+
                     | Registration |--->| Queue |--->| Queue |--->...
                     +--------------+    +-------+    +-------+
                            :
                     +--------------+    +-------+
                     | Registration |--->| Queue |--->...
                     +--------------+    +-------+
                            :
                           ...

Queueing and Routing Mechanisms
===============================

Goals and Principles
--------------------

The AMQP queueing and routing mechanisms define how content is moved
between an AMQP broker and its clients. Our goal is to define a single
coherent queueing and routing model that can support a range of different
highly-functional content classes.

Our design is based on these elements:

- Virtual hosts: an independent collection of exchanges and queues.

- Exchanges: an exchange distributes messages across queues.

- Queues: a queue distributes messages between consumers.

- Message persistence: defining the level of assurance that a message
  will be successfully delivered despite crashes and failures.

- Message priorities: allowing messages to be delivered out-of-sequence
  according to their importance.

- Queue browsing: allowing a client to read messages in a simple
  synchronous manner.

- Acknowledgements: allowing a client to tell the broker when it has
  successfully processed a message.

- Window-based flow control: allowing a client to control how many
  messages it receives

- Transactions: allowing a client to group multiple messages and
  acknowledgements into a single unit of work.

In general all these mechanisms apply to all content classes. Certain
content classes may elect to use a simpler model for performance
reasons. This is specifically the case for streamed content, which does
not support persistence, browsing, acknowledgements, or transactions.

Virtual Hosts
-------------

AMQP/Fast has explicit support for virtual hosts. The client chooses a
virtual host as the last stage in negotiating the connection. A virtual
host has its own set of exchanges, queues and access controls.

Exchanges
---------

Exchanges are named objects that act as message filters and multipliers.
Exchanges do not hold messages: rather they copy messages to queues. All
messages are published to exchanges.

Guidelines for implementors:

- Exchanges are not tied to specific content classes.

- A broker MUST allow any content class to be sent to any exchange, in any
  mix, depending on the access rights of the producing client.

- A broker SHOULD discard messages for which there are no valid queues.
  It MAY log such messages and/or send them to a dead-letter queue.

Queues
------

A queue is a named object that acts as an asynchronous buffer for
messages. Queues may be held in memory, on disk, or some combination.
Each virtual host provides a namespace for queues. Queues hold messages
and distribute them between one or more clients (consumers). A message
published to a queue is never sent to more than one client unless it
is is being resent after a failure or rejection.

Note that mixed content on a queue is generally sent asynchronously
using the appropriate Deliver methods, to those clients that have asked
for it.  The Browse method allows clients to selectively receive single
Basic, JMS or File messages but not Stream messages.

Guidelines for implementors:

- Queues are not tied to specific content classes.

- A broker MUST allow any content class to be sent to any queue, in any
  mix, depending on the access rights of the producing client.

Message Persistence
-------------------

A persistent message is held securely on disk and guaranteed to be
delivered even if there is a serious network failure, broker crash,
overflow etc.

Messages may be persistent or not, depending on several criteria:

1. In the Basic and JMS content classes, messages are individually
   marked as persistent or non-persistent.
2. In the File content class, messages are always persistent.
3. In the Stream content class, messages are never persistent.

Guidelines for implementors:

- The broker MUST do a best-effort to hold persistent messages on a
  fully-reliable storage medium.

- The broker MUST NOT discard persistent messages in case of
  overflow but SHOULD use the Channel.Flow method to slow or stop a
  producer when necessary.

- The broker MAY overflow non-persistent Basic, JMS or Stream messages
  to persistent storage, or MAY discard non-persistent Basica, JMS or
  Stream messages on a priority basis if the queue exceeds some
  configured maximum size.

Message Priorities
------------------

A high priority message is sent ahead of lower priority messages waiting
in the same queue or subscription.  When messages must be discarded in
order to maintain a specific service quality level the broker will first
discard low-priority messages.

Guidelines for implementors:

- A broker MUST implement at least 2 priority levels for non-persistent
  messages.  A broker MAY implement up to 10 priority levels.

- A broker MAY implement all persistent messages as a single priority.

Acknowledgements
---------------

When the client finishes processing a message it tells the broker via an
acknowledgement. AMQP/Fast defines different acknowledgement models for
different levels of performance and reliability:

- Acknowledgement by the application after it has processed a message.
- Acknowledgement by the client layer when it has received a message
  and before it passes it to the application.
- Acknowledgement by the broker when it has sent a message to the
  client.

The first two models use the same protocol mechanics.  The difference
is when the client API sends the acknowledgement.  The last model uses
a specific protocol option, in the CONSUME method for those classes
that support acknowledgement.

Flow Control
------------

AMQP/Fast flow control is based on these concepts:

1. Allowing the client to specify a prefetch - how many messages
   it will receive without acknowledgement.  We call this "window-based
   flow control".

2. Allowing one peer to halt and restart a flow of messages coming
   from the other peer, using the Channel.Flow method, which we call
   "channel flow control".

Since Publish methods are not acknowledged, there is no window-based
flow control for publishing and the recommended way to pause a publisher
is to use channel flow control.

Guidelines for implementors:

- A broker MUST support window-based flow control for clients.

- A broker MAY use channel flow control to pause publishers when
  queues or subscriptions overflow.

- A client MUST respect channel flow control when publishing
  messages to the broker.

- A broker MAY disconnect and/or ban clients that do not respect
  channel flow control methods.

Transactions
------------

AMQP/Fast supports three kinds of transactions, each kind progressively
slower, more complex, and more reliable:

1. Automatic transactions, in which every method is wrapped in a
   transaction. Automatic transactions provide no way to create units
   of work. Every message and acknowledgement is processed as a
   stand-alone transaction.

2. AMQP/Fast transactions, which cover units of work on a per-channel
   basis. Transactions cover messages published, and messages received
   and acknowledged. There is no "start transaction" method: a
   transaction starts when the channel is opened and after every commit
   or rollback. If the channel is closed without a commit, all pending
   work is rolled-back. Nested transactions are not allowed.

3. XA 2-phase transactions, using the XA class.  This is still under
   construction.

The transaction type is chosen on a per-channel basis.

Summary of Classes and Methods
==============================

Goals and Principles
--------------------

We aim to provide a clear and extensible organisation of the classes and
methods that a peer provides. Classes and methods are numbered but also
have constant names (shown in uppercase). The names are chosen to be
consistent across classes, so a similar method in different classes has
the same name and may have similar arguments where appropriate. The full
definition of each class and method is provided later.

We define methods as being either:

- a synchronous request ("syn request"). The sending peer SHOULD wait
  for the specific reply method, but MAY implement this asynchronously.

- a synchronous reply ("syn reply for XYZ").

- an asynchronous request or reply ("async").

A full explanation of classes and methods is provided in the Reference
section of this document.

[see ../kernel/amq_quick.txt]

Explanatory Notes
-----------------

Methods are numbered locally per class and there is no attempt to keep a
consistent numbering for similar methods in different classes, nor to
distinguish client or broker methods through special numbering schemes.
Method numbering has no significance beyond uniquely identifying the
method.

The grammars use this notation:

- 'S:' indicates data or a method sent from the broker to the client.
- 'C:' indicates data or a method sent from the client to the broker.
- +term or +(...) expression means '1 or more instances'.
- *term or *(...) expression means 'zero or more instances'.
- Methods are indicated by uppercase names, e.g. OPEN.


The Basic Operational Model
===========================

Goals and Principles
--------------------

The basic operational model is designed to provide the simplest
possible message store and forward model.  Basic messages are not acknowledged,
and cannot be put back onto a queue.

Basic Properties
----------------

These are the properties defined for basic content:

- ContentType (short string)
- ContentEncoding (short string)
- Destination (short string)
- Headers (field table)

The JMS Operational Model
========================

Goals and Principles
--------------------

JMS is a standard API for messaging middleware brokers. The AMQP/Fast
JMS implementation is compatible with providers that conform to the SUN
JMS specifications (within the bounds of JMS standardisation, which does
not guarantee interoperability). JMS messages can be published and
consumed using a set of methods that map to the JMS API, including:

- Publishing a message to a "queue".
- Publishing a message to a "topic".
- Creating a consumer for a queue.
- "Subscribing" to a "topic".
- Browsing a destination for messages.

JMS Content Properties
----------------------

These are the properties defined for JMS content:

- ContentType (short string)
- ContentEncoding (short string)
- Destination (short string)
- Headers (field table)
- DeliveryMode (octet)
- Priority (octet)
- CorrelationID (short string)
- ReplyTo (short string)
- Expiration (short string)
- MessageID (short string)
- Timestamp (short string)
- Type (short string)
- UserID (short string)
- AppID (short string)

The File Transfer Operational Model
===================================

Goals and Principles
--------------------

The file transfer operational model is designed for enterprise-wide
file transfer based on the AMQP/Fast queueing and routing models.  For
instance, routing files via the publish and subscribe functionality
of topics and subscriptions.

File content is specifically different from JMS content in that:

- Files are always persistent.
- File transfer is restartable: if a file has been
  partially transferred when a connection is broken, the sender
  can resend just the remainder.

File transfers always happen in two steps:

1. The sender "stages" the file into a temporary area provided by the
   recipient.
2. The sender notifies the recipient of the file, using Publish (a
   client to a broker), or Deliver (a broker to a client).

A File message is persistent and optimised for restartable transfers
across possibly unreliable network connections.

File Content Properties
-----------------------

These are the properties defined for File content:

- ContentType (short string)
- ContentEncoding (short string)
- Destination (short string)
- Headers (field table)
- Priority (octet)
- ReplyTo (short string)
- MessageID (short string)
- FileName (short string)
- Timestamp (short string)

The Stream Operational Model
============================

Goals and Principles
--------------------

Streaming is intended for multimedia applications: video, music, etc.
A stream consists of an unterminated series of messages, each message
containing a fragment of streamed data.

The AMQP/Fast streaming model separates the compression technology
(codec) from the streaming technology. The streaming model is compatible
with any codec that allows data to be fragmented.

Streamed messages use the full AMQP/Fast queueing and routing mechanisms
with some simplifications:

1. Streamed content is non-persistent though the broker MAY hold it on
   disk if needed.

2. Streamed data sent to a queue cannot be shared between multiple
   consumers (each would receive partial streams).

3. Streamed data sent to a subscription via a topic cannot be shared
   between multiple consumers (each would receive partial streams).

A stream producer can use topics to distribute streams to multiple
consumers at once.  Topics can be used - e.g. - to provide different
qualities of the same stream.

A stream consumer can specify the rate at which data is wanted.

Stream Content Properties
-------------------------

These are the properties defined for Stream content:

- ContentType (short string)
- ContentEncoding (short string)
- RoutingKey (short string)
- Headers (field table)
- Priority (octet)
- Timestamp (short string)

