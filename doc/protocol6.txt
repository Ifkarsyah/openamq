Scope and Requirements
**********************

 6. "Scope and Requirements", in which we state and analyse the scope
    and requirements of the AMQ standard.  This chapter comes last because
    it is a somewhat tedious but necessary argumentation. If you want to
    know why we built AMQ as we did, this chapter may enlighten.  Note
    that chapters 3, 4, and 5 include a statement of key requirements,
    but without argumentation.

 - To be clear, where each method does exactly one thing.
 - To be easily extended to handle new and changed needs.
 - To be consistent and explicit in naming.
 - To use a class/method/argument notation that maps easily into
   application-level APIs.
 - To guarantee interoperability between conforming implementations.
 - To provide the application with explicit control over the quality
   of service.
 
Restatement of Goals
....................

AMQ is designed to carry data ("messages") between applications
("clients") written in arbitrary languages and running on arbitrary
platforms spread across a fully-addressable network.

AMQ is designed to support many different types of application, each
with its own requirements as to:

- Message size, from zero bytes up to many gigabytes.
- Number of clients, from one up to many thousands.
- Volume of messages crossing the network, from a few per day to hundreds
  of thousands per second.
- Critical latency of a message, from a millisecond to an hour.
- Reliability of delivery, from "as reliable as possible, whatever the
  cost" to "best-effort delivery".
- Use of network, memory, CPU, and disk resources.

The same AMQ architecture must be able to work efficiently on a small
embedded message router, as well as on a supercluster with dozens of
CPUs and tens of gigabytes of memory.

Classic Message-Oriented Middleware
...................................

A classic message-oriented middleware server provides two types of
service: a "queue" service in which producers and consumers interact
via shared named queues, and a "topic" service which allows clients to
subscribe to a tree of topics. Clients subscribe with citeria such as
the topic name, or a pattern representing a set of topics, e.g.
"FOREX.*". The middleware explicitly provides functionality to
subscribe, manage topics, and so on.

AMQ does not provide these services directly: the protocol and server
make no mention of "topics" or "subscriptions". Rather, AMQ provides
more general building blocks that can easily be used to build a topic
service, a queue service, a mix of the two, and new kinds of service
that fall outside the classic definitions.


General Design Method
.....................

The main insights that led to our design (which is the third major
refactoring of the AMQ protocol) were:

1. Subscriptions can be designed as a special case of queues.  That is,
   subscriptions and queues can be designed to support exactly the same
   set of properties and access methods.  In the topic/subscription
   model subscriptions are simply queues that have a special matching
   technique and a private name space.

2. Matching can be abstracted.  That is, everything from matching on a
   specific routing key to matching on an SQL-like selector can be
   abstracted into a single concept.

3. Messages can have multiple instances.  That is, a message can be in
   many queues at the same time.  We do not copy message content, rather
   we use message reference counting.  Queues store references to
   messages rather than messages.  This applies both to persistent and
   non-persistent messages.

4. Queues and matching can be loosely-coupled.  That is, while one
   client "writes to queue X" and a second client "reads from queue
   X", this can be done using a less tightly-coupled relationship than
   the obvious "producer writes to queue".  Loose coupling is often
   desirable because it allows abstraction in which one side of a
   relationship can be reorganised without affecting the other.

We use these insights to define a set of building blocks that achieve
much wider functionality than classic messaging middleware (like JMS)
at no significant extra cost.


Purpose and Goals of AMQP/Fast
==============================

AMQP/Fast is designed to be the high-performance member of the AMQP
family of standardised general-purpose message-oriented middleware
wire-level protocols.

A "wire-level protocol" can be a simple as a "this is how we define
packets on the wire". AMQP/Fast is more ambitious than that. It tries to
provide formal answers to a series of questions that we must answer in
order to implement useful messaging between protocols.

We want to be able to:

- Construct logical "messages" out of data of any type and size, and
  move these message efficiently across a network of clients and
  servers.

- Provide queueing and routing semantics for messages so that the
  behaviour of the server is unambiguously defined by the protocol.

- Define explicit operational semantics for common messaging models,
  including JMS, file transfer, and streaming, at the protocol level.

- Define quality-of-service levels semantics so client applications can
  explicitly choose appropriate tradeoffs between speed and reliability.

- Create a fully-asynchronous network so that messages can be queued
  when clients are disconnected, and forwarded when they are connected.

- Allow interoperation and bridging with other middleware systems.

- Allow implementation in any language, on any kind of hardware.

- Avoid license and patent concerns that might hinder adoption of the
  protocol as a standard.

- Allow the marshalling layers of protocol implementations to be easily
  generated using code generation technology.

- Allow the creation of an abstract network where services, and their
  data, can move around the network opaquely to the clients.



Defining the Problem
*********************

Overview
========

To understand what AMQ is, and why we built it, we must look at the
kinds of problems that we wanted to solve.

Overall, messaging middleware is a critical layer in any system that
runs over more than a single server.  Even the simplest distributed
applications need reliable and fast message exchange between servers.

Traditionally there are three ways of doing this:

1. Write an ad-hoc messaging layer using TCP/IP, FTP, HTTP, SOAP, or
   one of the many other existing communication standards.

2. Use an open source message transfer layer.

3. Use a commercial product.

Each of these options has advantages: custom software is pliable and
can be tuned to specific needs; open source is cheap to use and cheap
to fix; commercial products are (hopefully) high-quality and come with
teams of skilled engineers.

But each of these options is also frustrating for their own reasons.
None of the existing standards are sufficiently high-level to handle
the real work, so any ad-hoc solution eventually breaks, or becomes a
significant project in itself.

Open source messaging products are generally low-quality and slow.
There are several reasons for this, probably the most important is
the lack of middleware engineering skill in the open source community.

Finally, commercial products are generally expensive, complex to use,
and closed.  They can be very reliable, so are found in many larger
projects.  But there is a fundamental frustration with closed-source
products: even the smallest bug fix means getting formal support, which
can take a long time.

The Ideal Solution
==================

The ideal solution, conceived by top engineers from JPMC's Investment
Banking division, was for an open source middleware standard that was
fast, reliable, portable, high-level, easy to use, well documented,
stable, good looking, and cheap to make.

In other words, something that combines all the advantages, with none
of the disadvantages, of the three main approaches to middleware.

We believe that we've accomplished much of this, and are on the way
to accomplishing it all.

General Concepts
================

We will step back and look at the kinds of problems we need to solve
when designing a general purpose middleware system.

The Three Functional Areas
--------------------------

Messaging middleware covers three main functional areas:

1. Point-to-point messaging, which we will call "queues"
   for simplicity.

2. High-volume publish/subscribe, which we will call "topics"
   for simplicity.

3. File transfer, which we will call "files" for simplicity.

(AMQ uses the term "queue" in a more specific sense to define a
specific type of component, but the above terms are generally accurate
when discussing middleware scenarios).

There is some overlap, but in general these three areas have particular
functional needs and need specific solutions. Point-to-point queuing
focusses on the ability to move messages from one party to another party.
Publish-subscribe focusses on distributing messages from one party to many
other parties. File transfer focusses on sending very large files across
slow and perhaps unreliable networks.

Reliability vs. Performance
---------------------------

In each case we can need various degrees of reliability and
performance.  In general there is a trade-off between reliability
and speed - the more reliable the system, the slower it will run.

Reliability can be broken into several aspects:

1. Type of memory used: system RAM or disk storage.  If we want
   messages to survive a system reboot, they must be on disk.

2. Degree of redundancy: none, mirrored.  If we want to survive
   a system failure (e.g. disk crash) we must have redundancy of
   some kind.

3. Redundancy distance: if we want a redundant system to survive
   a physical event (fire, lightning, hurricane), it must be
   physically separated.

4. Degree of transactionality: none, partial, full.  If we want to
   be certain that the data was safely written in a coherent manner
   we must use transactions (of varying complexity).

In each case, there is a well-understood cost for the extra reliability.

Scenario Matrix
===============

By combining the functional areas with the options for reliability,
we can plot the actual combinations that make sense and are commonly
used.  We use a scale from 1 to 5, meaning 'not too important' to
'critical'.  For each scenario we show the typical range for various
critria:

                          Queues  Topics  Files
    Throughput              2-3     4-5     1-2
    Latency                 3-4     4-5     1
    Reliability             3-5     1-5     4-5

We can conclude that there is a large overlap in needs, and rather
than try to define the three domains as separate problems, it seems
more useful to provide the application architect with control over
the reliability vs. performance tradeoff independently from the choice
of what kind of messaging model to use.

Example Scenarios
=================

We give some specific example scenarios:

 - Departmental inter-system communications: consisting of 1-10
   highly-reliable queues, with perhaps a thousand messages a day,
   serving one to five applications and perhaps 100 users.

 - Financial services information streams: consisting of data
   streams from information providers such as Reuters, being
   distributed to a thousand or more workstations.  Typical
   daily volume can be anything up to a billion messages.


Extreme Scenario - Market Data
------------------------------

Market data is an extreme scenario at the upper-end of what we are
aiming for with AMQ. We have set the benchmark at 100,000 events passing
through a server (or server cluster) per second between a set of
producer applications and a set of consumer applications. The occasional
dropped message is acceptable, but dropout should be measurable.

To achieve this rate of messaging requires high-specification hardware,
gigabit networking and significant tuning at all levels. Experience from
existing projects shows that even OS context-switch time becomes
significant at this rate of messaging. The topic space for event
notification should be able to handle 10,000 topics with 50% of traffic
volume going through 10% of the topics and delivered to 1,000
subscribers.


3. A statement and analysis of the technical requirements we have taken
   into account. By "technical", we mean the internal properties of the
   system, i.e. how it is constructed.


 - To be compact, using a binary encoding that packs and unpacks rapidly.
 - To handle messages of any size without significant limit.
 - To allow zero-copy data transfer (e.g. remote DMA).
 - To carry multiple channels across a single connection.
 - To be long-lived, with no significant in-built limitations.
 - To allow asynchronous command pipelining.
 - To be domain independent, handling JMS messages, file transfer, data
   streaming, voice, etc. without prejudice.
 - To be forward compatable with future versions.
 - To be repairable, using a strong assertion model.
 - To be language-neutral.
 - To have no license or patent restrictions.
 - To fit a code generation process.

3.  Technical Requirements
    technical = how
    performance
    portability
    longevity
    interoperability
    clarity
    extensibility


Intended Operating Lifespan
===========================

AMQP/Fast is designed to give a useful lifespan of 50 years or more. Our
goal is that an AMQP/Fast peer will be able to operate continuously
with no upgrades or incompatibility for at least this duration, without
requiring "legacy support". One should be able to build a client or
server into physical infrastructure.

While the protocol version may and will change, the protocol mechanics
(framing, method structures, etc.) must operate unchanged for the full
intended lifespan of the protocol, allowing full and perfect forwards
compatability with all future versions of the protocol.

We have applied "Moore's Law" - the theory of exponential growth of
capacity of technology - to all capacity limits to identify and
eliminate potential future bottlenecks, specifically for:

1. Message sizes: the largest messages (files) are today around 20GB. We
   expect this to grow by 50% per year, reaching the limit defined by a
   64-bit size in 50 years.

2. Frame sizes: IPv4 is limited to 64KB frames, IPv6 to 4GB frames.
   Ethernet itself is limited to 12000 byte frames due to its CRC
   algorithm. We expect the maximum networking frame size to grow by
   50% per year, in large leaps. We will thus reach the limit of
   64-bit sized packets in 50 years.

3. Protocol classes and methods: the current protocol defines about
   ten classes and about ten or fewer methods per class.  We assume
   that backwards compatability will be maintained by defining new
   classes and methods rather than modifying existing ones that are
   in use.  The limit of 64k classes and methods per class should be
   sufficient to last more than 50 years.

4. Channels: the limit of 4G channels allows growth of 50% per year
   from an estimated usage of 10 channels per connection today.

5. Timestamps: we use 64-bit time-stamp values.

An Extensible Functionality
===========================

AMQP/Fast is intended to be extensible in several directions, including
new directions totally outside the scope of the protocol as it is
designed today.  These are the aspects of AMQP/Fast that have been
deliberately designed to be extensible (in order of increasing
generality and power):

1. Adding new types of exchange to server implementations.
2. Adding new properties to content domains.
3. Adding new arguments to methods.
4. Adding new methods to classes.
5. Adding new content domains.
6. Adding new method classes.
7. Adding new frame types.
8. Adding new protocols.

All of these should be feasible while maintaining full backwards
compatability with existing implementations.

Ease of Implementation
======================

Our goal is to achieve some of the cost-benefit ratio of protocols such
as SMTP and HTTP, where a simple client can be trivial to build but a
full client can be very sophisticated. Keeping AMQP/Fast accessible to
simple clients is possible if we hold to these design rules:

1. The use of all complex functionality (e.g. more sophisticated data
   types or structures) must be optional.

2. The protocol must be able to operate entirely synchronously, since
   an asynchronous model - though more efficient and reliable - is a
   barrier for simple implementations.

3. The protocol must be formally defined so that significant parts of
   a client or server protocol interface can be mechanically generated
   using code generation techniques.



There are two main reasons why we don't just have one type of exchange
that does everything (the typical pre-AMQ middleware solution):

1. Different types of matching demand different exchange implementations.
   A general-purpose matching engine is too slow for common cases, and
   too complex to extend easily.  For example, content-based routing
   can (or must) be done in different ways, depending on the application.

2. Designing exchanges  an extensible framework makes it possible to
   add new functionality to the process, in a useful place, and in a
   simple way.

Multiple Exchange Instances
---------------------------

When we speak of "an exchange" as an active entity, we mean the instance,
not the type.  There are various reasons why we would want multiple
exchange instances of single type:

1. Scalability - exchanges may be scalable to certain limits, and to
   avoid passing those limits, it may be useful to split a heavily
   used exchange into two instances.

2. Distribution - it may be useful to run separate exchanges in their
   own threads to better use a multi-processor system.

3. Security - we plan to apply access controls to the data entering
   and leaving an exchange.  This would require one exchange per access
   control realm.


