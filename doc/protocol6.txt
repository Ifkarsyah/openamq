4. The Technical Layer
    technical objects & lifecycle
    framing layers
    content encoding
    limitations
    how connections work
    negotiation
    multichannels
    tokenisation


Limitations
===========

These limitations are formally part of the AMQP/Fast specifications:

- Number of channels per connection: 65535.
- Size of a short string: 0 to 255 octets.
- Size of a long string or field table: 0 to 4Gb-1 octets.
- Size of a frame: 0 to 4Gb-1 octets.
- Number of protocol classes/content domains: 65535.
- Number of methods: 65535 per protocol class.

Data Type Representation
========================

Goals and Principles
--------------------

We use a small set of basic data types that are guaranteed to work on
all platforms and be easily implemented in all languages. More
sophisticated data types can be packaged using the basic AMQP/Fast data
types.

Formal Grammar for AMQP/Fast Fields
-----------------------------------

This formal grammar defines the AMQP/Fast data types:

    amqp-field          = BIT
                        / OCTET
                        / short-integer
                        / long-integer
                        / long-long-integer
                        / short-string
                        / long-string
                        / time-stamp
                        / field-table
    short-integer       = 2*OCTET
    long-integer        = 4*OCTET
    long-long-integer   = 8*OCTET
    short-string        = OCTET *string-char
    string-char         = %d1 .. %d255
    long-string         = long-integer *OCTET
    time-stamp          = long-long-integer
    field-table         = long-integer *field-value-pair
    field-value-pair    = field-name field-value
    field-name          = short-string
    field-value         = 'S' long-string
                        / 'I' signed-integer
                        / 'D' decimal-value
                        / 'T' time-stamp
                        / 'F' field-table
    signed-integer      = 4*OCTET
    decimal-value       = decimals long-integer
    decimals            = OCTET

Guidelines for implementors:

- A peer MUST support all the above data types.

Integers
--------

AMQP/Fast defines these integer types:

- Bit values.
- Unsigned octet (8 bits).
- Unsigned short integers (16 bits).
- Unsigned long integers (32 bits).
- Unsigned long long integers (64 bits).

Integers and string lengths are always unsigned and held in network byte
order. We make no attempt to optimise the case when two low-high systems
(e.g. two Intel CPUs) talk to each other.

Guidelines for implementors:

- Implementors MUST NOT assume that integers encoded in a frame are
  aligned on memory word boundaries.

Bits
----

Bits are accumulated into whole octets.  When two or more bits are
contiguous in a frame these will be packed into one or more octets,
starting from the low bit in each octet.  There is no requirement that
all the bit values in a frame be contiguous, but this is generally
done to minimise frame sizes.

Strings
-------

All strings are variable-length and represented by an integer length
followed by zero or more octets of data.  AMQP/Fast defines these
string types:

- Short strings, stored as an 8-bit unsigned integer length followed
  by zero or more octets of data.  Short strings are capable of
  carrying UTF-8 data, and may not contain binary zero octets.
  In the current version of the protocol short strings may only
  contain US-ASCII (ISO-8859-1) characters.

- Long strings, stored as a 32-bit unsigned integer length followed
  by zero or more octets of data.  Long strings can contain any data.

Timestamps
----------

Time stamps are held in the 64-bit POSIX time_t format with an accuracy
of one second.  By using 64 bits we avoid the future wraparound issues
associated with the POSIX 31 and 32-bit values.

Field Tables
------------

Field tables are long strings that contain name-value pairs. Each
name-value pair is a structure that provides a field name, a field type,
and a field value. A field can hold a tiny text string, a long string,
a long signed integer, a decimal, a date and/or time, or another field
table.

Guidelines for implementors:

- Field names MUST start with a letter, '$' or '#' and may continue with
  letters, '$' or '#', digits, or underlines, to a maximum length of 128
  characters.

- A peer SHOULD validate field names.

- Specifically and only in field tables, integer values are signed (31
  bits plus sign bit).

- Decimal values are not intended to support floating point values, but
  rather business values such as currency rates and amounts. The
  'decimals' octet is not signed.

- A peer MUST handle duplicate fields by using only the first instance.

As a convention when documenting values allowed in field tables we will
use this syntax:

    Name=(Type)Content

For example:

    EXPIRATION-TIME=(Time)
    IDENTIFIER=(String)01-ABCD-9876
    MAXIMUM-SIZE=(Integer)

Negotiating a Connection
========================

Goals and Principles
--------------------

Negotiation means that one party in a discussion declares an intention
or capability and the other party either acknowledges it, modifies it,
or rejects it. In AMQP/Fast, we negotiate a number of specific aspects
of the protocol:

1. The actual protocol and version.
2. Encryption arguments and the authentication of both parties.
3. Operational constraints.

Protocol and Version
--------------------

An AMQP client and broker agree on a protocol and version using this
negotiation model:

1. The client opens a new socket connection on a well-known or
   configured port and and sends an initiation sequence consisting
   of the text "AMQP" followed by a protocol ID (2 decimal digits) and
   a protocol version (2 decimal digits holding the high and low version
   numbers).

2. The broker either accepts or rejects the initiation sequence.  If
   it rejects the initiation sequence it closes the socket. Otherwise it
   leaves the socket open and implements the protocol accordingly.

Protocol grammar:

    protocol-header     = 'AMQP' protocol-id protocol-version
    protocol-id         = protocol-class protocol-instance
    protocol-class      = OCTET
    protocol-instance   = OCTET
    protocol-version    = protocol-major protocol-minor
    protocol-major      = OCTET
    protocol-minor      = OCTET

For AMQP/Fast these are the correct values:

- protocol-class = 1 (this is the class of all AMQP/Fast protocols)
- protocol-instance = 1 (this is the instance of AMQP/Fast over TCP/IP)
- protocol-major = 9 (version 1.0 is 10, highest possible release is 25.5)
- protocol-minor = n (current release of minor version)

    +---+---+---+---+---+---+---+---+
    |'A'|'M'|'Q'|'P'| 1 | 1 | 9 | n |
    +---+---+---+---+---+---+---+---+
                8 octets

Guidelines for implementors:

- An AMQP broker MAY accept multiple AMQP protocols including AMQP/Fast
  on the same socket.

- An AMQP broker MAY accept non-AMQP protocols such as HTTP.

- An AMQP broker MUST accept the AMQP/Fast protocol as defined by
  class = 1, instance = 1.

- If the broker does not recognise the first 4 octets of data on the
  socket, or does not support the specific protocol version that the
  client requests, it MUST close the socket without sending any
  response back to the client.  The broker SHOULD print a diagnostic
  message to assist debugging.

- An AMQP client MAY detect the broker protocol version by attempting
  to connect with its highest supported version and decreasing this if
  the broker rejects the connection.

- An AMQP broker MUST NOT ban or delay a client that requests an
  unsupported protocol version.

- An AMQP broker MAY ban or delay a client that requests unknown
  protocol IDs.

The protocol negotiation model is compatible with existing protocols
such as HTTP that initiate a connection with an constant text string,
and with firewalls that sniff the start of a protocol in order to decide
what rules to apply to it.

Encryption and Authentication
-----------------------------

AMQP/Fast uses the SASL architecture for security. SASL encapsulates
TLS, GSSAPI, Kerberos, and other encryption and authentication
technologies.

Security is negotiated between broker and client as follows:

1. The broker sends a challenge to the client. The challenge lists the
   security mechanisms that the broker supports.
2. The client selects a suitable security mechanism and responds to the
   broker with relevant information for that security mechanism.
3. The broker can send another challenge, and the client another
   response, until the SASL layer at each end has received enough
   information.
4. The broker can now use the selected security mechanism and
   authenticated client identity to perform access controls on its
   data and services.

The "relevant information" is an opaque binary blob that is passed
between the SASL layers embedded in the client and in the broker.

SASL gives us the freedom to replace the security libraries with better
(more secure or faster) technologies at a later date without modifying
the protocol, the client, or the broker implementations.

Client and broker Limits
------------------------

The protocol allows the client and broker to agree on limits to ensure
operational stability. Limits allow both parties to pre-allocate key
buffers, avoiding deadlocks. Every incoming frame either obeys the
agreed limits, so is "safe", or exceeds them, in which case the other
party is faulty and can be disconnected.

Rather than fix the limits in the protocol, we negotiate them. This lets
us tune the protocol dynamically for different types of efficiency, e.g.
minimal memory consumption vs. maximum performance.

Limits are negotiated to the lowest agreed value as follows:

1. The broker tells the client what limits it proposes.
2. The client can respond to lower the limits for its connection.

Identification and Capabilities
-------------------------------

During the negotiation of limits the peers MUST pass this mandatory
information about themselves:

- The specific content domains that they support (see later).

And the peers MAY pass this optional information about themselves:

- Their public product name, for logging and tracking.
- Their version number.
- The platform they are running on.

For security reasons, all these pieces of information are optional and a
highly-security conscious peer MAY choose to provide some or none of
them. A peer MUST NOT use this information to adapt its behaviour.

Multiplexing and Pipelining
===========================

Goals and Principles
--------------------

Connection multiplexing allows multiple threads of communication to
share a single socket connection. This is valuable when threads are
short-lived since the cost of opening and closing TCP/IP sockets can be
relatively high.

Pipelining means that each peer can send frames asynchronously without
waiting for the recipient to acknowledge each one. This is an important
facility because it greatly improves performance.

Multiplexing Design
-------------------

AMQP/Fast uses the concept of "channel" to carry bi-directional streams
of communication between peers.  AMQP/Fast provides methods to open,
use, and close channels.  Large messages are broken into smaller frames
so that channels get fair (round-robin) use of the socket connection.

Pipelining Design
-----------------

Our design is based on these principles:

1. Most operations succeed.  We can thus optimise traffic in many cases
   by stating that "no response" means "successful".

2. Channels represent serial streams, where the order of methods and
   their acknowledgements is stable.

3. In general we want to send data as fast as possible in an asynchronous
   fashion.  Where necessary, we can implement windowing and throttling
   at a higher level.

The recipient indicates an error by closing the channel. The close
method includes the ID of the method that caused the error.  Methods on a
specific channel are processed strictly in order.

The Framing Design
==================

Goals and Principles
--------------------

Framing is the part of the protocol where we define how data is sent "to
the wire".  The framing design used in AMQP/Fast is designed to be compact,
easy and very fast to parse, extensible, and robust.

The key parts of this design are:

- How the transport layer carries data.
- How we delimit frames on the connection.
- How we multiplex frames on the connection.
- How different types of frame carry data.
- How we handle out-of-band transport.
- How we support future protocols (e.g. IPv6).

The Transport Layer
-------------------

We assume a reliable stream-oriented network transport layer (TCP/IP or
equivalent). If an unreliable transport layer is used, we assume that
the AMQP/Fast frames would be wrapped with additional traffic-control
information such as windowing.

AMQP/Fast explicitly excludes any support for traffic control but does
not disallow this to be implemented in an additional layer. We may at a
future point provide protocol wrappers that wrap AMQP/Fast frames with
traffic management to allow reliable transfer over multicast and
point-to-point UDP.

Delimiting Frames
-----------------

TCP/IP is a stream protocol, i.e. there is no in-built mechanism for
delimiting frames. Existing protocols solve this in several different
ways:

- Sending a single frame per connection. This is simple but adds
  considerable overhead to the protocol due to the opening and closing
  of connections.

- Adding frame delimiters to the stream. This is used in protocols
  such as SMTP but has the disadvantage that the stream must be parsed
  to find the delimiters. This makes implementations of the protocol
  slow.

- Counting the size of frames and sending the size in front of each
  frame. This is the fastest approach, and our choice.

Each frame is thus sent as a "frame header" which contains the frame
size, followed by a "frame body" of the specified size (the header is
not counted). Frames can carry methods and other data. To read a frame
we use this logic:

1. Read and decode the frame header to get the size of the frame body.
2. If the frame body is larger than the agreed limit, close the
   connection with a suitable error reply code.
3. Otherwise, read the specified number of octets into a frame buffer.
4. Decode the frame buffer as needed.

To write a frame we use this logic:

1. Marshal the frame buffer as needed.
2. Encode the length of this buffer into a frame header and write it.
3. Write the frame buffer contents, being the frame body.

Guidelines for implementors:

- A peer MUST write the frame body immediately after the frame header
  unless the body size is zero, or out-of-band transport is being used.

The Frame Header Wire Format
----------------------------

All frames start with an 8-octet header composed of a one-octet type
field, a 1-octet frame cycle field, a 2-octet channel field and a long
'size' field:

    0      1       2         4             8               size+4
    +------+-------+---------+----------+  +------------+  +-----------+
    | type | cycle | channel |   size   |  | frame body |  | frame-end |
    +------+-------+---------+----------+  +------------+  +-----------+
     octet   octet    short      long       size-1 octets      octet

AMQP/Fast defines these types of frame:

- Type = 1, "METHOD": method frame.
- Type = 2, "HEADER": content header frame.
- Type = 3, "BODY": content body frame.
- Type = 4, "OOB-METHOD": out-of-band method frame.
- Type = 5, "OOB-HEADER": out-of-band band header frame.
- Type = 6, "OOB-BODY": out-of-band body frame.
- Type = 7, "TRACE": trace frame.
- Type = 8, "HEARTBEAT": heartbeat frame.

The cycle field should be incremented for each frame sent, and provides
a peer with a safe way to resend partially-sent data after a connection
failover - see later discussion on this.

The channel number is 0 for all frames which are global to the connection
and 1..65535 for frames that refer to specific channels.

The size field includes the end field, a single octet with the value
%xCE.  While AMQP assumes a reliable connected protocol, we use a frame
end to allow easy detection of framing errors caused by incorrect client
or broker implementations.

Guidelines for implementors:

- If a peer receives a frame with a type that is not one of these defined
  types, it MUST treat this as a fatal protocol error and close the
  connection without sending any further data on it.

- The peer that implements connection failover MUST increment the cycle
  field on each frame sent, mod 256, per frame type.  A cycle value of
  zero has no special meaning.

- A peer that does implement connection failover MAY set the cycle field
  to zero on all frames sent.
  
- All frames include the frame-end octet. The minimum value for the size
  field is 1.

- When a peer reads a frame it SHOULD check that the frame-end is valid
  before attempting to decode the frame.  If the frame-end is not valid
  it MUST treat this as a fatal protocol error and close the connection
  without sending any further data on it.  It SHOULD log information
  about the problem, since this indicates an error in either the broker
  or client framing code implementation.

Method Frames
-------------

The method frame design is intended to be fast to read and write, and
compact when only partly filled.

Method frames (also called "methods" in the following discussion, for
brevity) are invariant. They contain no conditional or repeated fields.
Methods are constructed out of a constant series of AMQP/Fast data
fields (bits, integers, strings and string tables). Thus the marshalling
code can be easily generated, and can be very rapid. In the OpenAMQ
broker and clients this code is generated directly from the protocol
specifications.

Content Frames
--------------

Certain methods signal to the recipient that there is content arriving
on the connection.  Simple content consists of a header frame followed
by zero or more body frames.  Structured content may consist of a series
of header frames followed by the appropriate body frames.

Looking at the frames as they pass on the wire, we might see something
like this:

    [method]
    [method] [header] [body] [body]
    [method] [header] [body] [body]
    [trace]
    [method]
    ...

There is a specific reason for placing content body in distinct frames
as compared to including the header and body in the method. We want to
support "zero copy" techniques in which content is never marshalled or
encoded, and can be sent via out-of-band transport such as shared memory
or remote DMA.

Guidelines for implementors:

- The channel number in content frames MUST NOT be zero.

- Content frames on a specific channel form an strict list. That is,
  they may be mixed with frames for different channels, but two contents
  may not be mixed or overlapped on a single channel, nor may content
  frames for a single content be mixed with method frames on the same
  channel.

Out-of-Band Transport Frames
----------------------------

Method, content header, and content body frames can be sent using
out-of-band transport. The frame header is sent on the normal connection
but the frame body is sent via another mechanism. The specific
out-of-band transport used, and its configuration, is defined when a
channel is opened.

Trace Frames
------------

Trace frames are intended for a "trace handler" embedded in the
recipient. The significance and implementation of the trace handler
is implementation-defined.

Guidelines for implementors:

- Both broker and client MAY send trace frames at any point in the
  connection after protocol negotiation and before a Connection.Close
  method.

- If the recipient of a trace frame does not have a suitable trace
  handler, it MUST discard the trace frame without signalling any error
  or fault.

- The semantics and structure and of trace frames including the channel
  number are not formally defined by AMQP/Fast and implementations MUST
  NOT assume any interoperability with respect to trace frames unless
  and until formal standards are defined for these.

Heartbeat Frames
----------------

Although TCP/IP guarantees that data is not dropped or corrupted it can
be slow to detect that a peer process has gone "offline". The heartbeat
frame allows peers to detect network failure rapidly. This frame has no
body.

The peers negotiate heartbeat parameters at the start of a connection.

Guidelines for implementors:

- The channel number in a heartbeat frame MUST be zero.

- An AMQP peer MUST handle a non-zero channel number as a connection
  exception.

Connection Failover
-------------------

AMQP/Fast provides a connection failover mechanism that can be used by
clients to recover a connection and its broker-side state in case of
network errors (e.g. a connection across a fire-wall being reset).

The details of this mechanism are described in the Connection.Open
specifications.

In gross terms, the broker issues the client with a connection key,
called the "context key", once the connection has been established.
"Established" means going through authentication and negotiation. A
client starting a new connection will request a new context key from the
broker, and then proceed to define some state - opening channels, etc.

In case of a connection failure, the broker will hold the connection and
its broker-side state for a period of time - e.g. one minute. During
this time, the client may reconnect and estabish a new connection. When
the client has established the connection, rather than requesting a new
context key, it provides the broker with the previous ('old') key. The
broker will verify that this refers to a suspended connection and if so,
transfers the state from that old connection to the new connection.

The client should hold its state in memory during this process, so that
it can equally transfer its open channels, etc. to the new connection.

The frame cycle field is used to recover the session, once this process
is complete and both peer are satisfied that the connection is alive.

When a connection break is detected, each peer must save the last method
sent, and the last method received. Once the connection has been
re-established the client re-sends the last method it sent. The broker
decides whether it has seen this method or not, according to its saved
state. If it already saw this method, it resends the last method that it
sent. If not, it processes the method and continues as usual.

In a synchronous exchange of methods, this protocol guarantees that no
methods can be lost.  In an asynchronous exchange of methods, data sent
in one direction may be lost.  Where asynchronous methods must be
reliable, acknowledgements are used explicitly.

The Class/Method Model
======================

Goals and Principles
--------------------

AMQP/Fast allows two peers to connect and pass data. There are
several types of data and several ways of exchanging this data. The
combinations rapidly get complex. Worse, it is not always clear which
replies depend on which requests, since the passing of data is often
asynchronous, pipelined, and generally hard to follow.

Rather than attempt to formalise the exact flow of data from client to
broker and back, we use a metaphor taken from the software world,
namely the object-oriented metaphor of "classes" and "methods".

We build this as follows:

1. Each peer supports a set of classes.  These classes have names
   and cover specific areas of functionality.  A peer can support
   all the AMQP/Fast classes, or a subset of them.  Since the
   operational functionality of the protocol depends on the classes,
   the operational functionality of a particular implementation is
   clear to see.

2. Each class supports a set of methods.  These methods have names
   and provide specific functionalities.  A peer can support all
   the AMQP/Fast methods in a particular class, or a subset of them.
   As with classes, this unambiguously defines the operational
   functionality of a peer.

3. The methods are either synchronous or asynchronous.  A synchronous
   method replies immediately.  An asynchronous method replies at some
   later time and may send multiple replies.  A method "replies" by
   invoking the appropriate method in the requesting peer.  A request
   and reply always involves two methods: one to implement the request
   and one to implement the reply.

4. Each method is either a client method, broker method, or provided by
   both client and broker). A particular method in a particular class
   always has an identical behaviour whether it is in a "client" or
   "broker".

5. A peer can thus combine the roles of client and broker in various
   degrees by implementing the necessary classes and methods. At any
   point the operational functionality of the peer can be unambiguously
   defined by the methods that it supports.

Client and broker Roles
------------------------

The AMQP/Fast protocol is quasi-symmetrical with client-initiated
connections. We can visualise the protocol as governing two levels of
connection - network connections (sockets) and virtual connections
(channels):

    +-----------+-----------+-----------+-----------+
    |  channel  |  channel  |  channel  |  channel  |
    +-----------------------------------------------+
    |                    socket                     |
    +-----------------------------------------------+

Each peer involved in a connection (socket and channel) is strictly
a client or a broker.  The client initiates the connection and the
broker accepts the connection.  This applies both to network and to
virtual channel connections:

1. The client requests the broker to open connection.
2. The broker responds and the peers agree on connection parameters.
3. The client and the broker exchange information.
4. Either peer requests to close the connection.
5. The other peer responds and they negotiate the shut-down.

AMQP/Fast forsees two main architectures that use this model:

1. Client-broker, in which the same peer acts as client in all
   connections.  This is the "usual" architecture.
2. Peer-to-peer, in which one peer acts as client in the network
   connection but the peers can take either role in the virtual
   connection.

The peer-to-peer architecture requires that both peers can act as both
client and broker.

Guidelines for implementors:

- A peer MUST support at least either the client or broker role.

- A peer MAY support both roles.

Method Frame Body Wire Format
-----------------------------

A method frame body has this format:

    0       1        2       
    +----------+-----------+-------------- - -
    | class-id | method-id | arguments...
    +----------+-----------+-------------- - -
       short      short    ...

- The class-id and method-id are protocol-constant values.

- The arguments are a set of AMQP/Fast fields that specific to each
  method.

The Abstract Content Model
==========================

AMQP/Fast uses an abstract content model that has these goals and
features:

- It supports tree-structured content in which each content can
  contain further content ("child-content"), to any level.

- It provides multiple content types to allow optimal encoding for
  different applications.

- It supports content bodies of any size from zero octets upwards.

- Content body can be read and written directly from application memory
  with no formatting or copying ("zero copy").

- Content headers are sent before content body so that the recipient can
  selectively discard content that it does not want to process.

- Content body is sent in separate frames to support the AMQP/Fast
  channel multiplexing model.

Formal Grammar for Content Frames
---------------------------------

This is the formal grammar for the AMQP/Fast content model:

    content         = header-frame child-content *body-frame
    header-frame    = HEADER channel frame-size header-payload frame-end
    channel         = octet
    frame-size      = short-integer
    header-payload  = class-id weight body-size
                      property-flags property-list
    content-class   = OCTET
    content-weight  = OCTET
    body-size       = long-long-integer
    property-flags  = 15*BIT %b0 / 15*BIT %b1 property-flags
    property-list   = amqp-field
    child-content   = weight*content
    body-frame      = BODY channel frame-size body-payload frame-end
    body-payload    = *OCTET
    frame-end       = OCTET %xCE

Content Header Frame Wire Format
--------------------------------

A content header frame has this format:

    0          2        4           12               14
    +----------+--------+-----------+----------------+------------- - -
    | class-id | weight | body size | property flags | property list...
    +----------+--------+-----------+----------------+------------- - -
       short     short    long long       short        remainder...

- The content class specifies the set of properties (with a predefined
  syntax and semantics) that the header frame may hold. The content
  class-id matches the method class-id used when carrying content.
  E.g. a method like Jms.Deliver uses the same class-id (the integer
  constant representing 'Jms') both in the method frame and the
  content header frame.

- The weight field specifies whether the content is structured or not.
  Unstructured content has a weight of zero.  Structured content has a
  weight of 1 to 65535. This is the number of child-contents that the
  content contains.

- The body size is a 64-bit value that defines the total size of the
  body content.  It may be zero, indicating that there will be no
  body frames.

- The property flags are a bit array that indicates the presence or
  absence of each property value.

- The property values are class-specific data fields.  The properties
  are formatted as AMQP/Fast data types (integers, strings, field tables).

- Bit properties are indicated ONLY by their respective property flag
  (1 or 0) and are never present in the property list.

The set of properties for a content class can be any size. The first
two properties for all content classes are the content MIME type and the
content encoding. Following these, each content class has a specific
set of properties defined in a strict order from most to least
significant.

As an example, we take an imaginary content class "D" which has three
properties, T, E and C. Imagine a simple content that has properties E
and C but not T. The header frame will be formatted thus:

     class-id  weight   body size   property flags   property list
    +--------+--------+-----------+----------------+-------+
    |   D    |   0    |    nnn    | 011...         | E | C |
    +--------+--------+-----------+----------------+-------+

The property flags are ordered from high to low, the first property
being indicated by bit 15, and so on:

     15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    | T | E | C |                                               | 0 |
    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

The property flags can specify more than 16 properties. If bit 0 is set,
it indicates that a further property flags field follows. There can be
several property flag fields in succession:

     15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    |                                                           | 1 |
    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    |                                                           | 1 |
    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    |                                                           | 0 |
    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

Guidelines for implementors:

- A peer MUST check that the content class id matches the method
  class id and raise a connection exception if this is not the case.

Content Body Frame Wire Format
------------------------------

A content body frame has this format:

    +-----------------------+-----------+
    | Opaque binary content | frame-end |
    +-----------------------+-----------+

Where the size of the frame is defined in the frame header. A body frame
of size 1 (consisting just of the frame-end octet), which would normally
be meaningless, has special significance - it tells the recipient that
the content is ending prematurely, i.e. is incomplete. Thus, if a sender
decides to cancel a large message but keep the channel open, it will
send a content frame of size 1 and then continue as if the content had
been fully sent. The recipient may decide to process or discard the
content, depending on the application.

Structured Content
------------------

The "weight" field in the content header frame indicates whether the
content has child-contents or not. In the simplest case (weight = zero)
content consists of a header frame plus zero or more body frames:

    [header] [body] [body]...

If the content has child-contents, these are inserted between the
header and body of the parent content:

    [parent-header]
        [child-header] [child-body] ...
    [parent-body]

This organisation means that a principal content (e.g. a very large
video file) can have child content (e.g. subtitles and menus) which will
be sent before the main content. If a more specific order of content is
needed, it can be done by defining a top-level content that has no body,
only a header.

Multiplexed Channel Content
---------------------------

Content consists of one or more frames. The recipient of content that
has been sent in multiple frames can unambiguously reconstruct the
content by implementing the content grammar defined above, on a
per-channel basis.

Guidelines for implementors:

- Content frames MUST be sent on a single channel, and MUST NOT be
  intermixed with non-content frames on the same channel (method, trace,
  and heartbeat frames).

- Content frames MUST NOT be intermixed with frames of a different
  content.

- A peer MUST NOT make any assumptions about the minimum or maximum size
  of a body frame except that the minimum size is zero bytes and the
  maximum size is the smallest of either the negotiated maximum frame
  size or the remaining expected of content body (body-size minus amount
  of body data received so far).

- Empty body frames are permitted but a peer may not assign any special
  meaning to these: it MUST discard them with no side-effects of any kind.

Content Classes
----------------

The content class is not intended to provide data typing or encoding
information. Its purpose is to allow functional clarity in the property
sets and methods that we define per class of message.

Content classes turn AMQP/Fast from an abstract content-carrying
protocol into a functional tool by providing data and operations that
are directly and clearly mapped to the kinds of API that an application
programmer needs to see.

AMQP/Fast defines these standard content classes:

- Basic: the content is an untyped message.
- JMS: the content is a JMS-compliant message.
- File: the content is a persistent file.
- Stream: the content is a streamed message.

Note that the ID of each content class is the same as the ID of the
protocol class (Basic, JMS, File, Stream) that supports it.

Each class has a specific access model, though they all share the basic
AMQP queueing and routing mechanisms including topic multipliers. These
classes are defined in the next sections.  This model lets us extend
AMQP/Fast into new functional areas by defining new content classes and
appropriate methods, without breaking interoperability.

Guidelines for implementors:

- The client MAY support any or all of the defined content classes.

- The broker MUST support at least one of the defined content classes.

Content Type and Encoding
-------------------------

AMQP/Fast enforces MIME-compliance on all content classes using two
standard properties that are the first defined in all content classes:

- ContentType (short string) - the MIME content type of the message body.
  The default value is "application/octet-stream".

- ContentEncoding (short string) - The content encoding of the message
  body. The default value is "binary".

Guidelines for implementors:

- The broker SHOULD not modify the ContentType and ContentEncoding
  for content moved between producing and consuming clients.

- The broker MAY set the ContentType and ContentEncoding properties
  for content produced by the broker or by applications embedded in
  the broker.

Error Handling
==============

Goals and Principles
--------------------

Error handling is a critical aspect of any protocol.  First, we need a
clear statement of what situations can provoke an error.  Secondly, we
need a clear way of reporting errors.  Lastly we need unambiguous error
handling that leaves both peers in a clear state.

The AMQP/Fast error handling model is based on an answer to each of these
questions:

1. Use an exception-based model to define protocol correctness.
2. Use existing standards for error reporting.
3. Use a hand-shaked close to handle errors.

Existing Standards
------------------

The standard for error handling (defined semi-independently in several
IETF RFCs) is the 3-digit reply code. This format has evolved into a
fine-grained tool for communicating success or failure.  It is also
well-structured for expansion as a protocol gets more mature.

The current AMQP reply codes are standard to all protocols in the AMQP
family and are defined in AMQ RFC 011.

The reply code is constructed as follows:

- The first digit - the completion indicator - reports whether the
  request succeeded or not.
- The second digit - the category indicator - provides more information
  on failures.
- The third digit - the instance indicator - distinguishes different
  situations with the same completion/category.

The completion indicator has one of these values:

    1 = ready to be performed, pending some confirmation.
    2 = successful.
    3 = ready to be performed, pending more information.
    4 = failed, but may succeed later.
    5 = failed, requires intervention.

The category indicator has one of these values:

    0 = error in syntax.
    1 = the reply provides general information.
    2 = problem with session or connection.
    3 = problem with security.
    4 = application-specific.

The instance indicator is 0 to 9 as needed to distinguish different
situations.

The Assertion/Exception Model
-----------------------------

AMQP/Fast uses an assertion/exception model that has these goals:

- identify and document all protocol preconditions ("assertions").
- define the exception level caused by any assertion failure.
- define a formal procedure for handling such exceptions.

AMQP/Fast defines two exception levels:

1. Channel exceptions.  These close a single virtual connection.
   A channel exception is raised when a peer cannot complete some
   request because of transient or configuration errors.

2. Connection exceptions.  These close the socket connection.
   A connection exception is raised when a peer detects a syntax
   error, badly-formed frame, or other indicator that the other
   peer is not conformant with AMQP/Fast.

We document the assertions formally in the definition of each class
and method.

Hand-shaked Closure
-------------------

Closing a connection for any reason - normal or exceptional - must be
done carefully.  Abrupt closure is not always detected rapidly, and
in the case of errors, it means that error responses can be lost. The
correct design is to hand-shake all closure so that we close only after
we are sure the other party is aware of the situation.

A peer can close a channel or connection at any time for internal
reasons, or as a reaction to an error.  It sends a Close method to
the other party.  The receiving peer must respond to a Close with a
Close-Ok method.  The closing peer reads methods back until it gets a
Close-Ok, at which point it closes the connection and frees resources.

Security
========

Goals and Principles
--------------------

We guard against buffer-overflow exploits by using length-specified
buffers in all places.  All externally-provided data can be verified
against maximum allowed lengths whenever any data is read.

Invalid data can be handled unambiguously, by closing the channel or
the connection.

Buffer Overflows
----------------

All data is length-specified so that applications can allocate memory in
advance and avoid deadlocks. Length-specified strings protect against
buffer-overflow attacks.

Denial of Service Attacks
-------------------------

AMQP/Fast handles errors by returning a reply code and then closing the
channel or connection. This avoids ambiguous states after errors.

It should be assumed that exceptional conditions during connection
negotiation stage are due to an hostile attempt to gain access to the
broker. The general response to any exceptional condition in the
connection negotiation is to pause that connection (presumably a thread)
for a period of several seconds and then to close the network
connection. This includes syntax errors, over-sized data, or failed
attempts to authenticate. The broker implementation should log all such
exceptions and flag or block clients provoking multiple failures.

