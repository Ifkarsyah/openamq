gdl
    title     = Architecture
    subtitle  = OpenAMQ Content Broker Architecture
    product   = OpenAMQ Content Broker
    author    = Pieter Hintjens <ph@imatix.com>
    date      = 2006/08/11
    copyright = Copyright (c) 1996-2006 iMatix Corporation
    version   = 1.0
end gdl

Cover
*****

State of this Document
======================

This document is a design white paper.

Copyright and License
=====================

Copyright (c) 1996-2006 iMatix Corporation

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

For information on alternative licensing for OEMs, please contact
iMatix Corporation.

Abstract
========

This document describes the proposed architecture for the OpenAMQ content
broker version 2.0.

Goals and Objectives
********************

General Goals
=============

The goal of this architecture is to provide a clear set of objects and
relationships between them which can become the basis for a very large
product.

While the 1.0 broker design was largely developed in an ad-hoc manner,
we want the 2.0 broker design to be clearly specified and fully
discussed before we start to implement it.

Functional Compatability
========================

We want the major functionality of the 1.1 code to be reusable without
heavy changes.

Use of ASL Layer
================

Large parts of the architecture can be and will be handled by the code
produced by ASL. In gross terms, ASL provides the broad server, vhost,
and session framework, while the OpenAMQ content broker code provides
the AMQP-specific functionality.

General Architecture
********************

Object Relationship Diagram
===========================

    mb_broker
    :
    :-- mb_exchange_portal  # meta-portal
    :
    :-- mb_vhost
    :   :
    :   :-- mb_exchange_portal --> mb_exchange_sometype
    :   :
    :   `-- mb_session --> mb_gateway_sometype
    :
    :-- mb_gateway_portal   # meta-portal
    :
    :-- mb_gateway_portal --> mb_gateway_sometype
    :   :
    :   `-- mb_connection --> mb_broker
    :       :
    :       `-- mb_session --> mb_vhost
    :
    `-- mb_connection --> mb_gateway_sometype
        :
        `-- mb_session --> mb_gateway_sometype
    
Broker and Virtual Hosts
========================

The Broker Class
----------------

The broker class (mb_broker) defines a the central controlling object of
the messaging broker. There is only a single broker though in theory we
could construct multi-broker processes. The broker class holds all
global server-side objects, such as log files, config files, and virtual
hosts. The broker object is asynchronous, visible to the console. It is
owned by the main-line code.

The broker life-cycle is:

 - Main-line code creates broker object.
 - Main-line code executes SMT until finished.
 - Main-line code stops broker object.

The Virtual Host Class
----------------------

The virtual host class (mb_vhost) defines a virtual host. A virtual host
is a collection of server-side resources. Virtual host objects are async
objects, visible to the console, and children of the broker. Virtual
hosts are indexed in a hash table owned by the broker.

The vhost life-cycle is:

- Broker constructor creates vhost objects according to configuration
  data and indexes vhosts via hash table.
   
- Broker destructor stops vhost objects by stopping the hash table.

Exchange Management
===================

Problem Statement
-----------------

We want to allow the broker to link arbitrary exchange classes together.
The only code that should know the specific set of exchange classes is
the main line code.

General Solution
----------------

Rather than work with exchange classes directly, we create portals that
have implicit portal server objects (the exchange being the portal
server), and we then work with those portals, rather than exchanges. We
use meta-portals to abstract the exchange classes, and normal portals to
abstract the exchange instances.

Broker and Vhost
----------------

We have a single set of exchange classes per broker, and we have a
unique set of exchanges per vhost. Thus we hold the exchange
meta-portals in the broker object, and we hold the exchange portals in
the vhost object.

Registering Exchange Types
--------------------------

To register exchange types we create a set of meta-portals in the
main-line code, one for each exchange type. This is done using a broker
method. The meta-portals virtualise the exchange construction process.
The meta-portals are named and held on a looseref list in the broker
object.

Creating a New Exchange
-----------------------

To create a new exchange, we use the virtualised construction feature of
the exchange meta-portals. This means that we ask the meta-portal to
create a new exchange for us, without any requirement to know the
exchange's real class type.

The exchange meta-portals are owned by the broker, but the vhost can use
these portals, since it also acts as an exchange portal front-end. Thus
the logic to create a new exchange called X of type T is as follows:

 - An application object asks vhost to create an exchange X of type T.
 - The vhost asks the broker to lookup the meta-portal called "T".(*)
 - The vhost asks the meta-portal to create a new portal called "X" and
   implied exchange object.(*)
 - The vhost binds the new portal, so the portal is ready for use.(*)
 - The vhost indexes the exchange portal by name.(*)
 - The vhost informs the application that the exchange was created.

The steps marked (*) are done synchronously using threadsafe mechanisms
where needed.

Implementation Sketches
-----------------------

Registering an Exchange Type
............................

In the main-line code, we register exchanges as follows:

    mb_server_main.inc:
    ----------------------------------------------------------------------
    //  Register all exchange classes
    mb_exchange_fanout_register  (mb_broker);
    mb_exchange_direct_register  (mb_broker);
    mb_exchange_topic_register   (mb_broker);
    mb_exchange_headers_register (mb_broker);
    mb_exchange_return_register  (mb_broker);
    mb_exchange_system_register  (mb_broker);

The exchange portal class has a "name" property, set in the portal class
constructor:

    mb_exchange_portal.icl:
    ----------------------------------------------------------------------
    <context>
        icl_shortstr_t
            name;           //  Exchange name or type
        ipr_hast_t
            *hash;          //  Reference into vhost exchange hash
    </context>
    <method name = "new">
        <argument name = "name" type = "char *" />
        icl_shortstr_cpy (self->name, name);
    </method>

Each exchange class inherits from an exchange base class and specifies
its type name, e.g.:

    mb_exchange_direct.icl:
    ----------------------------------------------------------------------
    <inherit class = "mb_exchange_base">
        <option name = "type_name" value = "direct" />
    </inherit>

The exchange base class inherits from the exchange portal back-end glue
and implements the "register" method:

    mb_exchange_base.icl:
    ----------------------------------------------------------------------
    <inherit class = "mb_exchange_portal_back" />
    <method name = "register" async = "1" template = "async function">
        <argument name = "broker" type = "mb_broker_t *" />
        <local>
        exchange_portal_t
            *meta_portal;
        </local>
        meta_portal = self_mb_exchange_portal_meta ("$(type_name)");
        mb_broker_exchange_register (broker, meta_portal);
        mb_exchange_portal_unlink (&portal);
    </method>

The "exchange register" method in the broker class binds the meta-portal
to the broker, so that the meta-portal is correctly held as a child of
the broker object (and destroyed correctly at shut-down):

    mb_broker.icl:
    ----------------------------------------------------------------------
    <inherit class = "mb_exchange_portal_front" />
    <method name = "exchange register" async = "1" template = "async function">
        <argument name = "meta portal" type = "mb_exchange_portal_t *" />
        self_mb_exchange_portal_bind (self, meta_portal);
    </method>

Virtual Host Exchange Hash Table
................................

The virtual host holds a loose-referenced hash table of all exchange
portals it creates:

    mb_vhost.icl:
    ----------------------------------------------------------------------
    <context>
        ipr_hash_table_t
            *exchanges;
    </context>
    <method name = "new">
        self->exchanges = ipr_hash_table_new ();
    </method>
    <method name = "destroy">
        ipr_hash_table_destroy (self->exchanges);
    </method>

Declaring a New Exchange
........................

Exchanges are children of vhosts. To declare an exchange we call the
vhost "exchange declare" method, which creates a new exchange portal and
implicit exchange, like this:

    mb_vhost.icl:
    ----------------------------------------------------------------------
    <method name = "exchange declare" async = "1" template = "async function">
        <argument name = "name" type = "char *">Exchange name</argument>
        <argument name = "type" type = "char *">Exchange type</argument>
        <local>
        mb_exchange_portal_t
            *meta_portal,
            *portal;
        ipr_hash_t
            *hash;          //  Lookup exchange by name
        </local>
        //  Ignore multiple declares of same exchange
        hash = ipr_hash_table_search (self->exchanges, name);
        if (!hash) {
            //  Get exchange meta-portal
            meta_portal = mb_broker_exchange_type_lookup (self->broker, type);
            if (meta_portal) {
                portal = mb_exchange_portal_meta_new (meta_portal, name);
                self_mb_exchange_portal_bind (self, portal);
                //  Add portal to hash table
                portal->hash = ipr_hash_new (self->exchanges, name, portal);
                mb_exchange_portal_unlink (&portal);
                mb_exchange_portal_unlink (&meta_portal);
                //  Signal to session that exchange was created
            }
            else
                //  Signal to session that exchange type was invalid
        }
    </method>

The "exchange type lookup" method in the broker looks for and returns
the meta-portal for the exchange type, like this:

    mb_broker.icl:
    ----------------------------------------------------------------------
    <method name = "exchange type lookup" return = "portal">
        <argument name = "self" type = "$(selftype) *" />
        <argument name = "type" type = "char *">Exchange type</argument>
        <declare name = "portal" type = "mb_exchange_portal_t" />
        <local>
        ipr_looseref_t
            *looseref;           //  Meta-portal reference
        </local>
        //  This code assumes the portal list is not modified at runtime
        looseref = ipr_looseref_list_first (self->mb_exchange_portal_list);
        while (looseref) {
            portal = (mb_exchange_portal_t *) (looseref->object);
            if (streq (type, portal->name)) {
                portal = mb_exchange_portal_link (portal);
                break;                  //  Have a match
            }
            portal = NULL;              //  Reset matched portal
            looseref = ipr_looseref_list_next (&looseref);
        }
    </method>

Destroying an Exchange
......................

To destroy an exchange an application program calls the vhost "exchange
delete" method, which finds and destroys the exchange's portal, like
this:

    mb_vhost.icl:
    ----------------------------------------------------------------------
    <method name = "exchange delete" async = "1" template = "async function">
        <argument name = "name" type = "char *">Exchange name</argument>
        <local>
        mb_exchange_portal_t
            *portal;
        ipr_hash_t
            *hash;          //  Lookup exchange by name
        </local>
        //  Ignore if exchange does not exist
        hash = ipr_hash_table_search (self->exchanges, name);
        if (hash) {
            //  Get exchange meta-portal
            portal = (mb_exchange_portal_t *) hash->data;
            mb_exchange_portal_destroy (&portal);
            ipr_hash_destroy (&hash);
        }
    </method>

The Protocol Layer
==================

Problem Statement
-----------------

We want to solve three specific problems. First, to allow the server to
support arbitrary protocols in the same way as it can support arbitrary
exchange types. Second, to provide both protocol server and protocol
client functionality in a single layer. Finally, to allow multiple
instances of a protocol server (on different TCP/IP ports, typically) to
be active and addressable at once.

General Solution
----------------

The general solution uses a model that is very similar to the exchange
class model:

- We introduce the concept of "gateway", which abstracts a protocol. The
  gateway implementation is entirely hidden to the rest of the server.
  The server includes at least one gateway class, and can include as many
  as the implementor wants to provide, accessed by name.

- Rather than work with gateway classes directly, we access gateways
  through portals.

- We use meta-portals to abstract gateway types and portals to abstract
  gateway instances.

The entire protocol layer is implemented at the ASL level (not in the
AMQP server code).

The Gateway Class
-----------------

The gateway class encapsulates a specific protocol implementation. The
main-line code registers the various gateway classes that it wants to
support. Each of these registrations is instantiated as a meta-portal of
the mb_gateway_portal class. The gateway meta-portals are created by,
and belong to, the broker.

The gateway class works as follows:

 - A gateway class (mb_gateway_somename) implements a specific protocol.

 - Each gateway object acts as a protocol server for incoming connections
   and a managing object for outgoing connections.

 - Gateway objects belong to the broker: the broker creates one gateway
   for each protocol server it wants to start, which is usually a single
   gateway instance per class.

 - The gateway encapsulates all protocol agents. The AMQP gateway, for
   example, encapsulates the db_amqp_server_agent master thread, its
   client threads, and db_amqp_client_agent outgoing threads.

The internal architecture of each gateway is not relevant here but we
know that for an AMQP or HTTP gateway, for example, we have two SMT
agents, one for incoming connections from other servers or from
applications (the server agent) and one for outgoing connections to
other servers (the client agent).

The Connection Class
--------------------

The connection class (mb_connection) handles the interface between the
broker and a gateway instance. We implement the connection as a portal
object. The connection class works as follows:

 - Connections can go from broker to gateway, or from gateway to broker,
   depending on which side initiates the connection. In portal terms, both
   broker and gateway can act as clients and/or servers for the portal
   class.

 - An incoming connection (from an application) is created by the gateway
   and bound onto the broker.

 - An outgoing connection (from the broker to another broker) is created
   by the broker and bound onto the appropriate gateway. 

 - Connections are given temporary IDs (short strings) and are indexed by
   the broker on this key (using an ipr_hash table).

The Session Class
-----------------

The session class (mb_session) handles the interface between a virtual
host and a gateway. Sessions are children of connections, but are also
implemented as portals to or from vhosts, from or to gateways. This lets
us work with arbitrary gateway objects, without the need for a separate
portal object. The session class works as follows:

 - In portal terms, a session links either a vhost client to a gateway
   server, or a gateway client to a vhost sever. 

 - Sessions are created by their parent connection, which creates the
   session from vhost to gateway or from gateway to vhost, as wanted. 

 - When the connection is stopped, all its sessions are also destroyed.

Publishing Messages off an Exchange
======================

Problem Statement
-----------------

The goal is to let arbitrary application objects act as clients for
exchanges. Currently this is hardcoded as a "binding" relationship
between queues and exchanges. We want any object - not just a queue - to
be able to bind to an exchange to receive messages. The main challenge
is that we have a variant exchange class, and an undefined set of
message-accepting classes (which includes queues and cluster-mtas).

General Solution
----------------

We use a portal to connect application objects with exchanges. The
portal is called the "subscriber".

The Subscriber Class
-----------------------

The subscriber class (mb_subscriber) is a portal that connects an
arbitrary client object to an exchange as portal server. 

Subscribers work as follows:

 - The client object (usually a queue) creates a subscriber using the
   portal creation mechanism (it requests the exchange to create the
   portal class, then binds this portal to itself).

 - The client object configures the subscriber by sending a single 
   "configure" method to the exchange.

 - The exchange delivers messages as they arrive and match the
   subscription criteria. 

Subscriptions are generally handled by exchanges using 'bindings' but
this is an implementation detail and is not visible in the APIs.
Bindings are internal exchange concepts.

The subscriber portal defines these request methods:

 - configure - configures a new subscription using the specified
   arguments. The arguments are: a routing key, an arguments field table,
   and a routing option. 

The routing options are:

 - match - when the subscription matches
 - ccall - request a copy of all messages
 - default - request all messages that have no other matching subscribers)
 
The subscriber portal defines these response methods:

 - publish - delivers a message to the client object (e.g. the queue).

Subscriber Management
---------------------

AMQP does not implement a cancel method for bindings but this will
probably be added at some stage. Queues do not, in any case, need to
manage subscribers on a per-session (channel) basis.

For now, subscribers can be created and then ignored, at the queue side.
When the queue is destroyed its subscribers will be destroyed
automatically. The exchange must correctly handle the destruction of
subscribers to keep its routing tables updated.

We map a subscriber to an exchange binding so that bindiings can be
destroyed rapidly, without lookups.

Delivering Messages off a Queue
===============================

Problem Statement
-----------------

The goal is to abstract the relationship between queues and gateways
(the 'consumer' relationship), in such a way that we can add arbitrary
queue implementations to the server, and they can work correctly with
all gateway types.

General Solution
----------------

We use a portal class - the "consumer" - to link gateways with queues.
The consumer is 

The Subscriber Class
-----------------------


from queue to session
- consumer model
consume/cancel/deliver

1. gateway is client, queue is server, consumer is the portal
2. consumer can be created with arbitrary properties, used by queue
3. queue selects and uses consumer, sends it the deliver
4. consumer sends this to gateway, session is parent of consumer
5. consumer is child of session
 - gateway asks session to create consumerr object
 - session creates consumer onto queue
 
connection (gateway <--> broker)
   -- session (gateway <--> vhost)
      -- consumer (gateway <-- queue)

- for messages from application; we deliver to vhost via session
  - gateway has session to vhost, sends message to session
  - vhost processes, using session for responses
- for messages from queue to session, can we deliver via consumer
 



Purpose: defines the relationship between a queue instance and the objects that consume messages off a queue.

Server: a queue instance (mb_queue_t).

Client: a session (mb_session_t).

Methods:

 - C:consume, C:cancel, C:get, C:ack
 - S:deliver







###############################################################################

session to vhost

 - C:consume, C:cancel, C:get, C:ack
 - S:deliver

Confidence: 90%.

The GATEWAY Portal
------------------

Purpose: defines the relationship between

Server: a queue instance.

Client: a session.

Methods:

 - C:consume, C:cancel, C:get, C:ack
 - S:deliver

Confidence: 90%.

The ROUTING Portal
------------------

Purpose: defines the relationship between

Server: a queue instance.

Client: a session.

Methods:

 - C:consume, C:cancel, C:get, C:ack
 - S:deliver

Confidence: 90%.

