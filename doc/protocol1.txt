Overview
********

Goals of This Document
======================

This document aims to define a new general-purpose standard for
application level (OSI level 7) middleware. Our standard - AMQ - aims to
create full functional interoperability between conforming clients and
servers (also called "brokers"). We address a technical audience with
some experience in the domain, and we aim to provide sufficient
specifications and guidelines that a suitably skilled engineer can
construct conforming components in any modern programming language.

Copyrights
==========

This document is copyright (c) 2004-2005 JPMorganChase and iMatix
Corporation. The contents of this document are at present confidential
and may not be copied outside of JPMorganChase or iMatix Corporation
without express permission.

Summary
=======

What is AMQ?
------------

Our goal is to spark the development and industry-wide use of a new open
source, standardised middleware technology that will lower the cost of
enterprise and systems integration to an absolute minimum.

We propose two main inventions:

 1. A modular framework (called "Advanced Message Queues", or AMQ) for
    defining the semantics of a middleware server.  The AMQ framework
    consists of a set of components that route and store messages within
    a central server, plus a set of rules for wiring these components
    together.

 2. A wire-level protocol (AMQP/Fast) that lets applications talk to an
    AMQ server. AMQP/Fast is a TCP/IP implementation of a generic family
    of protocols - AMQP.  Other AMQP protocols are being studied.

One can derive the semantics of the AMQ server from the AMQP/Fast
protocol specifications but we believe that an explicit description of
these semantics help the understanding of the protocol.

The AMQ Framework
-----------------

We define the server's semantics explicitly, since interoperability
demands that these be the same in any given server implementation.

The AMQ framework thus specifies an modular set of components and
standard rules for connecting these. AMQ defines three main types of
component, which are connected into processing chains in the server to
create the desired middleware functionality:

 - The "exchange" receives messages from publisher applications and
   routes these to "queues", based on arbitrary criteria, usually message
   properties or content.

 - The "queue" stores messages until they can be safely processed by a
   consumer application (or multiple applications).

 - The "binding" defines the relationship between a queue and an exchange
   and provides the message routing criteria.

We can emulate the classic middleware concepts of store-and-forward
queues and topic subscriptions trivially. We can also expresses less
trivial concepts such as content-based routing, queue forking, and
on-demand queues.

In very gross terms, an AMQ server is analogous to an email server, with
each exchange acting as a message transfer agent, and each queue as a
mailbox. The bindings define the routing tables in each transfer agent.
Publishers send messages to individual transfer agents, which then route
the messages into mailboxes. Consumers take messages from mailboxes.

In a pre-AMQ middleware system, by contrast, publishers send messages
directly to individual mailboxes (in the case of store-and-forward
queues), or to mailing lists (in the case of topic subscriptions).

The difference is that when the rules connecting queues to exchanges
are under control of the architect (rather than embedded in code), it
becomes possible to do interesting things, such as define a rule that
says, "place a copy of all messages containing such-and-such a header
into this queue".

The AMQP/Fast Wire-level Protocol
---------------------------------

The AMQP/Fast protocol is a binary protocol with modern features: it is
multi-channel, negotiated, asynchronous, secure, portable, neutral, and
fast.

AMQP/Fast is usefully split into as two layers:

    +------------------Functional Layer----------------+
    |                                                  |
    |     JMS  File transfer  Transactions  Queues     |
    |                                                  |
    |        Exchanges  Access control  Streaming      |
    |                                                  |
    +--------------------------------------------------+

    +------------------Transport Layer-----------------+
    |                                                  |
    | Framing  Content  Heartbeat  Data representation |
    |                                                  |
    |   Error handling  Connection failover  Channels  |
    |                                                  |
    +--------------------------------------------------+

The functional layer defines a set of classes and methods (the
"AMQP protocol classes") that do useful work on behalf of the
application.

The transport layer that carries these methods from application to
server, and back, and which handles channel multiplexing, framing,
content encoding, heartbeating, data representation, and error handling.

One could replace the transport layer with arbitrary transports without
changing the application-visible functionality of the protocol. One
could also use the same transport layer for different high-level
protocols.

The design of AMQP functional layer was driven by these main
requirements:

 - To be clear, where each method does exactly one thing.
 - To be easily extended to handle new and changed needs.
 - To be consistent and explicit in naming.
 - To use a class/method/argument notation that maps easily into
   application-level APIs.
 - To allow complete configuration of server wiring via the protocol.
 - To guarantee interoperability between conforming implementations.
 - To provide explicit control over the quality of service.
 - To be compatible with existing API standards, mainly JMS.
 - To support any middleware domain: JMS, file transfer, etc.

The design of AMQP/Fast transport layer was driven by these main
requirements, in no particular order:

 - To be compact, using a binary encoding that packs and unpacks rapidly.
 - To handle messages of any size without significant limit.
 - To allow zero-copy data transfer (e.g. remote DMA).
 - To carry multiple channels across a single connection.
 - To be long-lived, with no significant in-built limitations.
 - To allow asynchronous command pipelining.
 - To be forward compatable with future versions.
 - To be repairable, using a strong assertion model.
 - To be neutral with respect to programming languages.
 - To have no license or patent restrictions.
 - To fit a code generation process.

Design Methodology
------------------

Our design methodology is to work with highly skilled engineers who have
decades of middleware experience, to take the best of the art, build
software prototypes, and then refactor our designs into generic components
and abstracted idioms. The current versions of AMQ and AMQP/Fast
are based on several full cycles.  The current reference implementations
are the third generation, built from scratch.

Since the ultimate goal is to make software designs that work perfectly,
we make heavy use of automation in our processes.  We rely on generable
abstract models - grammars and state machines - in the production of the
reference implementations. Change is cheap, and we can tune and refactor
our idioms rapidly.

Scales of Deployment
--------------------

The scope of AMQ covers different levels of scale:

1. Developer/casual use: 1 server, 1 user, 10 queues, 1 message per
   second.

2. Production application: 2 servers, 10-100 users, 10-50 queues, 10
   messages per second (36K messages/hour).

3. Departmental mission critical application: 4 servers, 100-500 users,
   50-100 queues, 100 messages per second (360K/hour).

4. Regional mission critical application: 16 servers, 500-2,000 users,
   100-500 queues and topics, 1000 messages per second (3.6M/hour).

5. Global mission critical application: 64 servers, 2K-10K users,
   500-1000 queues and topics, 10,000 messages per second (36M/hour).

6. Market data (trading): 200 servers, 5K users, 10K topics, 100K
   messages per second (360M/hour).

As well as volume, the latency of message transfer can be highly
important. For instance, market data becomes worthless very rapidly.

Licensing
---------

The AMQ and AMQP/Fast specifications, and all related materials
including tools, code generators, formal specifications, and reference
implementations are or will be provided under a BSD-style open source
license.

Organisation of This Document
=============================

The document is divided into six chapters, most of which are designed
to be read independently according to your level of interest:

 1. "Overview" (this chapter).  Read this chapter for an introduction
    to AMQ and AMQP/Fast.

 2. "General Architecture", in which we describe the architecture and
    overall design of AMQ and AMQP/Fast.  This chapter is intended to
    help systems architects understand how AMQ works.

 3. "Functional Specifications", in which we define how applications
    work with AMQ, according to the AMQP classes and methods.  This
    chapter consists of a readable discussion, followed by a detailed
    specification of each class and method, intended as a reference
    for implementors.  Before reading this chapter you should read
    the General Architecture.

 4. "Technical Specifications", in which we define how the AMQP/Fast
    transport later works.  This chapter consists of a short discussion,
    followed by a detailed specification of the wire-level constructs,
    intended as a reference for implementors. You can read this chapter
    by itself if you want to understand how the wire-level protocol works
    (but not what it is used for).

 5. "Conformance Tests", in which we explain the conformance test
    framework, which asserts that an AMQ server conforms to the functional
    and technical specifications defined in this document. This chapter
    consists of a short explanation of how the conformance tests are
    designed, followed by a detailed specification of each conformance
    test, intended as a reference for implementors. You can read this
    chapter by itself.

 6. "Scope and Requirements", in which we state and analyse the scope
    and requirements of the AMQ standard.  This chapter comes last because
    it is a somewhat tedious but necessary argumentation. If you want to
    know why we built AMQ as we did, this chapter may enlighten.  Note
    that chapters 3, 4, and 5 include a statement of key requirements,
    but without argumentation.

Conventions
===========

Guidelines for Implementors
---------------------------

- We use the terms MUST, MUST NOT, SHOULD, SHOULD NOT, and MAY as
  defined by IETF RFC 2119.

- We use the term "the server" when discussing the specific behaviour
  required of a conforming AMQ server.

- We use the term "the client" when discussing the specific behaviour
  required of a conforming AMQ client.

- We use the term "the peer" to mean "the server or the client".

- All numeric values are decimal unless otherwise indicated.

- Protocol constants are shown as uppercase names. AMQP/Fast
  implementations SHOULD use these names when defining and using
  constants in source code and documentation.

- Property names, method arguments, and frame fields are shown as
  lowercase names. AMQP/Fast implementations SHOULD use these names
  consistently in source code and documentation.

Technical Terminology
---------------------

These terms have significance within the context of this document:

Connection:
    A network connection, e.g. a TCP/IP socket connection.
Channel:
    A bi-directional stream of communications between two AMQP/Fast
    peers. Channels are multiplexed so that a single network connection
    can carry multiple channels.
Client:
    The initiator of an AMQP/Fast connection or channel.  AMQP/Fast is
    not symmetrical.  Clients produce and consume messages while servers
    queues and route messages.
Server:
    The process that accepts client connections and implements the AMQ
    queueing and routing functions. Also known as "broker".
Peer:
    Either party in an AMQP/Fast connection.  An AMQP/Fast connection
    involves exactly two peers (one is the client, one is the server).
Frame:
    A formally-defined package of connection data.  Frames are
    always written and read contiguously - as a single unit - on the
    connection.
Protocol_Class:
    A collection of methods that deal with a specific type of
    functionality.
Method:
    A specific type of frame that passes instructions from one peer
    to the other.
Content:
    Application data passed from client to server and from server to
    client.  AMQP/Fast content can be structured into multiple parts.
    The term is synonymous with "message".
Content_Header:
    A specific type of frame that describes a content's properties.
Content_Body:
    A specific type of frame that contains raw application data.
    Content body frames are entirely opaque - the server does not
    examine or modify these in any way.
Message:
    Synonymous with "content".
Exchange:
    The entity within the server which receives messages from producer
    applications and optionally routes these to queues within the
    server.
Exchange_Type:
    The algorithm and implementation of a particular model of exchange.
    In contrast to the "exchange instance", which is the entity that
    receives and routes messages within the server.
Server_queue:
    A named entity that holds messages and forwards them to consumer
    applications.
Binding:
    An entity that creates a relationship between a queue and an
    exchange.
Durable:
    A server resource that survives a server restart.
Transient:
    A server resource that is wiped or reset after a server restart.
Persistent:
    A message that the server holds on reliable disk storage and
    should not lose after a server restart.
Non-persistent:
    A message that the server holds in memory and may lose after a
    server restart.
Consumer:
    A client application that requests messages from a queue.
Producer:
    A client application that publishes messages to an exchange.
Virtual_host:
    A collection of exchanges, queues and associated objects. Virtual
    hosts are independent server domains that share a common
    authentication and encryption environment.  The client application
    choses a virtual host after logging in to the server.
Realm:
    A set of server resources (exchanges and queues) covered by a single
    security policy and access control.  Applications ask for access
    rights for specific realms, rather than for specific resources.
Ticket:
    A token that a server provides to a client, for access to a specific
    realm.
Streaming:
    The process by which the server will send messages to the client at
    a pre-arranged rate.
Staging:
    The process by which a peer will transfer a large message to a
    temporary holding area before formally handing it over to the
    recipient.  This is how AMQP/Fast implements restartable file
    transfers.
Out-of-band_transport:
    The technique by which data is carried outside the network
    connection.  For example, two peers can carry frames across a
    TCP/IP connection and then switch to using shared memory if they
    discover they are on the same system.
Zero_copy:
    The technique of transferring data without copying it to or from
    intermediate buffers.  Zero copy requires that the protocol allow
    the transfer of data as opaque blocks, which AMQP/Fast does.
Assertion:
    A condition that must be true for processing to continue.
Exception:
    A failed assertion, handled by closing either the channel or the
    connection.

These terms have no special significance within the context of AMQ:

Topic:
    Usually a means of distributing messages; AMQ implements topics
    using one or more types of exchange.
Subscription:
    Usually a request to receive data from topics; AMQ implements
    subscriptions as queues.

Authors
=======

AMQP was designed by Pieter Hintjens with help from John O'Hara, Mark
Atwell, and others. This document was written by Pieter Hintjens.


