Overview
********

Goals of This Document
======================

This document defines a new general-purpose standard for application
level (OSI level 7) middleware. Our standard, AMQ, creates full
functional interoperability between conforming clients and servers (also
called "brokers"). We address a technical audience with some experience
in the domain, and we provide sufficient specifications and guidelines
that a suitably skilled engineer can construct conforming components in
any modern programming language.

Copyrights
==========

This document was written by the AMQ Working Group (amqp.org) and is
copyright (c) 2004-2005 JPMorganChase Inc. The contents of this document
are at present confidential and may not be copied outside of
JPMorganChase Inc. without express permission.

Summary
=======

What is AMQ?
------------

Our goal is to spark the development and industry-wide use of a new open
source, standardised middleware technology that will lower the cost of
enterprise and systems integration.

We propose two main standards:

 1. A logical framework (called "Advanced Message Queues", or AMQ) for
    defining the semantics of a middleware server.  The AMQ framework
    consists of a set of components that route and store messages within
    a central server, plus a set of rules for wiring these components
    together.

 2. A physical wire-level protocol (AMQP) that lets applications talk
    to an AMQ server.

One can derive the semantics of the AMQ server from the AMQP protocol
specifications but we believe that an explicit description of these
semantics help the understanding of the protocol.

The AMQ Logical Framework
-------------------------

We define the server's semantics explicitly, since interoperability
demands that these be the same in any given server implementation.

The AMQ framework thus specifies an modular set of components and
standard rules for connecting these. AMQ defines three main types of
component, which are connected into processing chains in the server to
create the desired middleware functionality:

 - The "exchange" receives messages from publisher applications and
   routes these to "message queues", based on arbitrary criteria,
   usually message properties or content.

 - The "message queue" stores messages until they can be safely processed
   by a consumer application (or multiple applications).

 - The "binding" defines the relationship between a message queue and an
   exchange and provides the message routing criteria.

We can emulate the classic middleware concepts of store-and-forward
queues and topic subscriptions trivially. We can also expresses less
trivial concepts such as content-based routing, message queue forking,
and on-demand message queues.

In very gross terms, an AMQ server is analogous to an email server, with
each exchange acting as a message transfer agent, and each message queue
as a mailbox. The bindings define the routing tables in each transfer
agent. Publishers send messages to individual transfer agents, which
then route the messages into mailboxes. Consumers take messages from
mailboxes.

In a pre-AMQ middleware system, by contrast, publishers send messages
directly to individual mailboxes (in the case of store-and-forward
queues), or to mailing lists (in the case of topic subscriptions).

The difference is that when the rules connecting message queues to
exchanges are under control of the architect (rather than embedded in
code), it becomes possible to do interesting things, such as define a
rule that says, "place a copy of all messages containing such-and-such a
header into this message queue".

The design of AMQ framework was driven by these main requirements:

 - To support the semantics of the market-leading commercial middleware
   products.

 - To be easily extended for new kinds of message routing and queueing.

 - To permit the server's specific semantics to be programmed by the
   application, via the protocol.

The AMQP Wire-level Protocol
----------------------------

The AMQP protocol is a binary protocol with modern features: it is
multi-channel, negotiated, asynchronous, secure, portable, neutral, and
efficient.

AMQP is usefully split into as two layers:

    +------------------Functional Layer----------------+
    |                                                  |
    |  Basic  File transfer  Transactions  Exchanges   |
    |                                                  |
    |    Message queues   Access control  Streaming    |
    |                                                  |
    +--------------------------------------------------+

    +------------------Transport Layer-----------------+
    |                                                  |
    |      Framing  Content  Data representation       |
    |                                                  |
    |      Error handling  Heatbeating   Channels      |
    |                                                  |
    +--------------------------------------------------+

The functional layer defines a set of classes and methods (the "AMQP
protocol classes") that do useful work on behalf of the application.

The transport layer that carries these methods from application to
server, and back, and which handles channel multiplexing, framing,
content encoding, heartbeating, data representation, and error handling.

One could replace the transport layer with arbitrary transports without
changing the application-visible functionality of the protocol. One
could also use the same transport layer for different high-level
protocols.

The design of AMQP functional layer was driven by these main
requirements:

 - To guarantee interoperability between conforming implementations.
 - To provide explicit control over the quality of service.
 - To support any middleware domain: messaging, file transfer,
   streaming, etc.
 - To be compatible with existing messaging API standards (Sun JMS).
 - To be consistent and explicit in naming.
 - To allow complete configuration of server wiring via the protocol.
 - To use a class/method/argument notation that maps easily into
   application-level APIs.
 - To be clear, so each method does exactly one thing.

The design of AMQP transport layer was driven by these main
requirements, in no particular order:

 - To be compact, using a binary encoding that packs and unpacks rapidly.
 - To handle messages of any size without significant limit.
 - To allow zero-copy data transfer (e.g. remote DMA).
 - To carry multiple channels across a single connection.
 - To be long-lived, with no significant in-built limitations.
 - To allow asynchronous command pipelining.
 - To be easily extended to handle new and changed needs.
 - To be forward compatable with future versions.
 - To be repairable, using a strong assertion model.
 - To be neutral with respect to programming languages.
 - To have no license or patent restrictions.
 - To fit a code generation process.

Scales of Deployment
--------------------

The scope of AMQ covers different levels of scale:

1. Developer/casual use: 1 server, 1 user, 10 message queues, 1 message
   per second.

2. Production application: 2 servers, 10-100 users, 10-50 message
   queues, 10 messages per second (36K messages/hour).

3. Departmental mission critical application: 4 servers, 100-500 users,
   50-100 message queues, 100 messages per second (360K/hour).

4. Regional mission critical application: 16 servers, 500-2,000 users,
   100-500 message queues and topics, 1000 messages per second
   (3.6M/hour).

5. Global mission critical application: 64 servers, 2K-10K users,
   500-1000 message queues and topics, 10,000 messages per second
   (36M/hour).

6. Market data (trading): 200 servers, 5K users, 10K topics, 100K
   messages per second (360M/hour).

As well as volume, the latency of message transfer can be highly
important. For instance, market data becomes worthless very rapidly.

Functional Scope
----------------

We want to support a variety of messaging architectures:

 - Store-and-forward with many writers and one reader.

 - Transaction distribution with many writers and many readers.

 - Publish-subscribe with many writers and many readers.

 - Content-based routing with many writers and many readers.

 - Queued file transfer with many writers and many readers.

 - Point-to-point connection between two peers.

 - Market data distribution with many sources and many readers.

Licensing
---------

These specifications are or will be provided under a BSD-style open
source license.

Patents
-------

AMQ and AMQP are based on concepts taken from existing unencumbered
standards, and all aspects of AMQ are obvious to anyone skilled in
the art.

Organisation of This Document
=============================

The document is divided into six chapters, most of which are designed
to be read independently according to your level of interest:

 1. "Overview" (this chapter). Read this chapter for an introduction.

 2. "General Architecture", in which we describe the architecture and
    overall design of AMQ and AMQP. This chapter is intended to help
    systems architects understand how AMQ works.

 3. "Functional Specifications", in which we define how applications
    work with AMQ, according to the AMQP classes and methods.  This
    chapter consists of a readable discussion, followed by a detailed
    specification of each class and method, intended as a reference
    for implementors.  Before reading this chapter you should read
    the General Architecture.

 4. "Technical Specifications", in which we define how the AMQP
    transport later works.  This chapter consists of a short discussion,
    followed by a detailed specification of the wire-level constructs,
    intended as a reference for implementors. You can read this chapter
    by itself if you want to understand how the wire-level protocol
    works (but not what it is used for).

 5. "Conformance Tests", in which we explain the conformance tests,
    which assert that an AMQ server conforms to the functional and
    technical specifications defined in this document. This chapter
    consists of a short explanation of how the conformance tests are
    designed, followed by a detailed specification of each conformance
    test, intended as a reference for implementors. You can read this
    chapter by itself.

 6. "Analysis", in which we state and analyse the scope and requirements
    of the AMQ standard. This chapter comes last because it is not part
    of the knowledge needed to write an AMQ implementation, but it does
    provide useful background understanding. Note that the specification
    chapters include statements of key requirements, without analysis.

Conventions
===========

Guidelines for Implementors
---------------------------

- We use the terms MUST, MUST NOT, SHOULD, SHOULD NOT, and MAY as
  defined by IETF RFC 2119.

- We use the term "the server" when discussing the specific behaviour
  required of a conforming AMQ server.

- We use the term "the client" when discussing the specific behaviour
  required of a conforming AMQ client.

- We use the term "the peer" to mean "the server or the client".

- All numeric values are decimal unless otherwise indicated.

- Protocol constants are shown as uppercase names. AMQP implementations
  SHOULD use these names when defining and using constants in source
  code and documentation.

- Property names, method arguments, and frame fields are shown as
  lowercase names. AMQP implementations SHOULD use these names
  consistently in source code and documentation.

Technical Terminology
---------------------

These terms have significance within the context of this document:

Connection:
    A network connection, e.g. a TCP/IP socket connection.
Channel:
    A bi-directional stream of communications between two AMQP peers.
    Channels are multiplexed so that a single network connection can
    carry multiple channels.
Client:
    The initiator of an AMQP connection or channel.  AMQP is not
    symmetrical.  Clients produce and consume messages while servers
    queue and route messages.
Server:
    The process that accepts client connections and implements the AMQ
    message queueing and routing functions. Also known as "broker".
Peer:
    Either party in an AMQP connection.  An AMQP connection involves
    exactly two peers (one is the client, one is the server).
Frame:
    A formally-defined package of connection data.  Frames are
    always written and read contiguously - as a single unit - on the
    connection.
Protocol Class:
    A collection of methods that deal with a specific type of
    functionality.
Method:
    A specific type of frame that passes instructions from one peer
    to the other.
Content:
    Application data passed from client to server and from server to
    client.  AMQP content can be structured into multiple parts. The
    term is synonymous with "message".
Content Header:
    A specific type of frame that describes a content's properties.
Content Body:
    A specific type of frame that contains raw application data.
    Content body frames are entirely opaque - the server does not
    examine or modify these in any way.
Message:
    Synonymous with "content".
Exchange:
    The entity within the server which receives messages from producer
    applications and optionally routes these to message queues within
    the server.
Exchange Type:
    The algorithm and implementation of a particular model of exchange.
    In contrast to the "exchange instance", which is the entity that
    receives and routes messages within the server.
Message queue:
    A named entity that holds messages and forwards them to consumer
    applications.
Binding:
    An entity that creates a relationship between a message queue and an
    exchange.
Routing key:
    A virtual address that an exchange may use to decide how to route a
    specific message. 
Durable:
    A server resource that survives a server restart.
Transient:
    A server resource that is wiped or reset after a server restart.
Persistent:
    A message that the server holds on reliable disk storage and
    MUST NOT lose after a server restart.
Non-persistent:
    A message that the server holds in memory and MAY lose after a
    server restart.
Consumer:
    A client application that requests messages from a message queue.
Producer:
    A client application that publishes messages to an exchange.
Virtual host:
    A collection of exchanges, message queues and associated objects.
    Virtual hosts are independent server domains that share a common
    authentication and encryption environment.  The client application
    choses a virtual host after logging in to the server.
Realm:
    A set of server resources (exchanges and message queues) covered by
    a single security policy and access control.  Applications ask for
    access rights for specific realms, rather than for specific resources.
Ticket:
    A token that a server provides to a client, for access to a specific
    realm.
Streaming:
    The process by which the server will send messages to the client at
    a pre-arranged rate.
Staging:
    The process by which a peer will transfer a large message to a
    temporary holding area before formally handing it over to the
    recipient. This is how AMQP implements restartable file transfers.
Out-of-band transport:
    The technique by which data is carried outside the network
    connection. For example, one might send data across TCP/IP and then
    switch to using shared memory if one is talking to a peer on the
    same system.
Zero copy:
    The technique of transferring data without copying it to or from
    intermediate buffers. Zero copy requires that the protocol allows
    the out-of-band transfer of data as opaque blocks, as AMQP does.
Assertion:
    A condition that must be true for processing to continue.
Exception:
    A failed assertion, handled by closing either the channel or the
    connection.

These terms have no special significance within the context of AMQ:

Topic:
    Usually a means of distributing messages; AMQ implements topics
    using one or more types of exchange.
Subscription:
    Usually a request to receive data from topics; AMQ implements
    subscriptions as message queues and bindings.
Service:
    Usually synonymous with server. The AMQ standard uses "server"
    to conform with IETF standard nomenclature and to clarify the
    roles of each party in the protocol (both sides may be AMQP
    services).
Router:
    Sometimes used to describe the actions of an exchange. To some
    extent the whole AMQP server can be considered a message router
    but this term is misleading to network administrators and we do
    not use it.


