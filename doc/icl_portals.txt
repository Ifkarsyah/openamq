iCL Portals
***********

Summary
=======

This whitepaper documents the iCL Portal concept, which is a two-directional
interface between a pair of objects.  We designed portals as a layer on top
of the iCL Interface layer.

General Description
===================

Portals are


Terminology
-----------

In this document the following terms have special meaning:

 - CLIENT - an application object that uses portals to talk to servers.

 - SERVER - an application object that acts as host for portals.

"Client" and "server" do not carry their traditional network meanings here.

What is a Portal?
-----------------

A portal is a bi-directional interface object that joins two objects
called a "client" and a "server".  The portal takes care of the relationship
between the two objects and provides virtualised methods in both directions so 
that the client can send requests and the server can send responses, in a fully
asynchronous manner.

Portals have these features and properties:

 - A portal can work with either sync or async classes for client and/or
   server.

 - A portal is always private to a single client and connects that client
   to a single server object or class (in the case of class factories).

 - A portal can have properties, methods, and constructor arguments like a
   normal object.

 - A portal can import classes, which are then accessible to the client and
   server classes.

 - Portals can be used to create plug-in architectures where the set of
   server classes is not known in advance to the application.

 - Portals manage N-to-N relationships between objects automatically.

 - Portals are efficient, adding only two C function calls to method
   invocations.

 - Portals can be 'class factories' that allow applications to virtualise 
   the server objects together with portals to access them, for plugin 
   architectures.

 - A portal is always owned by a single client object but can be used by
   other client objects.

Why Invent Portals?
-------------------

Most of the most complex issues we face in large applications are related
to either connecting sets of objects in useful ways, especially with one or
more levels of virtualisation, or in ensuring that the references between
connected objects can be dropped in safe ways.  Both of these issues are the
causes of major pain:

1. We invent ad-hoc virtualisation layers, each adding to the complexity
   of the resulting code.

2. We invent ad-hoc shutdown frameworks, which need delicate hand-coding
   to avoid the two rocks of (a) accessing a destroyed object by mistake
   or (b) ommitting a destroy call, so objects 'leak'.

Note that iCL has good mechanisms for detecting such issues but no tools to
help us write the code more easily.

Portals are thus a generic solution that solve the virtualisation and the
reference-management issues in a high-level manner.  The cost of portals vs.
hand-made code is about 0.0001% additional overhead.

Implementation
--------------

- Servers, clients, and portals are all implemented as iCL classes.  The
  client and server can either be synchronous iCL classes, or async classes
  built using iCL/SMT.

- Each portal is specified a class with meta-data that defines the request
  and response method formats.

- The client and server each inherit glue for the portal, called the front
  end and back-end respectively.  A single client or server can use multiple
  portal classes and portal objects.

- The client opens a new portal as follows: it asks the server to create a
  portal, and then it invokes the portal _bind() method to complete the
  handshake.

- Client or server can send methods to the bound portal, which are received
  in method handlers at the receiving end.

- Client or server can close the portal by invoking the portal _destroy()
  method (to be renamed to _stop() at some stage).

Easy Steps for Using a Portal
-----------------------------

1. Define your portal, as an iCL class. Use ipr_demo_portal.icl as a
   starting point.

2. In your client and server classes, inherit from the front-end and
   back-end portal classes respectively: see ipr_demo_portal_client
   and ipr_demo_portal_server for examples.

4. In your client and server classes, define methods that correspond
   to the portal requests (in the server) and responses (in the client)
   and add your own code.

3. Use the portal as follows:

    //  Ask server to create new portal instance
    portal = ipr_demo_portal_server_ipr_demo_portal_new (server);
    //  Open portal from client side
    ipr_demo_portal_open (client, portal);
    //  Send portal requests
    ipr_demo_portal_request_print (portal, "test step 1");
    //  Close the portal
    ipr_demo_portal_destroy (&portal);

Portal API
----------

Server class methods:

 * server = myserver_new () - takes no arguments; creates a new server
   object.

 * myserver_destroy (&server) - takes a server reference address; stops
   the server object.

Portal methods in the server class:

 * portal = myserver_myportal_new (server, arguments) - creates a new portal
   and if the server argument is null, also creates an implicit server
   object. The arguments are passed to the portal constructor.

 * factory = myserver_myportal_factory (arguments) - creates a portal factory
   The arguments are passed to the portal constructor, since portal factories
   have the same properties as portals.

Portal class methods:

 * portal = myportal_factory (factory, arguments) - asks the factory to create
   a new portal.

Portal methods in the client class:

 * myclient_myportal_bind (client, portal) - binds portal to client so that
   it can be used.

Implicit Server Objects
-----------------------

The conventional way of creating a portal and a server is to:

 1. Explicitly create the server object at some point.
 2. Create one or more portal that talk to the server.

Here is an example of this 'explicit server object' approach:

    ipr_demo_portal_t
        *portal;
    ipr_demo_portal_server_t
        *server;
    //
    server = ipr_demo_portal_server_new ();
    portal = ipr_demo_portal_server_ipr_demo_portal_new (server, "data");
    ipr_demo_portal_client_ipr_demo_portal_bind (self, portal);
    ipr_demo_portal_request_print (portal, "Test explicit server");
    ipr_demo_portal_destroy (&portal);
    ipr_demo_portal_server_unlink (&server);

Portals also support 'implicit server objects', in which we create a portal
and automatically create a server object.  Implicit server objects are not
accessible except via their portal, and when the portal is destroyed, the
implicit server object is also destroyed.

Here is an example of the 'implicit server object' approach:

    ipr_demo_portal_t
        *portal;
    //
    portal = ipr_demo_portal_server_ipr_demo_portal_new (NULL, "data");
    ipr_demo_portal_client_ipr_demo_portal_bind (self, portal);
    ipr_demo_portal_request_print (portal, "Test implicit server");
    ipr_demo_portal_destroy (&portal);

In most cases we recommend the implicit server approach, as it is simpler
to use and requires one object less to manage in the client.

Portal Factories
----------------

Portal factories let us virtualise the construction of new portals and servers.
This solves problems where we create servers from a range of classes, but we do
not want to hard-code the possible classes into the application.

Portal factories work with implicit server objects.  That is, a factory will
create, on demand, a new portal + implicit server pair, and return the portal.

The expected application scenario is that we create a set of factories at
startup, where each factory abstracts portal+server construction for one
class.  We then allow the application to lookup the factories through some
index (a name, for example) and call the factory to create a new portal
and implicit server.

This removes all server class-specific code from the application after the
point of creation of the factories.  We usually create the factories in
some customisable layer which is then the only code that we must modify in
order to add or remove portal server classes.

Here is an example of using a factory:

    ipr_demo_portal_t
        *factory,
        *portal;
    //
    //  Use a factory to create a new server portal
    //  First, create a factory
    factory = ipr_demo_portal_server_ipr_demo_portal_factory ("C");
    ipr_demo_portal_client_ipr_demo_portal_bind (self, factory);
    //  Next, invoke the factory method to get a new server and portal
    portal = ipr_demo_portal_factory (factory, "D");
    ipr_demo_portal_client_ipr_demo_portal_bind (self, portal);
    //  Use the server portal
    ipr_demo_portal_request_print (portal, "test step 3");
    //  Shut-down the portals
    ipr_demo_portal_destroy (&portal);
    ipr_demo_portal_destroy (&factory);

Server Constructor
------------------

The server constructor takes NO arguments.  If you want to provide initial
values to a server, send it a portal method after you create it.

Tips
----

 - You can use many portals in a client or server, each portal defines
   a bidirectional set of request and response methods.

 - If you use the same method name in two portals, you cannot use those
   two portals at the same time.

 - To send a method back on the same portal, use the 'portal' variable
   which is instantiated in each request and response method handler.

 - The server or client object is always available in a request or
   response method handler using the 'self' variable.

 - If either the client or server is an async objects, you must define
   an option in the portal class accordingly:

        <inherit class = "ipr_portal">
            <option name = "front_end" value = "async" />
            <option name = "back_end" value = "async" />
        </inherit>

Files
-----

In ipr:

 * ipr_portal.icl - portal base class.
 * ipr_portal.gsl - portal code generator main.
 * ipr_portal_sync.gsl - portal code generator for sync glue.
 * ipr_demo_portal.icl - demo portal.
 * ipr_demo_portal_client.icl - demo portal client.
 * ipr_demo_portal_server.icl - demo portal server.

In smt:

 * ipr_portal_async.gsl - portal code generator for async glue.
 * smt_demo_portal.icl - demo portal.
 * smt_demo_portal_client.icl - demo portal client.
 * smt_demo_portal_server.icl - demo portal server.

