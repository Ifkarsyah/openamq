gdl
    title     = AMQ Functional Specifications
    subtitle  = Building a General Purpose Middleware System
    product   = OpenAMQ
    author    = iMatix Corporation <amq@imatix.com>
    date      = 2005/10/26
    copyright = Copyright (c) 2004-2005 JPMorgan
    version   = 0.1a0
end gdl

Overview
********

This document states the functional requirements that drove the AMQ
project.  It is intended as a general introduction to the question
of "what is AMQ", and "why did JPMC build AMQ?"

Defining the Problem
*********************

Overview
========

To understand what AMQ is, and why we built it, we must look at the
kinds of problems that we wanted to solve.

Overall, messaging middleware is a critical layer in any system that
runs over more than a single server.  Even the simplest distributed
applications need reliable and fast message exchange between servers.

Traditionally there are three ways of doing this:

1. Write an ad-hoc messaging layer using TCP/IP, FTP, HTTP, SOAP, or
   one of the many other existing communication standards.

2. Use an open source message transfer layer.

3. Use a commercial product.

Each of these options has advantages: custom software is pliable and
can be tuned to specific needs; open source is cheap to use and cheap
to fix; commercial products are (hopefully) high-quality and come with
teams of skilled engineers.

But each of these options is also frustrating for their own reasons.
None of the existing standards are sufficiently high-level to handle
the real work, so any ad-hoc solution eventually breaks, or becomes a
significant project in itself.

Open source messaging products are generally low-quality and slow.
There are several reasons for this, probably the most important is
the lack of middleware engineering skill in the open source community.

Finally, commercial products are generally expensive, complex to use,
and closed.  They can be very reliable, so are found in many larger
projects.  But there is a fundamental frustration with closed-source
products: even the smallest bug fix means getting formal support, which
can take a long time.

The Ideal Solution
==================

The ideal solution, conceived by top engineers from JPMC's Investment
Banking division, was for an open source middleware standard that was
fast, reliable, portable, high-level, easy to use, well documented,
stable, good looking, and cheap to make.

In other words, something that combines all the advantages, with none
of the disadvantages, of the three main approaches to middleware.

We believe that we've accomplished much of this, and are on the way
to accomplishing it all.

General Concepts
================

We will step back and look at the kinds of problems we need to solve
when designing a general purpose middleware system.

The Three Functional Areas
--------------------------

Messaging middleware covers three main functional areas:

1. Point-to-point messaging, which we will call "queues"
   for simplicity.

2. High-volume publish/subscribe, which we will call "topics"
   for simplicity.

3. File transfer, which we will call "files" for simplicity.

(AMQ uses the term "queue" in a more specific sense to define a
specific type of component, but the above terms are generally accurate
when discussing middleware scenarios).

There is some overlap, but in general these three areas have particular
functional needs and need specific solutions. Point-to-point queuing
focusses on the ability to move messages from one party to another party.
Publish-subscribe focusses on distributing messages from one party to many
other parties. File transfer focusses on sending very large files across
slow and perhaps unreliable networks.

Reliability vs. Performance
---------------------------

In each case we can need various degrees of reliability and
performance.  In general there is a trade-off between reliability
and speed - the more reliable the system, the slower it will run.

Reliability can be broken into several aspects:

1. Type of memory used: system RAM or disk storage.  If we want
   messages to survive a system reboot, they must be on disk.

2. Degree of redundancy: none, mirrored.  If we want to survive
   a system failure (e.g. disk crash) we must have redundancy of
   some kind.

3. Redundancy distance: if we want a redundant system to survive
   a physical event (fire, lightning, hurricane), it must be
   physically separated.

4. Degree of transactionality: none, partial, full.  If we want to
   be certain that the data was safely written in a coherent manner
   we must use transactions (of varying complexity).

In each case, there is a well-understood cost for the extra reliability.

Scenario Matrix
===============

By combining the functional areas with the options for reliability,
we can plot the actual combinations that make sense and are commonly
used.  We use a scale from 1 to 5, meaning 'not too important' to
'critical'.  For each scenario we show the typical range for various
critria:

                          Queues  Topics  Files
    Throughput              2-3     4-5     1-2
    Latency                 3-4     4-5     1
    Reliability             3-5     1-5     4-5

We can conclude that there is a large overlap in needs, and rather
than try to define the three domains as separate problems, it seems
more useful to provide the application architect with control over
the reliability vs. performance tradeoff independently from the choice
of what kind of messaging model to use.

Example Scenarios
=================

We give some specific example scenarios:

 - Departmental inter-system communications: consisting of 1-10
   highly-reliable queues, with perhaps a thousand messages a day,
   serving one to five applications and perhaps 100 users.

 - Financial services information streams: consisting of data
   streams from information providers such as Reuters, being
   distributed to a thousand or more workstations.  Typical
   daily volume can be anything up to a billion messages.

[PH: need JOH input here]

Existing Products
*****************

In-House Products
-----------------

- rough description of inhouse systems
- pros and cons

Open-source Products
--------------------

- some example open source products

Commercial Products
-------------------

IBM MQ Series
.............

Sonic MQ
........

Tibco
.....
