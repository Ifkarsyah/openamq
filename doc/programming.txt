gdl
    title     = Programming
    subtitle  = Writing OpenAMQ Applications
    product   = OpenAMQ
    author    = iMatix Corporation
    date      = 2008/04/12
    copyright = Copyright (c) 1996-2007 iMatix Corporation
    version   = 1.0
end gdl

WireAPI - a standard AMQP API
*****************************

Overview
========

What is WireAPI?
----------------

WireAPI is a standardised API that closely maps to the semantics of the AMQP
wire level protocol. For example, the AMQP method Queue.Declare maps to a
WireAPI function called amq_client_session_queue_declare. We can contrast this
approach with the one taken by the other kinds of API that hide the semantics of
working with AMQP are hidden to the developer. WireAPI has several advantages 
over more abstracted APIs:

 - Any version of AMQP is cleanly mapped to identical semantics in WireAPI.
 - Developers do not need to learn new semantics - once they know the protocol
   they know the API.
 - Developers have full control over all aspects of the middleware, not being
   restrained by any unnecessary API abstraction.
 - WireAPI semantics are portable to all languages (note that iMatix does not
   yet offer client libraries in languages other than C/C++).
   
The negative aspects of WireAPI are:

 - It can be complex for beginners.
 - It forces the developers to understand the protocol.
 - There are some useful abstractions missing from WireAPI.
 
Overall WireAPI works well because AMQP was designed to used in this way; its
semantics were designed to be meaningful to application developers.  We plan to
develop a WireAPI/2 that adds some useful abstractions such as end-to-end 
reliability, end-to-end encryption, message eventing (asynchronous deliver) and
so on.

Goals and principles
--------------------

The WireAPI is built using the same technology as the OpenAMQ server, and
provides a component-based interface to the AMQ protocol from the client side.
It is designed to:

 - Provide full asynchronous background operations.
 - Work both in single-threaded and multi-threaded applications.
 - Provide full access to all AMQP methods except those used for connection
   and session start-up and shut-down.
 - Provide full access to all AMQP method properties.
 - Act as the basis for other language APIs based on the WireAPI model.
 - Be 100% portable to all mainstream operating system platforms.
 - Work with any AMQP server implementation.

Architecture of C/C++ WireAPI
-----------------------------

The C/C++ WireAPI implementation provided by iMatix for OpenAMQ is a
multithreaded application in two halves. One half runs as a background thread ,
processing protocol methods and doing network i/o, so that messages can be sent
and received indepedently of application work. The second half runs in the
application thread, and provides API-level functionality, including
implementation of the WireAPI objects (connections, session, etc.)

This design has several consequences that you should take into account when
designing and building your application and/or messaging frameworks:

 * If you build OpenAMQ as a single-threaded application, background processing
   of messages will be unreliable.  Concretely, the background thread will only 
   process when the application calls the amq_client_session_wait () method.

 * WireAPI is safe to use in multithreaded applications, but you must not share
   WireAPI classes (connection, session, etc.) between application threads.

Using WireAPI
=============

Compiling and linking
---------------------

WireAPI is internally constructed using a number of iMatix tools such as iCL.
However, the calling application does not need to use these tools in order to
use WireAPI, except to correctly initialise and terminate iCL. It needs only the
header files and the libraries. The simplest way to get these is to build the
full OpenAMQ kernel, and then use the $IBASE/include and $IBASE/lib directories
when compiling and linking the application.

Basic construction
------------------

WireAPI sits between the application:

    .---------------.      .-------------.      .--------------.
    |               | ---> |             | ---> |              |
    |  Application  |      |   WireAPI   |      |  AMQ Server  |
    |               | <--- |             | <--- |              |
    `---------------'      `-------------'      `--------------'

Here is a trivial example that sends one message to an AMQ server. This program
does no error handling so you should not copy this code directly:

    #include "asl.h"
    #include "amq_client_connection.h"
    #include "amq_client_session.h"

    int
    main (int argc, char *argv [])
    {
        amq_client_connection_t
            *connection = NULL;             //  Current connection
        amq_client_session_t
            *session = NULL;                //  Current session
        amq_content_basic_t
            *content = NULL;                //  Message content
        icl_longstr_t
            *auth_data;

        //  Initialise iCL system
        icl_system_initialise (argc, argv);

        //  Open session to local server
        auth_data  = amq_client_connection_auth_plain ("guest", "guest");
        connection = amq_client_connection_new (
            "localhost", "/", auth_data, "test", 0, 30000);
        icl_longstr_destroy (&auth_data);
        session = amq_client_session_new (connection);

        //  Create a content and send it to the "queue" exchange
        content = amq_content_basic_new ();
        amq_content_basic_set_body       (content, "0123456789", 10, NULL);
        amq_content_basic_set_message_id (content, "ID001");
        amq_client_session_basic_publish (
            session, content, 0, "to-address", NULL, FALSE, FALSE);
        amq_content_basic_unlink         (&content);

        //  Shutdown connection and session
        amq_client_session_destroy    (&session);
        amq_client_connection_destroy (&connection);

        //  Terminate iCL system
        icl_system_terminate ();
        return (0);
    }

This shows some of the main object classes that compose WireAPI:

 - amq_client_connection: lets you connect to a server.
 - amq_client_session: lets you create a session and talk to the server
   using this session.
 - amq_content_basic: lets you create Basic content to send to the
   server, or process Basic content received from the server.

The iCL class syntax
--------------------

The WireAPI classes are all constructed using iCL and some knowledge of iCL will
make your life easier. However, the syntax for using iCL classes in C is
consistent and we can summarise it:

 - classname_new creates a new object instance and returns a reference to that 
   object.
 - classname_destroy takes the address of an object reference and destroys that
   object, if the reference is not null.
 - classname_somemethod takes an object reference along with arguments and does
   some work on the object.
 - classname->propertyname accesses a class property.

iCL signals errors by returning a null object (after a new) or by returning a
non-zero error code (after other methods). iCL return codes are integers.

Thus the correct way to open a connection and session is actually like this:

    auth_data  = amq_client_connection_auth_plain ("guest", "guest");
    connection = amq_client_connection_new (
        "localhost", "/", auth_data, "test", 0, 30000);
    icl_longstr_destroy (&auth_data);
    if (!connection) {
        icl_console_print ("E: could not open connection");
        return (1);
    }
    session = amq_client_session_new (connection);
    if (!session) {
        icl_console_print ("E: could not open session");
        return (1);
    }

And the correct way to call a method like publish is:

    int rc;
    ...
    content = amq_content_basic_new ();
    ...
    rc = amq_client_session_basic_publish (
        session, content, 0, "queue", "mydest", FALSE, FALSE);
    amq_content_basic_unlink (&content);
    if (rc) {
        icl_console_print ("E: could not publish message");
        return (1);
    }

The connection class
====================

What is a 'connection'?
-----------------------

A connection is a TCP/IP connection from a client to an OpenAMQ server. AMQP is
a multi-channel protocol, meaning that one network connection can carry an
arbitrary number of parallel, independent virtual connections, which AMQP calls
"channels". In WireAPI these are called "sessions" for compatability with other
middleware APIs. NOTE: OpenAMQ currently supports exactly ONE session per
connection.

Before calling any iCL method including amq_client_connection_new, you must have
called icl_system_initialise (), or your application will fail with an abort.

amq_client_connection_new
-------------------------

Creates a new connection to the server:

    amq_client_connection_t
        *connection = NULL;             //  Current connection
    icl_longstr_t
        *auth_data;                     //  Authentication data

    auth_data  = amq_client_connection_auth_plain ("guest", "guest");
    connection = amq_client_connection_new (
        "localhost", "/", auth_data, "test", 0, 30000);

    icl_longstr_destroy (&auth_data);
    if (connection)
        icl_console_print ("I: connected to %s/%s - %s - %s",
            connection->server_product,
            connection->server_version,
            connection->server_platform,
            connection->server_information);
    else {
        icl_console_print ("E: could not connect to server");
        return (1);
    }

Notes:

 - The host_name argument specifies a server name or IP address, optionally
   ending in ':' plus a port number.

 - The virtual_host name specifies the virtual host to which the connection
   will connect.  The default virtual host is "/".

 - The auth_data provides an authentication block, used to login to the server.
   To create a plain-text authentication block, use the auth_plain method. The 
   new method destroys the auth_data block on behalf of the caller.

 - The instance argument sets the client instance name, which can be used
   to identify a specific client in the management console or server log.

 - The trace argument sets the trace level for WireAPI.

 - The timeout argument governs all synchronous exchanges with the server - if
   the server does not respond within this time, the connection treats it as a
   fatal error.  A timeout of zero means "infinite".  A good value for fast 
   networks is five to ten seconds; for a slower network, a value of 30 seconds 
   or more is reasonable.

amq_client_connection_destroy
-----------------------------

Closes an open connection, doing a clean shut-down.  Applications should
use this to end a connection (rather than just exiting):

    amq_client_connection_destroy (&connection);

amq_client_connection_auth_plain
--------------------------------

Returns an authentication block for a plain login:

    icl_longstr_t
        *auth_data;                     //  Authentication data

    auth_data = amq_client_connection_auth_plain ("guest", "guest");

Connection Properties
---------------------

These are the properties of a connection object:

 - alive (Boolean) - FALSE when connection has had an error
 - silent (Boolean) - set this TRUE to suppress error reporting
 - error_text (string) - error string reported by the API
 - reply_text (string) - error string reported by server
 - reply_code (integer) - error value reported by server
 - version_major (integer) - server protocol version major
 - version_major (integer) - server protocol version minor
 - server_product (string) - product name reported by server
 - server_version (string) - product version reported by server
 - server_platform (string) - operatintg system platform reported by server
 - server_copyright (string) - copyright notice reported by server
 - server_information (string) - other information reported by server

The session class
=================

What is a 'session'?
--------------------

A session corresponds to an AMQP channel, and is a virtual connection to an AMQP
server. You must at least create one session in order to talk with an AMQP
server. While AMQP offers multiplexing in theory, OpenAMQ no longer implements
this, mainly because there are no proven performance advantages. So you should
create a single session per connection, no more. Future versions of WireAPI may
merge the session and connection classes.

amq_client_session_new
----------------------

Creates a new session:

    amq_client_session_t
        *session = NULL;                //  Current session

    session = amq_client_session_new (connection);
    if (!session) {
        icl_console_print ("E: could not open session to server");
        return (1);
    }

amq_client_session_destroy
--------------------------

Closes an open session, doing a clean shut-down. Applications should call this
method when closing a session. Closing the connection is a valid way of closing
all open sessions for that connection:

    amq_client_session_destroy (&session);

amq_client_session_wait
-----------------------

Waits for content to arrive from the server. You must call this method in order
to get content. Returns zero if content arrived, or -1 if the timeout expired:

    if (amq_client_session_wait (session, timeout))
        if (session->alive)
            //  timeout expired
        else
            //  session died
    else
        //  zero or more contents arrived

Session properties
------------------

These are the properties of a session object:

 - alive (Boolean) - FALSE when connection has had an error
 - silent (Boolean) - set this TRUE to suppress error reporting
 - error_text (string) - error string reported by the API
 - ticket (integer) - access ticket granted by server
 - queue (string) - queue name assigned by server
 - exchange (string) - exchange name from last method
 - message_count (integer) - number of messages in queue
 - consumer_count (integer) - number of consumers
 - active (Boolean) - session is paused or active
 - reply_text (string) - error string reported by server
 - reply_code (integer) - error value reported by server
 - consumer_tag (integer) - server-assigned consumer tag
 - routing_key (string) - original message routing key
 - scope (string) - queue name scope
 - delivery_tag (integer) - server-assigned delivery tag
 - redelivered (Boolean) - message is being redelivered

Note that all of these except alive, silent, and error_text are the result of
methods sent from the server to the client. For detailed descriptions of these
properties, read the AMQP specifications. All incoming method arguments are
stored as session properties. Thus the "message-count" argument of an incoming
Basic.Browse-Ok method will be stored in the message_count property.

The exchange class
==================

Exchanges match and distribute messages across queues. Exchanges can be
configured in the server or created at runtime.

amq_client_session_exchange_declare
-----------------------------------

This method creates an exchange if it does not already exist, and if the
exchange exists, verifies that it is of the correct and expected class:

    asl_field_list_t
        *field_list = NULL;
    icl_longstr_t
        *arguments_table = NULL;

    //  Build arguments field as necessary
    field_list = asl_field_list_new (NULL);
    arguments_table = asl_field_list_flatten (field_list);

    rc = amq_client_session_exchange_declare (
        session,                    //  Session reference
        0,                          //  Access ticket (unused)
        exchange_name,              //  Exchange name
        "direct",                   //  Exchange type
        0,                          //  If 1, don't actually create
        0,                          //  Durable (unused)
        0,                          //  If 1, auto-delete when unused
        0,                          //  Internal exchange (unused)
        arguments_table);           //  Arguments for declaration

    asl_field_list_unlink (&field_list);
    icl_longstr_destroy (&arguments_table);

The Exchange.Declare method has the following specific fields:

- exchange (shortstr) - exchange name. The exchange name is a client-selected 
  string that identifies the exchange for publish methods. Exchange names may 
  consist of any mixture of digits, letters, and underscores. Exchange names 
  are scoped by the virtual host.

- type (shortstr) - exchange type. Each exchange belongs to one of a set of 
  exchange types implemented by the server. The exchange types define the 
  functionality of the exchange - i.e. how messages are routed through it. It 
  is not valid or meaningful to attempt to change the type of an existing 
  exchange.  OpenAMQ supports "fanout", "direct", "topic", and "header"
  exchanges.

- passive (bit) - do not create exchange. If set, the server will not create 
  the exchange. The client can use this to check whether an exchange exists 
  without modifying the server state.

- auto_delete (bit) - auto-delete when unused. If set, the exchange is deleted 
  when all queues have finished using it.

- arguments (table) - arguments for declaration. A set of arguments for the 
  declaration. The syntax and semantics of these arguments depends on the server
  implementation. This field is ignored if passive is 1.

amq_client_session_exchange_delete
----------------------------------

This method deletes an exchange. When an exchange is deleted all queue bindings
on the exchange are cancelled.

    rc = amq_client_session_exchange_delete (
        session,                    //  Session reference
        0,                          //  Access ticket (unused)
        exchange_name,              //  Exchange name
        0);                         //  If-unused option (unused)

The Exchange.Delete method has the following specific fields:

- exchange (shortstr) - exchange name. The exchange name is a client-selected 
  string that identifies the exchange for publish methods. Exchange names may 
  consist of any mixture of digits, letters, and underscores.

The queue class
===============

Queues store and forward messages. Queues can be configured in the server or
created at runtime. Queues must be attached to at least one exchange in order to
receive messages from publishers.

amq_client_session_queue_declare
--------------------------------

This method creates or checks a queue. When creating a new queue the client can
specify various properties that control the durability of the queue and its
contents, and the level of sharing for the queue.

    asl_field_list_t
        *field_list = NULL;
    icl_longstr_t
        *arguments_table = NULL;

    //  Build arguments field as necessary
    field_list = asl_field_list_new (NULL);
    arguments_table = asl_field_list_flatten (field_list);

    rc = amq_client_session_queue_declare (
        session,                    //  Session reference
        0,                          //  Access ticket (unused)
        queue_name,                 //  Queue name, null means auto-assign
        0,                          //  If 1, don't actually create
        0,                          //  Durable (unused)
        0,                          //  If 1, request exclusive queue
        0,                          //  If 1, auto-delete when unused
        arguments_table);           //  Arguments for declaration

    asl_field_list_unlink (&field_list);
    icl_longstr_destroy (&arguments_table);

The Queue.Declare method has the following specific fields:

- queue (shortstr) - queue name. Queue names may consist of any mixture of
  digits, letters, and underscores.  May be specified, or may be empty (NULL).
  If the queue name is null, the server creates and names a queue and
  returns this.  You can access the last created queue from
  session->queue; if you want to create many queues, copy the returned
  name somewhere safe.

- passive (bit) - do not create queue. If set, the server will not
  create the queue. The client can use this to check whether a queue
  exists without modifying the server state.

- exclusive (bit) - request an exclusive queue. Exclusive queues may
  only be consumed from by the current connection. Setting the
  'exclusive' flag always implies 'auto-delete'.

- auto_delete (bit) - auto-delete queue when unused. If set, the queue
  is deleted when all consumers have finished using it. Last consumer
  can be cancelled either explicitly or because its channel is closed.
  If there was no consumer ever on the queue, it won't be deleted.

- arguments (table) - arguments for declaration. A set of arguments for
  the declaration. The syntax and semantics of these arguments depends
  on the server implementation. This field is ignored if passive is 1.

amq_client_session_queue_bind
-----------------------------

This method binds a queue to an exchange. Until a queue is bound it will not
receive any messages. In a classic messaging model, store-and-forward queues are
bound to a dest exchange and subscription queues are bound to a dest_wild
exchange.

    rc = amq_client_session_queue_bind (
        s_session,                  //  Session reference
        0,                          //  Access ticket (unused)
        queue_name,                 //  Name of queue to bind
        exchange_name,              //  Name of exchange to bind to
        routing_key,                //  Message routing key
        arguments_table);           //  Arguments for bind

The Queue.Bind method has the following specific fields:

- queue (shortstr) - queue name. Specifies the name of the queue to bind. If 
  the queue name is empty (NULL), refers to the current queue for the channel, 
  which is the last declared queue. Queue names may consist of any mixture of
  digits, letters, and underscores.

- exchange (shortstr) - exchange name. The exchange name is a client-selected 
  string that identifies the exchange for publish methods. Exchange names may
  consist of any mixture of digits, letters, and underscores. Exchange names 
  are scoped by the virtual host.

- routing_key (shortstr) - message routing key. Specifies the routing key for 
  the binding. The routing key is used for routing messages depending on the
  exchange configuration. Not all exchanges use a routing key - refer to the 
  specific exchange documentation. If the routing key is empty and the queue 
  name is empty, the routing key will be the current queue for the channel, 
  which is the last declared queue.

- arguments (table) - arguments for binding. A set of arguments for the binding. 
  The syntax and semantics of these arguments depends on the exchange class.

amq_client_session_queue_unbind
-------------------------------

This method unbinds a queue from an exchange.

    rc = amq_client_session_queue_unbind (
        s_session,                  //  Session reference
        0,                          //  Access ticket (unused)
        queue_name,                 //  Name of queue
        exchange_name,              //  Name of exchange
        routing_key,                //  Message routing key
        arguments_table);           //  Arguments for unbind

The Queue.Unbind method has the following specific fields:

- queue (shortstr) - queue name. Specifies the name of the queue to
  unbind. If the queue name is empty, refers to the current queue for
  the channel, which is the last declared queue. Queue names may consist
  of any mixture of digits, letters, and underscores.

- exchange (shortstr) - exchange name. The exchange name is a
  client-selected string that identifies the exchange for publish
  methods. Exchange names may consist of any mixture of digits,
  letters, and underscores. Exchange names are scoped by the virtual
  host.

- routing_key (shortstr) - message routing key. Specifies the routing
  key of the binding to unbind.

- arguments (table) - arguments for binding. A set of arguments of the
  binding to unbind.

amq_client_session_queue_purge
------------------------------

This method removes all messages from a queue. It does not cancel consumers.
Purged messages are deleted without any formal "undo" mechanism.

    rc = amq_client_session_queue_purge (
        s_session,                  //  Session reference
        0,                          //  Access ticket (unused)
        queue_name);                //  Name of queue to purge

The Queue.Purge method has the following specific fields:

- queue (shortstr) - queue name. Specifies the name of the queue to
  purge. If the queue name is empty, refers to the current queue for
  the channel, which is the last declared queue. Queue names may consist of any
  mixture of digits, letters, and underscores.

amq_client_session_queue_delete
-------------------------------

This method deletes a queue. When a queue is deleted any pending messages are
sent to a dead-letter queue if this is defined in the server configuration, and
all consumers on the queue are cancelled.

    rc = amq_client_session_queue_delete (
        s_session,                  //  Session reference
        0,                          //  Access ticket (unused)
        queue_name,                 //  Name of queue to delete
        0,                          //  If-unused (unused)
        0);                         //  If-empty (unused)

The Queue.Delete method has the following specific fields:

- queue (shortstr) - queue name. Specifies the name of the queue to
  delete. If the queue name is empty, refers to the current queue for
  the channel, which is the last declared queue. Queue names may consist
  of any mixture of digits, letters, and underscores.

The basic content class
========================

What is a 'content'?
--------------------

AMQP uses the term "content" to mean an application message (the term "message"
means different things at the application, protocol, and internal technical
levels, so is confusing).

WireAPI provides an iCL class called 'amq_content_basic' to lets you create and
manipulate basic contents:

    amq_content_basic_t
        *content;

    content = amq_content_basic_new ();
    amq_content_basic_set_body       (content, "0123456789", 10, NULL);
    amq_content_basic_set_message_id (content, "ID001");
    amq_content_basic_unlink (&content);

To create a new content, use the 'new' method. To destroy a content, use the
'unlink' method.

amq_client_session_basic_consume
--------------------------------

The amq_client_session_basic_consume method tells a queue to start sending
messages to the application. The standard pattern is to declare a queue, then
bind it to one or more exchanges, and then consume from it. There are two
typical use cases: private queues for response messages, and shared queue for
workload balancing. The application can request exclusive access (be the only
consumer), which is recommended for private response queues. The application can
also request 'no_local' delivery which is recommended for certain kinds of
fanout pub-sub:

    amq_client_session_basic_consume (
        session,                    //  Session reference
        0,                          //  Access ticket (unused)
        queue_name,                 //  Queue name
        consumer_tag,               //  Consumer tag, or empty
        no_local,                   //  If TRUE, won't receive own messages
        0,                          //  No-ack (unused)
        exclusive,                  //  Request exclusive access to queue
        arguments);                 //  Arguments for consume


amq_client_session_basic_cancel
-------------------------------

The amq_client_session_basic_cancel method stops a consumer.  The application
must use the consumer tag that was returned by the server after the consume
method (which will be in session->consumer_tag immediately after the consume
succeeds, and until a further consume is executed):

    rc = amq_client_session_basic_cancel (
        session,                    //  Session reference
        consumer_tag);              //  Consumer tag

amq_client_session_basic_publish
--------------------------------

The amq_client_session_basic_publish method sends a content to a specified
exchange:

    rc = amq_client_session_basic_publish (
        session,                    //  Session reference
        basic_content,              //  Content reference
        0,                          //  Access ticket (unused)
        exchange_name,              //  Exchange name
        "",                         //  Routing key
        0,                          //  If 1, must be routable
        0);                         //  If 1, must be deliverable

amq_client_session_basic_get
----------------------------

The amq_client_session_basic_get method gets a single message off the queue.
This method does not require a consumer, so is used for simpler scenarios. Since
getting messages one by one is heavily synchronized, it is slower than using a
consumer:

    rc = amq_client_session_basic_get (
        session,                    //  Session reference
        0,                          //  Access ticket (unused)
        queue_name,                 //  Queue name
        0);                         //  No-ack (unused)
        
Receiving contents
------------------

For the Basic content class, WireAPI provides a set of methods to access arrived
and returned contents:

    amq_client_session_basic_arrived ()
    amq_client_session_basic_arrived_count ()
    amq_client_session_basic_returned ()
    amq_client_session_basic_returned_count ()

The first method returns the oldest content waiting to be processed, the second
methods returns the number of contents waiting. For example:

    amq_content_basic_t
        *content;

    amq_client_session_wait (session);
    if (amq_client_session_basic_arrived_count (session)) {
        icl_console_print ("I: have messages to process...");
        content = amq_client_session_basic_arrived (session);
        while (content) {
            //  Process content
            ...
            //  Unlink/destroy content, or we get memory leaks     
            amq_content_basic_unlink (&content);
            //  Get next content to process, if any
            content = amq_client_session_basic_arrived (session);
        }
    }

When processing arrived or returned content the application must not assume that
a single content arrived. It should assume that zero or more contents arrived or
returned, and process each of them, and wait again if it needs to.

Basic content properties
------------------------

All contents have these properties, which you can inspect directly using
content->propertyname (e.g. 'content->routing_key'):

 - body_size (integer) - the body size of the content.
 - exchange (string) - the exchange to which the content was published.
 - routing_key (string) - the original routing_key specified by the publisher.
 - producer_id (string) - the producer id of the publishing connection.
 - content_type (string) - MIME content type.
 - content_encoding (string) - MIME content encoding.
 - headers (field table) - message header field table.
 - delivery_mode (integer) - non-persistent or persistent.
 - priority (integer) - message priority, 0 to 9.
 - correlation_id (string) - application correlation identifier
 - reply_to (string) - the destination to reply to.
 - expiration(string) - expiration specification.
 - message_id (string) - the application message identifier.
 - timestamp (integer) - message timestamp.
 - type (string) - message type name.
 - user_id (string) - creating user id.
 - app_id (string) - creating application id.
 - sender_id (string) - the sending application id.
  
To set any of a basic content's properties, DO NOT modify the property directly
but use the method:

    amq_content_basic_set_[propertyname] (content, newvalue)

Content body data
-----------------

To set a content's body, use this method:

    amq_content_basic_set_body (content, byte *data, size_t size, free_fn)

Where the free_fn is a function of type 'icl_mem_free_fn *' (compatible with the
standard library free() function). If free_fn is not null, it is called when the
data needs to be destroyed (when the content is destroyed, or if you call
_set_body() again.

To get a content's body, use this method:

    amq_content_basic_get_body (content, byte *buffer, size_t limit)

Where the buffer is at least as large as content->body_size. This method returns
the number of bytes copied, or -1 if the buffer was too small.

Advanced content manipulation
-----------------------------

To work with large contents - which do not fit into memory - you must use a more
complex API to read and write contents. For details of this please read the
amq_content_basic_class.icl and look at the test case, which demonstrates how to
read and write content bodies in frames rather than as single buffers.

Field tables
============

Various AMQP methods take field table arguments. The asl_field and
asl_field_list classes provide field tables that are designed to work with AMQP:

 - asl_field - defines a single named field holding data of various types.
 - asl_field_list - defines a field table (implemented as a list).

Simple field tables
-------------------

The simplest way to build a field table is to construct this using the
asl_field_list_build() method:

    icl_longstr_t
        field_table;

    field_table = asl_field_list_build (
        "host",  "Sleeper Service",
        "guest", "My Homework Ate My Dog",
        NULL);
    ...
    icl_longstr_destroy (&field_table);

The build() method has a limitation - it only handles string fields. For most
AMQP applications this is fine but we can get the same result using calls to
individual methods:

    asl_field_list_t
        *field_list;
    icl_longstr_t
        *field_table;

    field_list = asl_field_list_new (NULL);
    asl_field_new_string  (field_list, "host", "Sleeper Service");
    asl_field_new_string  (field_list, "guest", "My Homework Ate My Dog");
    field_table = asl_field_list_flatten (field_list);
    asl_field_list_destroy (&field_list);
    ...
    icl_longstr_destroy (&field_table);

Field tables in more detail
---------------------------

Field tables are held in two ways:

 1. As a list of fields.  You can navigate this list using standard iCL list 
    navigation commands (first, next, pop, etc.)

 2. As a serialised block of data, held in an icl_longstr_t.  Field tables held 
    in this format are portable, and can be sent to other machines.  This is the 
    format we send across a network via AMQP.

To convert from a field table string to a list, create a new list and pass the
string as an argument. To convert from a field list to a table string, use the
flatten() method as shown above.

The main asl_field_list methods are:

 - asl_field_list_t *asl_field_list_new (icl_longstr_t *string) - create
   a new field table given a serialised string, or NULL to create an
   empty field table.
 - asl_field_t *asl_field_list_search (list, fieldname) - look for a field
   with a given name.  Note that you must use the unlink() method on the
   returned field reference when you are finished using it.
 - asl_field_list_print (list) - print the field table contents for
   debugging purposes.
 - icl_longstr_t *asl_field_list_build (...) - build a field table from
   a list of name/value pairs, ending in a null name.

The main asl_field methods are:

 - asl_field_new_string (list, fieldname, stringvalue) - create a new
   string field with the given name and value.
 - asl_field_new_integer (list, fieldname, integervalue) - create a new
   integer field with the given name and value.
 - asl_field_new_decimal (list, fieldname, integervalue, decimals) -
   create a new decimal field with the given name and value.
 - asl_field_new_time (list, fieldname, timevalue) - create a new time
   field with the given name and value.
 - asl_field_list_destroy (&list) - destroy a field table.
 - asl_field_string (field) - return a string value for a field, doing
   any necessary conversion.
 - asl_field_integer (field) - return an integer value for a field, doing
   any necessary conversion.

For more details on these methods, refer to the class documentation and/or
documented class source code.

You can also access a field's properties directly:

 - name (string) - the field name.
 - type (character) - 'S', 'I', 'D', or 'T' for string, integer, date, or time 
   field.
 - decimals (integer) - number of decimals for a decimal field.
 - string (icl_longstr_t *) - string value for the field.
 - integer (int64_t) - integer value for the field.

Error handling
==============

WireAPI returns two types of error:

 - Errors reported internally, e.g. timeout.
 - Errors reported by the remote server, e.g. invalid queue name.

In the first case, the error message is provided in session->error_text. There
is no localisation - error messages are English only (for now). When there is an
internal error, the session->reply_code will be zero.

In the second case, the error message is provided in session->reply_text and an
error code is provided in session->reply_code. If the error was at the
connection level, the error is placed in connection->reply_text and
connection->reply_code instead.

The application can print the right error message using code like this:

    if (s_session->reply_code)
        icl_console_print ("E: %d - %s",
            s_session->reply_code, s_session->reply_text);
    else
        icl_console_print ("E: %s", s_session->error_text);

Nowait methods
==============

AMQP/0.9 has a "nowait" option on some methods that turn normally synchronous
methods into asynchronous ones.  This is important for applications that do very
large volumes of wiring (queue creation, etc.) since it can dramatically cut the
start-up time.

WireAPI implements nowait as a second set of methods:

 - amq_client_session_exchange_declare_nowait 
 - amq_client_session_exchange_delete_nowait 
 - amq_client_session_queue_declare_nowait 
 - amq_client_session_queue_bind_nowait 
 - amq_client_session_queue_purge_nowait 
 - amq_client_session_queue_delete_nowait 
 - amq_client_session_queue_unbind_nowait 
 - amq_client_session_basic_consume_nowait 
 - amq_client_session_basic_cancel_nowait 

Each of these methods takes the same arguments as their synchronous versions.

To use the nowait functionality on automatically-named queues (private exclusive
queues), you need to use the default queue functionality, i.e:

 - queue.declare with no name (creates a name automatically)
 - queue.bind with no name (uses that queue name)
 - queue.consume with no name (uses that queue name)

Miscellaneous topics
====================

Object ownership
----------------

WireAPI uses the standard iCL model to define object ownership:

 - The layer which calls the "new" method on an object also destroys it.

 - If an intermediate layer wants to co-own the object, it does this using 
   possession.  An object must explicitly allow this. The content objects are 
   designed for this.

 - If an intermediate layer wants to hold a reference to an object, it does this
   using linking.  An object must explicitly allow this.

Synchronous vs. asynchronous methods
------------------------------------

AMQP (like all ASL protocols) divides methods strictly into those that expect an
immediate reply (synchronous) and those that do not (asynchronous). WireAPI
handles these cases as follows:

 - When you use a synchronous method (e.g. Basic.Consume), WireAPI waits for the
   server to respond with a synchronous reply, and it processes this reply.  Any
   asynchronous methods that the server sends before the reply are also 
   processed (e.g. incoming content will be correctly queued.)

 - When you use an asynchronous method (e.g. Basic.Publish), WireAPI does not
   wait for any server response.  You can therefore send such events rapidly and
   expect WireAPI to return as fast as it can, and process them in the 
   background.

Single-Threaded background processing
-------------------------------------

WireAPI works in both a multi-threaded model (in which one thread handles all
dialogue with the server and a second handles the application) and
single-threaded (in which a single thread does all the work).

You choose the model when you build OpenAMQ, which specifically has both single-
and multi-threaded capability built into it.

The single-threaded model has one specific requirement: the application must
periodically call the amq_client_session_wait() method, since it is during this
call that asynchronous incoming methods are processed. Always call this method
instead of "sleep" or an equivalent in your application.

The demo chat application
*************************

Building and testing
====================

The following OpenAMQ application is a simple example of how to send and receive
messages via WireAPI. This is a "chat" application. It consists of two programs
that are listed at the end of this chapter:

 - im_sender.c publishes a line of text to a chat room
 - im_receiver.c joins a chat room and prints everything that is posted there
 
To compile and link the files set your environment in the same way as you do to
build OpenAMQ server and type this command:

    c -l im_sender.c im_receiver.c

To start the chat room demo, open two console windows and run these commands,
one in each window, in the following order:

    amq_server
    im_receiver localhost:5672 "demo room"

Note that the amq_server by default starts on port 5672.  Now to send a line of
text to the chat room, run the im_sender program in a third window:
    
    im_sender localhost:5672 "demo room" "This is a not a string"

There can be any number of clients connected to the same chatroom. There's no
need to create chat rooms explicitly; these are created on demand.

Sender program
==============

    im_sender.c:
    --------------------------------------------------------------------------
    //
    //  im_sender.c - Sends messages to the chatroom
    //  By iMatix Corporation, April 2008.  Code released into the public domain.
    //
    //  Name:     im_sender
    //  Usage:    im_sender <broker-addeess> <chatroom> <your-name>
    //  Example:  im_sender 127.0.0.1:5672 "OpenAMQ discussion" "Baron Bartholomaeus von Saburg-Fridetzki"
    //  Sends messages from stdio to the chat room 
    //  To receive messages from the chat room, use im_receiver application
    
    #include "base.h"
    #include "amq_client_connection.h"
    #include "amq_client_session.h"
    
    int main (int argc, char *argv [])
    {
        amq_client_connection_t
            *connection;
        amq_client_session_t
            *session;
        icl_longstr_t
            *auth_data;
        amq_content_basic_t
            *content;
        char
            message_text [1024];
        char
            *message_body;
            
        assert (argc == 4);
    
        //  Initialise system
        icl_system_initialise (argc, argv);
    
        //  Open a connection
        auth_data = amq_client_connection_auth_plain ("guest", "guest");
        connection = amq_client_connection_new (
                argv [1], "/", auth_data, "im_sender", 0, 30000);
        assert (connection);
        icl_longstr_destroy (&auth_data);
    
        //  Open a channel
        session = amq_client_session_new (connection);
        assert (session);
    
        while (1) {

        //  Read one line from stdin
            fgets (message_text, sizeof (message_text), stdin);
    
            //  Exit the loop if Ctrl+C is encountered
            if (!connection->alive)
                break;
    
            //  Create the message body
            message_body =
                malloc (strlen (argv [3]) + 2 + strlen (message_text) + 1);
            assert (message_body);
            sprintf (message_body, "%s: %s", argv [3], message_text);
    
            //  Create the message itself
            content = amq_content_basic_new ();
            amq_content_basic_set_body (content, message_body,
                strlen (message_body), free);
    
            //  Send the message
            amq_client_session_basic_publish (
                session,                        //  session
                content,                        //  content to send
                0,                              //  ticket
                "amq.direct",                   //  exchange to send message to
                argv [2],                       //  routing-key
                FALSE,                          //  mandatory
                FALSE);                         //  immediate
    
            //  Release the message
            amq_content_basic_unlink (&content);
        }
    
        //  Close the channel
        amq_client_session_destroy (&session);
    
        //  Close the connection
        amq_client_connection_destroy (&connection);
    
        //  Uninitialise system
        icl_system_terminate ();
    
        return 0;
    }

Receiver program
================

    im_receiver.c:
    --------------------------------------------------------------------------
    //
    //  im_receiver.c - Receives messages from a chatroom
    //  By iMatix Corporation, April 2008.  Code released into the public domain.
    //
    //  Name:     im_receiver
    //  Usage:    im_receiver <broker-addeess> <chatroom>
    //  Example:  im_receiver 127.0.0.1:5672 "OpenAMQ discussion"
    //  Receives messages from the chatroom and writed them to stdout
    //  To send messages to the chat room, use im_sender application
    
    #include "base.h"
    #include "amq_client_connection.h"
    #include "amq_client_session.h"
    
    int main (int argc, char *argv [])
    {
        amq_client_connection_t
            *connection;
        amq_client_session_t
            *session;
        icl_longstr_t
            *auth_data;
        amq_content_basic_t
            *content;
        char
            message_text [1024];
        size_t
            message_size;
    
    
        assert (argc == 3);
    
        //  Initialise system
        icl_system_initialise (argc, argv);
    
        //  Open a connection
        auth_data = amq_client_connection_auth_plain ("guest", "guest");
        connection = amq_client_connection_new (
                argv [1], "/", auth_data, "im_receiver", 0, 30000);
        assert (connection);
        icl_longstr_destroy (&auth_data);
    
        //  Open a channel
        session = amq_client_session_new (connection);
        assert (session);
    
        //  Create a private queue
        amq_client_session_queue_declare (
            session,                        //  session
            0,                              //  ticket
            NULL,                           //  queue name
            FALSE,                          //  passive
            FALSE,                          //  durable
            TRUE,                           //  exclusive
            TRUE,                           //  auto-delete
            NULL);                          //  arguments
    
        //  Bind the queue to the exchange
        amq_client_session_queue_bind (
            session,                        //  session
            0,                              //  ticket
            NULL,                           //  queue
            "amq.direct",                   //  exchange
            argv [2],                       //  routing-key
            NULL);                          //  arguments
    
        //  Consume from the queue
        amq_client_session_basic_consume (
            session,                        //  session
            0,                              //  ticket
            NULL,                           //  queue
            NULL,                           //  consumer-tag
            TRUE,                           //  no-local
            TRUE,                           //  no-ack
            TRUE,                           //  exclusive
            NULL);                          //  arguments
    
        while (1) {
    
            while (1) {
    
                //  Get next message
                content = amq_client_session_basic_arrived (session);
                if (!content)
                    break;
    
                //  Get the message body and write it to stdout
                message_size = amq_content_basic_get_body (content,
                      (byte*) message_text, sizeof (message_text));
                if (message_size) {
                    message_text [message_size] = 0;
                    fputs (message_text, stdout);
                }
    
                //  Destroy the message
                amq_content_basic_unlink (&content);
            }
            
            //  Wait while next message arrives
            amq_client_session_wait (session, 0);
    
            //  Exit the loop if Ctrl+C is encountered
            if (!connection->alive)
                break;
        }
    
        //  Close the channel
        amq_client_session_destroy (&session);
    
        //  Close the connection
        amq_client_connection_destroy (&connection);
    
        //  Uninitialise system
        icl_system_terminate ();
    
        return 0;
    }

Overview
========

AMQP was originally designed using the iMatix ASL framework for protocols. ASL
includes a tool for scripting protocols like AMQP, called PAL, the protocol
automation language.

PAL is an XML language intended to make it very simple to script AMQP scenarios,
most importantly for writing test scripts.  PAL can be used to develop certain
types of AMQP application but this is not its intent.

PAL has two sets of commands:

 1. A set of commands that implement a simple scripting language.
 2. A set of commands that automate the protocol.

The scripting language functionality provides loops, conditional and repeated
blocks, variables etc. The protocol method commands talk to the server and
manipulate content.

ASL protocols have the useful property of being high-level. That is, the methods
generally need little or no abstraction to be immediately obvious and useful to
application developers. This makes it reasonable in PAL to simply expose the
protocol methods directly to the scripting language. This strategy is helped by:

 - The use of clear and consistent names for methods and method properties.
 - The use of intelligent defaults for optional properties.

ASL protocols share the same connection and channel initiation and tear-down
architecture. The methods used to do this - such as Connection.Tune - are hidden
from the PAL developer. Specifically, we hide:

 - All Connection class methods.
 - The Channel.Open and Close methods.
 - All methods sent by the server and received by the client. Since PAL is for 
   client-side automation, methods sent by the server cannot be scripted.

Architecture of PAL
-------------------

PAL is a "codebot" written using the iMatix GSL language. The PAL codebot is an
interpreter and code generator that understands the PAL language and AMQP, and
generates code (ANSI C) for the script. The PAL codebot for AMQP is called
amq_pal_gen.gsl and sits on the $IBASE/bin path.  To run PAL you need to have
GSL installed (this is built and installed when you build OpenAMQ).

To build a PAL program called example.pal you would issue these commands:

    gsl example.pal
    c -l example

The gsl command loads PAL program, which is an XML file, and looks for a
property named 'script', that tells GSL which codebot to run.  So the basic form
of all PAL files is:

    <?xml?>
    <pal script = "amq_pal_gen">
        ...
    </pal>

If the 'script' property is missing, you can specify it on the command line as
follows (but this is usually extra work and we don't recommend it):
    
    gsl -script:amq_pal_gen.gsl example.pal
    
The PAL code generation and compilation are encapsulated in a shell script
called 'pal' which is provided by the OpenAMQ installation, for Unix and for
Windows systems.

Sample PAL scripts
------------------

This section is in the form of a tutorial that explains each functionality with
an example. Here is a sample PAL script:

    <?xml?>
    <pal script = "amq_pal_gen">
        <echo>
        Hello world!
        </echo>
    </pal>

To compile the script use "pal" command. It will create an executable for you.
You can run the executable straight away. Use "-h" option to get command line
parameters for the executable.

    $ pal hello.pal
    2007/03/23 06:46:41: gsl/4 M: Generating hello.c...
    Compiling hello...
    Linking hello...
    $ ./hello
    06:46:56: Hello world!
    $

Here is a script that demonstrates some of the standard PAL control commands:

    <?xml?>
    <pal script = "amq_pal_gen">
        <set name = "index" value = "0" />
        <repeat>
            <inc name = "index" />
            <if name = "index" value = "10">
                <break/>
            </if>
            <else>
                <echo>I can count up to $index</echo>
            </else>
        </repeat>
    </pal>

And an equivalent, shorter version:

    <?xml?>
    <pal script = "amq_pal_gen">
        <repeat times = "10" counter = "index">
            <echo>I can count up to $index</echo>
        </repeat>
    </pal>

To connect to a server and open a session we use the <session> control command.
Here is a script that connects to a server and then echoes the connection
properties:

    <?xml?>
    <pal script = "amq_pal_gen">
        <session>
            <echo>channel_max=$channel_max</echo>
            <echo>frame_max=$frame_max</echo>
            <echo>heartbeat=$heartbeat</echo>
            <echo>server_copyright=$server_copyright</echo>
            <echo>server_host=$server_host</echo>
            <echo>server_information=$server_information</echo>
            <echo>server_platform=$server_platform</echo>
            <echo>server_product=$server_product</echo>
            <echo>version_major=$version_major</echo>
            <echo>version_minor=$version_minor</echo>
        </session>
    </pal>

Note that the script does not specify what server to talk to, nor the IP port.
These and other options are passed on the command-line. For the standard C PAL
implementation run the script executable with "-h" to get a list of all options.

Having established a session we can send methods to the server:

    <?xml?>
    <pal script = "amq_pal_gen">
        <session>
            <queue_declare queue = "myqueue" />
            <queue_bind queue = "myqueue" exchange = "myexchange" />
            <basic_content size = "64000" message_id = "id-0001" />
            <basic_publish exchange = "myexchange" routing_key = "myqueue" />
            <basic_get queue = "myqueue" />
            <basic_arrived>
                <echo>Message '$message_id' came back to us</echo>
            </basic_arrived>
            <empty>
                <echo>Message did not come back, this is bad!</echo>
            </empty>
        </session>
    </pal>

PAL lets us define often-used method arguments at the 'session' level. These are
then inherited to methods that don't explicity specify them. So we can rewrite
the above script to make it shorter:

    <?xml?>
    <pal script = "amq_pal_gen">
        <session
            exchange = "myexchange"
            queue = "myqueue"
            >
            <exchange_declare class = "fanout" />
            <queue_declare />
            <queue_bind />
            <basic_content size = "64000" message_id = "id-0001" />
            <basic_publish routing_key = "myqueue" />
            <basic_get />
            <basic_arrived>
                <echo>Message '$message_id' came back to us</echo>
            </basic_arrived>
            <empty>
                <echo>Message did not come back, this is bad!</echo>
            </empty>
        </session>
    </pal>

We can also create content bodies by reading data from test data files, or by
running helper commands. See the 'read' and 'exec' options for the content
commands. It's as simple as (for instance):

    <basic_content exec = "perl -S myprog.pl" />

Scripts can be made flexible by passing arguments on the command line. Here is a
simple example:

    <?xml?>
    <pal script = "amq_pal_gen">
        <set name = "number" value = "1234" cmdline = "N" />
        <set name = "string" value = "abcd" cmdline = "S" />
        <echo>Number=$number, string=$string</echo>
    </pal>

Which we can run with the options -N and -S:

    cmdline -N 9999 -S XXXX

Lastly let's look at macros, which are ways of collecting repetitive commands
into groups to save time:

    <?xml?>
    <pal script = "amq_pal_gen">
        <macro name = "queue new">
            <exchange_declare exchange = "stdqueue" class = "fanout" />
            <queue_declare queue = "$queue" />
            <queue_bind queue = "$queue" exchange = "stdqueue" />
        </macro>
        <macro name = "send message">
            <basic_content size = "$size" message_id = "id-$random" />
            <basic_publish exchange = "stdqueue" routing_key = "$queue" />
        </macro>
        <session>
            <set name = "queue" value = "myqueue" />
            <invoke macro = "queue new" />
            <invoke macro = "send message">
                <set name = "size" value = "64000" />
            </invoke>
            <basic_get queue = "myqueue" />
            <basic_arrived>
                <echo>Message '$message_id' came back to us</echo>
            </basic_arrived>
            <empty>
                <echo>Message did not come back, this is bad!</echo>
            </empty>
        </session>
    </pal>

If you use macros to any extent you'll want to look at the <include> command,
described in the next section.

Scripting commands
==================

Summary
-------

These are the basic scripting commands, which can be nested to form scripts of
any complexity:

    invoke  - invoke a macro
    server  - start a protocol server
    timer   - start or reset performance timer
    set     - define or modify a variable
    inc     - increment a counter variable
    dec     - decrement a counter variable
    random  - set variable to randomised value
    read    - get input from console, assign to variable 
    echo    - echo text to the console
    abort   - echo text to the console and abort the script
    assert  - assert some condition is true
    repeat  - repeat a loop some number of times
    while   - repeat a loop while some condition is true
    break   - exit a loop
    if      - execute commands if a condition is true
    else    - execute commands if the previous if condition was false
    elsif   - combined if and else
    wait    - wait for the server to return data

Overall PAL script structure
----------------------------

The overall structure of the PAL script is:

    <pal script = "amq_pal_gen">
        [ <include filename = "filename" /> ]...
        [ <macro name = "macroname">
            [ script command ]...
          </macro> ]...
        [ <session>
            [ script command ]...
          </session> ]...
    </pal>

The include command
-------------------

The <include> command copies the contents of another PAL file into the current
script. It has this syntax:

    <include filename = "scriptfile" />

 - The filename must include the file extension (usually .pal). The included
   file should not have a <pal> level but may contain macros or script commands.

The macro command
-----------------

The <macro> command defines a block of commands that can be reused in as a
single command in the script. It has this syntax:
    
    <macro
        name = "macroname">
        [ script command ]...
    </macro>

 - Macros have no effect until they are used through the 'invoke' command.

The session command
-------------------

The <session> command defines a session:

    <session
      [ restart = "0 | 1" ]
      [ server = "servername" ]
      [ failover = "msecs" ]
        >
        [ script command ]...
    </session>

 - PAL may in future allow multiple sessions to be started in parallel, but for
   now sessions are executed serially.

 - If the restart option is 1, the session will restart in a new connection,
   whatever the state of previous sessions.  If 0, the session will restart in
   the previous connection, if any.

 - The servername can be used to test multiple servers in a single script. This 
   option is not used for general-purpose scripts.

 - If the failover is set to an integer greater than zero, on a broken  
   connection the script will pause for the specified number of milliseconds,
   and then try to reconnect to the same or alternate server. To use alternate 
   servers, specify multiple server names in the 'server' attribute, seperated 
   by spaces.

The invoke command
------------------

The <invoke> command expands a macro:

    <invoke
        macro = "macroname"
        />

 - If the macro uses variables in commands, you can set these variables
   either before the <invoke> command, or inside it, using <set> commands.

The server command
------------------

The <server> commands starts or restarts a protocol server:

    <server
        name = "servername"
      [ stdout = "filename" ]
      [ stderr = "filename" ]
      [ where = "directory" ]
        />

 - Do not specify a file extension (.exe) or your scripts will not be
   portable.

 - If a protocol server was already started, this command stops the server
   and then restarts it.

 - Only one protocol server can be started at a time.

 - The name value can include arbitrary server arguments but not shell
   redirection commands.

 - To redirect the server's output, use the stdout and stderr options.

The timer command
-----------------

The <timer> commands shows or resets the script timer.

    <timer
      [ action = "show | reset" ]
        />

 - The action is optional and defaults to "reset".
 
The set command
---------------

The <set> command defines a variable. Variables can be strings or integers. You
can use variables in repeat, while, and if blocks, and as symbols for templating
arguments and strings. Untyped variables are typed according to their value.

    <set
        name = "variablename"
      [ value = "newvalue" ]
      [ type = "string | integer" ]
        cmdline = "char"
        />

 - The value is optional, and defaults to "".
 
 - If the value is purely numeric, the type will default to "integer",
   and if not the type will default to "string".

 - The cmdline option specifies a single character. Do not use one of
   the command-line options already used by the PAL implementation (see
   section at the end of this document).

The inc command
---------------

The <inc> command increments an integer variable:

    <inc
        name = "variablename"
        />

The dec command
---------------

The <dec> command decrements an integer variable:

    <dec
        name = "variablename"
        />

 - Decrementing a variable below zero is illegal and raises a fatal error.
   This is done to catch script errors - negative values are normally not
   meaningful in test scripts.

The random command
------------------

The <random> command sets a variable to a random value within a specified range:

    <random
        name = "variablename"
      [ min = "minvalue" ]
        max = "maxvalue"
        />

 - The minimum is optional, and defaults to zero.

The read command
----------------

The <read> command accepts a line of input from the console and assigns this to
a variable:

    <read
        name = "variablename"
      [ prompt = "promptstring" ]
        />

 - The prompt is optional; if defined, this will be shown to the user (with no
   newline) before the console waits for input.

The echo command
----------------

The <echo> command echoes a line of text:

    <echo [trace = "1|2|3"]>line of text</echo>

 - The text can use variables with the syntax: $variablename.

 - The trace level set using a command-line switch.  Use the help option
   (-h) on the test program for details.

The assert command
------------------

The <assert> command tests a condition and aborts the script if the condition is
false.

    <assert
        name = "variablename"
      [ test = "eq | ne | gt | lt | ge | le" ]
      [ value = "testvalue" ]
        >[line of text]</assert>

 - The variablename is a script variable, or a connection or session
   property, or a standard PAL variable.

 - If the test and value are not specified, they default to "ne" and
   "0" or "" depending on the type of variable.

 - If just the test is not specified, it defaults to "eq".

 - If the assert statement includes a message, this is printed before
   an assertion failure.

The repeat command
------------------

The <repeat> command defines an iterative loop, which can run forever or for a
specified number of times. The counter is global (do not use the same counter
for two nested loops). To access the counter within the repeat loop, use
$variablename.

    <repeat
      [ counter = "variablename" ]
      [ times = "integer" ]
      [ progress = "integer" ]
        >
        [ script command ]...
    </repeat>

 - If the times attribute is not specified, the loop will run forever
   or until the script does a <break/>.

 - The counter does not need to be previously defined. If no counter
   is specified, the repeat loop will create its own internal counter
   which cannot then be used as a symbolic value.

 - If the progress option is set to an integer N, then after every N
   passes through the loop, the test script will print a dot to the
   standard error output.

The while command
-----------------

The <while> command defines a conditional loop, which runs so long as a
specified condition is true:

    <while
        name = "variablename"
      [ test = "eq | ne | gt | lt | ge | le" ]
      [ value = "testvalue" ]
      [ counter = "variablename" ]
      [ progress = "integer" ]
        >
        [ script command ]...
    </while>

 - See the <assert> command for an explanation of the test and value
   properties.

 - If a counter is specified, this variable is automatically set to
   zero when the while loop starts and incremented each time the loop
   runs.  You can access the counter variable after the while loop.

 - If the progress option is set to an integer N, then after every N
   passes through the loop, the test script will print a dot to the
   standard error output.

The break command
-----------------

The <break> command exits the enveloping repeat or while loop and has this
syntax:

    <break/>
    
The if command
--------------

The <if> command defines a block that is executed if a specific condition
is true:

    <if
        name = "variablename"
      [ test = "eq | ne | gt | lt | ge | le" ]
      [ value = "testvalue" ]
        >
        [ script command ]...
    </if>

 - See the <assert> command for an explanation of the test and value
   properties.

The else command
----------------

The <else> command defines a block that is executed if the previous <if>
condition was false:

    <else>
        [ script command ]...
    </else>

The elsif command
-----------------

The <elsif> command defines a block that is executed if the previous <if>
condition was false and some further condition is true:

    <elsif
        name = "variablename"
      [ test = "eq | ne | gt | lt | ge | le" ]
      [ value = "testvalue" ]
        >
        [ script command ]...
    </elsif>

 - See the <assert> command for an explanation of the test and value
   properties.

The wait command
----------------

The <wait> command pauses the script for a number of milliseconds, or until
content is received from the server:

    <wait
      [ timeout = "milliseconds" ]
        />

 - Inside a session the default timeout is 'forever'.  Outside a session,
   the default timeout is 'zero'.
   
Here is an example of using the <wait> command:

    <?xml?>
    <pal script = "amq_pal_gen">
        <set name = "index" value = "0" />
        <echo>Waiting without an active connection...</echo>
        <wait timeout = "1000" />
        <session>
            <echo>Waiting inside an active connection...</echo>
            <wait timeout = "1000" />
        </session>
        <echo>OK</echo>
    </pal>

The abort command
-----------------

The <abort> command echoes a line of text and halts the script.

    <abort>line of text</abort>

 - The text can use variables with the syntax: $variablename.

The exit command
----------------

The <exit> command halts the script.

    <exit [status = "value"] >

 - The default status value is 0.

PAL variables
=============

PAL uses the convention '$name' to allow variable substitution. This is allowed
in:

 - The body of <echo> and <abort> commands.
 - All attributes except variablenames.

PAL defines all connection and session properties as variables. These are the
connection properties:

 -  channel_max - proposed maximum channels.
 -  class_id - failing method class.
 -  frame_max - proposed maximum frame size.
 -  heartbeat - desired heartbeat delay.
 -  host - server to connect to.
 -  known_hosts - list of known hosts.
 -  method_id - failing method ID.
 -  reply_code - reply code from server.
 -  reply_text - localised reply text.
 -  server_copyright - server copyright.
 -  server_host - server hostname and port.
 -  server_information - other server information.
 -  server_platform - operating platform.
 -  server_product - name of server implementation.
 -  server_version - version of server.
 -  version_major - protocol major version.
 -  version_minor - protocol major version.

These are the session properties returned by various AMQP response methods:

 -  active - start/stop content frames.
 -  class_id - failing method class.
 -  cluster_id - Cluster id.
 -  consumer_count - number of consumers.
 -  consumer_tag - consumer tag.
 -  content_size - message content size.
 -  delivery_tag - server-assigned delivery tag.
 -  exchange - exchange name.
 -  identifier - staging identifier.
 -  message_count - number of messages in queue.
 -  method_id - failing method ID.
 -  queue - queue name.
 -  redelivered - message is being redelivered.
 -  reply_code - reply code from server.
 -  reply_text - localised reply text.
 -  routing_key - Message routing key.
 -  staged_size - already staged amount.
 -  ticket - access ticket granted by server.

Note that the standard ASL technique for returning values from protocol methods
is via the session properties. Thus the variable 'message_count' holds the
number of messages after a queue.browse request and a queue.browse-ok response.

PAL also defines these built-in variables:

  - $script - name of current PAL script.
  - $connection - 1 if the connection is alive, else 0.
  - $session - 1 if the session is alive, else 0.
  - $random - a random integer in the range 0..32767, when used as an
    insertion value, produces a 4-digit hex string.
  - $body_size - the body size of the last content to be created,
    arrived, or returned.

You must not name your own variables using any of the connection, session, or
built-in names. PAL resolves a variable reference in this order:

 1. First, in-built variables.
 2. Content properties, inside an arrived/returned loop.
 3. Session properties.
 4. Connection properties.
 5. Script variables and counters.

Here is a sample script that demonstrates various ways of using variables:

    <?xml?>
    <pal script = "amq_pal_gen">
        <set name = "expect_major"   value = "9" />
        <set name = "exchange_class" value = "fanout" />
        <set name = "queue"          value = "test-queue" />
        <set name = "exchange"       value = "test-exchange" />
        <set name = "times"          value = "100" />
        <set name = "size"           value = "64000" />
        <session
            queue    = "$queue"
            exchange = "$exchange"
            >
            <echo>Connected to $server_product/$server_version - $server_platform</echo>
            <assert name = "version_major" value = "$expect_major" />
            <exchange_declare class = "$exchange_class" />
            <queue_declare />
            <queue_bind />
            <repeat times = "$times" counter = "id">
              <basic_content size = "$size" content_type = "text/html" message_id = "id-$id" />
              <basic_publish routing_key = "$queue" />
            </repeat>
            <repeat>
                <basic_get />
                <basic_returned>
                    <echo>Returned: $message_id</echo>
                </basic_returned>
                <basic_arrived>
                    <inc name = "count" />
                    <echo>Arrived: $message_id</echo>
                </basic_arrived>
                <empty>
                    <break/>
                </empty>
            </repeat>
            <echo>Total number of messages exchanged: $count</echo>
        </session>
    </pal>

General syntax for protocol methods
===================================

A protocol method command sends a protocol method to the server. If the method
is a synchronous method, the script waits for a response from the server. If the
method is asynchronous, the script continues without waiting. The basic syntax
for protocol method commands is:

    <class_method [properties...]>
        <field_table_name>
          [ <field
                name = "fieldname"
              [ value = "fieldvalue" ]
              [ type = "string | integer"  ("string") ]
                /> ]...
        </field_table_name>
    </class_method>

Properties that are not specified take a default value, which is zero for
numeric properties, FALSE for Boolean properties, and NULL for strings and field
tables.

See the specification of each protocol command in the WireAPI documentation
above, or the AMQP specifications themselves, for details.

These are the protocol method commands you can use in a PAL script:

Exchange.Declare:

    <exchange_declare
        [ exchange = "exchange name" ]
        [ type = "exchange type" ]
        [ passive = "do not create exchange" ]
        [ auto_delete = "auto-delete when unused" ]
    />

Exchange.Delete:

    <exchange_delete
        [ exchange = "exchange name" ]
    />

Queue.Declare:

    <queue_declare
        [ queue = "queue name" ]
        [ passive = "do not create queue" ]
        [ exclusive = "request an exclusive queue" ]
        [ auto_delete = "auto-delete queue when unused" ]
    />

Queue.Bind:

    <queue_bind
        [ queue = "queue name" ]
        [ exchange = "exchange name" ]
        [ routing_key = "message routing key" ]
        >
        [ <arguments .../> ]
    />

Queue.Unbind:

    <queue_unbind
        [ queue = "..." ]
        [ exchange = "..." ]
        [ routing_key = "..." ]
        >
        [ <arguments .../> ]
    </queue_unbind>

Queue.Purge:

    <queue_purge
        [ queue = "queue name" ]
    />

Queue.Delete:

    <queue_delete
        [ queue = "queue name" ]
    />


Basic.Consume:

    <basic_consume
        [ queue = "queue name" ]
        [ consumer_tag = "consumer tag" ]
        [ no_local = "do not deliver own messages" ]
        [ exclusive = "request exclusive access" ]
    />

Basic.Cancel:
    
    <basic_cancel
        [ consumer_tag = "consumer tag" ]
    />

Basic.Publish:

    <basic_publish
        [ exchange = "exchange name" ]
        [ routing_key = "Message routing key" ]
        [ mandatory = "indicate mandatory routing" ]
        [ immediate = "request immediate delivery" ]
    />

Basic.Get:

    <basic_get
        [ queue = "queue name" ]
    />

Content manipulation
====================

Basic content commands
----------------------

PAL provides a command to create a basic content and set its properties. Only
one basic content is ever active.  If your script creates a content, that causes
any previously created content to be destroyed.  The syntax for the
<basic_content command is:

    <basic_content
      [ size = "bodysize"  ("1024") ]
      [ fill = "random | null | repeat"  ("random") ]
      [ read = "..." ]
      [ exec = "..." ]
      [ headers = "0|(1)" ]
      [ content_type = "propertyvalue" ]
      [ content_encoding = "propertyvalue" ]
      [ message_id = "propertyvalue" ]
        >
        [ <headers>
          [ <field
                name = "fieldname"
              [ value = "fieldvalue" ]
              [ type = "string | integer"  ("string") ]
                /> ]...
        </headers> ]
      [ content text ]
    </basic_content>

 - The size attribute specifies the size in octets of the content buffer.
   Its default value is "1024".

 - The fill attribute specifies the fill mode. It can be "random", which
   sets the body to random data, or "null", which sets it to binary zeroes,
   or "repeat", which repeats the content text up to the specified size.

 - The body of the content item optionally provides a content text.  If
   this is set, it's reformatted as a single line of text, and used as
   message body.  This overrides the default fill ('random').

 - The read attribute specifies a file from which to read the content
   body. This is useful when you want to send test messages with a specific
   format.

 - The exec attribute specifies a command to run, so that the stdout of
   the command can be used as the content body.  The command must be the
   name of an executable program, on the path, with arguments as desired.
   The program receives the current content body as stdin, much like a
   web server CGI program.

 - If the headers field is set to zero, the output of the executed
   program is not reparsed. If one, the output is reparsed to collect
   message properties and headers as follows: each line specifies a
   header field name, followed by ":", followed by a space and a value.
   Field names starting with "x-table-" are stored as-is (minus the
   x-table- prefix) in a field table with that name. Other fields must
   match known content properties. Hyphens are allowed in field names,
   and field names are case-insensitive.  The headers are ended with a
   blank line. Parsed headers create a CGI-like interface for calling
   programs.

 - For each content property defined in the protocol (except field tables)
   PAL defines an attribute for the content command.

 - For field tables, PAL defines a child entity with the same name, e.g.
   'headers'.  Field tables are then constructed from one or more <field>
   definitions.

 - After a content command, the script can access the content body size
   as a variables ($body_size in expressions, or body_size in assertions
   and conditions).

Processing arrived contents
---------------------------

The <basic_arrived> command lets your PAL program process incoming messages
delivered by the server. This command acts as a loop, and repeats for each
arrived content at the moment it is invoked.

    <basic_arrived
      [ counter = "variablename" ]
        >
        [ script command ]...
    </basic_arrived>
    <empty>
        [ script command ]...
    </empty>

 - If a counter is specified, this variable is automatically set to zero when 
   the loop starts and incremented each time the loop runs.  You can access the 
   counter variable after the loop.

 - If there was no arrived content, the script executes the following <empty>
   command, if any.

You can use these variables within an arrived loop:

 - $body_text - content body as printable text.
 - $body_size - the body size of the content.
 - $exchange - the exchange to which the content was published.
 - $routing_key - the original routing_key specified by the publisher.
 - $producer_id - the producer id of the publishing connection.
 - $content_type - MIME content type.
 - $content_encoding  - MIME content encoding.
 - $delivery_mode - non-persistent or persistent.
 - $priority - message priority, 0 to 9.
 - $correlation_id - application correlation identifier
 - $reply_to - the destination to reply to.
 - $expiration - expiration specification.
 - $message_id - the application message identifier.
 - $timestamp - message timestamp.
 - $type - message type name.
 - $user_id - creating user id.
 - $app_id - creating application id.
 - $sender_id - the sending application id.

Additionally, if the content contains header fields (in the 'headers' table),
these are made available as:

 - $header-fieldname - where 'fieldname' is the name of each field. 
 
Processing returned content
---------------------------

We process returned content in a similar way to arrived content:

    <basic_returned
      [ counter = "variablename" ]
        >
        [ script command ]...
    </basic_returned>
    <empty>
        [ script command ]...
    </empty>

 - If a counter is specified, this variable is automatically set to zero when 
   the loop starts and incremented each time the loop runs.  You can access the
   counter variable after the loop.

 - If there was no arrived content, the script executes the following <empty> 
   command, if any.

Synchronous content processing
------------------------------

PAL does not provide any asynchronous content processing. The script runs as a
single-threaded procedure from start to end. Content will arrive when the script
is busy, i.e. during any command that talks to the server. To process content
after such commands, use the 'arrived' commands. To process content while not
doing such commands, use <wait/> and then use the arrived command.

Nowait methods
==============

AMQP/0.9 has a "nowait" option on some methods that turn normally synchronous
methods into asynchronous ones.  This is important for applications that do very
large volumes of wiring (queue creation, etc.) since it can dramatically cut the
start-up time.

WireAPI implements nowait as a second set of methods:

 - <exchange_declare_nowait ... />
 - <exchange_delete_nowait ... />
 - <queue_declare_nowait ... />
 - <queue_bind_nowait ... />
 - <queue_purge_nowait ... />
 - <queue_delete_nowait ... />
 - <queue_unbind_nowait ... />
 - <basic_consume_nowait ... /> 
 - <basic_cancel_nowait ... />

Each of these methods takes the same arguments as their synchronous versions.

To use the nowait functionality on automatically-named queues (private exclusive
queues), you need to use the default queue functionality, i.e:

 - <queue_declare/> with no name (creates a name automatically)
 - <queue_bind/> with no name (uses the last created queue name)
 - <queue_consume/> with no name (uses the last used queue name)

Error handling
==============

Most PAL errors cause the script to stop.  The one exception is a connection
failure (meaning the server disappered unexpectedly): if the session failover
property is set, the script will try to failover to a backup server.

PAL implementations
===================

ANSI C implementation
---------------------

The standard C implementation creates a command-line program that accepts
these arguments:

    Syntax: program [options...]
    Options:
      -s server        Server:port to connect to (localhost)
      -t level         Set trace level (default = 0)
                       0=none, 1=low, 2=medium, 3=high
      -r count         Repeat script count times, 0=forever (1)
      -c               Clock the script (0)
      -a               Animate: show script commands
      -e               Execute in single-step mode (0)
      -q               Quiet mode: no messages
      -v               Show version information
      -h               Show summary of command-line options

    The order of arguments is not important. Switches and filenames
    are case sensitive. See documentation for detailed information.

Performance measurements
------------------------

The -c option clocks the script and produces performance measurement output.
Here is an example of a simple stress test script:

    <?xml?>
    <pal
        name = "stress"
        script = "amq_pal_gen"
        >
        This script sends a large number of messages to a queue and then
        reads them back.  The number of messages can be specified on the
        command-line.
        <session exchange = "myexchange" queue = "myqueue" >
            <set name = "number-of-messages" cmdline = "N" value = "1000" />
            <set name = "message-size" cmdline = "S" value = "1000" />
            <exchange_declare type = "fanout" />
            <queue_declare />
            <queue_bind />
            <repeat times = "$number-of-messages" counter = "index" progress = "100">
                <basic_content size = "$message-size" message_id = "id-$index" />
                <basic_publish routing_key = "myqueue" />
            </repeat>
            <while name = "arrived" test = "lt" value = "$number-of-messages" progress = "100">
                <basic_get />
                <basic_arrived>
                    <inc name = "arrived" />
                </basic_arrived>
            </while>
        </session>
    </pal>

Which produces this output (the figures are obviously just an example):

    ...........
    ...........
    16:41:26: I: elapsed time:781 msecs
    16:41:26: I: outgoing messages:1000 (976 Kbytes)
    16:41:26: I: incoming messages:1000 (976 Kbytes)
    16:41:26: I: total messages:2000 (1952 Kbytes) average:2560/sec (2499 Kbytes/sec)
    16:41:26: I: message latency min=280 max=410 mean=331 dev=37 msecs

Other implementations
---------------------

There are no other implementations of PAL at present.


