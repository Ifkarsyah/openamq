OpenAMQ Operator Console
************************

Goals of the Operator Console
=============================

To allow remote control of an OpenAMQ server, including:

 - monitoring of key objects (queues, etc.)
 - collection of status information (performance, statistics)
 - setting of watches (on queue size, etc.)

We want the operator console to have these features:

 - to be very rapid, even when many people are operating (different
   parts of) an OpenAMQ server.
   
 - to be portable to any desired user interface technology, including
   web, command-line, JMX, etc.

 - to provide access to all "operable" internals of the server, i.e.
   to any object that may be tuned, configured, or managed.

 - to hide all aspects of the server that are not "operable", i.e.
   any object that should not be touched or seen.

 - all messages are formally defined so that the necessary code and
   can documentation can be fully generated.

 - the operator console is stateless, with no concept of "session".
   All operations work directly on the live server.

 - the operator console may have the notion of transaction, in which
   an operation will be completed fully, or not at all.

Principles
==========

Uses AMQP Mechanisms
--------------------

The operator console is built using the AMQP protocol. The overall
architecture is:

    .------------.               .-----------.       .----------.
    |            | <- Request -- |  Console  |       |          |
    | AMQ Server | - Response -> | Interface | <===> |   GUI    |
    |            | --- Alert --> |  Client   |       |          |
    `------------'               `-----------'       `----------'

In the OpenAMQ server, requests are handled by a standard exchange, the
system exchange amq.system. Responses are sent to a temporary reply
queue created by the console interface layer.

Asynchronous information - alerts - are sent to the amq.system.alert
exchange, and console interface layer(s) get these alerts using a
pub/sub model. Alerts are published with a topic-style routing key that
allows selective subscription to specific types of alert.

Object Properties
-----------------

We define an object as:

 - belonging to a certain 'class' of objects.
 - having a unique identifier - see below.
 - having a set of named properties that can be inspected.
 - having a set of named properties that can be watched.
 - having a set of named properties that can be modified.

A watchable property is always inspectable. A modifiable property may or
may not be inspectable and/or watchable.

Watches
-------

A watch is a concept designed to let an operator monitor specific
objects without having to watch them constantly. Watches are set on
specific properties.

While the specifics of watch implementation depend on the server, we
assume a model like this:

 - watches are global and shared between all operators
 - a watch specifies some upper or lower limit for a property
 - the server will regularly check all watches on all objects
 - when a watch limit is crossed, the server will send an alert
   message to the amq.system.alert exchange using the watch routing
   key.
 - in order to receive a watch alert the operator console must have
   correctly subscribed to messages coming from amq.system.alert.

Watches have the same lifespan as the objects they are applied to.
That is, durable objects have durable watches.  Note that in the
current OpenAMQ server implementation, all objects are temporary,
and so are all watches.

Hierarchical Data View
----------------------

The operational model is a hierarchy of objects as follows:

    server
     :
     :-- vhost
     :
     :-- exchange
     :
     :-- queue
     :    :
     :    `-- consumer
     :
     `-- connection

These objects are:

 - server: the openamq server.  Server properties include the server IP
   address and port, number of connections, traffic statistics, etc.

 - vhost: each virtual host defined in the server.  Virtual host properties
   include the vhost path, number of connections, traffic statistics, etc.

 - exchange: each exchange defined in the virtual host.  Exchange properties
   include the exchange name, number of bindings, traffic statistics, etc.

 - queue: each queue defined in the virtual host.  Queue properties include
   the queue name, current size, maximum size, overflow limits, number of
   consumers, etc.

 - consumer: each consumer working with the queue.  A consumer refers to a
   connection.  Consumer properties cover the exchange 

 - connection: each active connection. A connection refers to a client IP
   address, and to a virtual host.  Connection properties include the time
   of connection, traffic statistics, number of errors, last error, etc.

XML-formatted Messages
----------------------

All messages between the Console Interface Client (CIC) and the server
are formatted using simple XML. We use a minimalistic XML syntax - no
stylesheets, namespaces, document types, etc.

We define two categories of message:

 1. Synchronous request-response messages in which the CIC makes a
    request and the server replies with a response.
 2. Asynchronous information messages provoked by events in the server,
    to which the CIC may subscribe.
    
These messages carry descriptions of a variety of objects (exchange,
queue, etc.) along with meta data.

Note: this document provides two alternate XML mappings for objects and
the meta data needed for various methods. The first mapping is simple
but introduces the possibility of name clashes between meta-data and
real data. The second mapping eliminates the possibility of clashes but
is a little more work to understand and use.

The Console Interface Language
------------------------------

We will define the CIL grammar to specify:

 - The general format of messages.
 - The set of inspectable objects and their organisation into a tree.
 - The inspectable properties of each object.
 - The modifiable properties of each object.
 - The monitorable properties of each object.
 - Any other synchronous methods that are allowed on each object,
   along with the request and response arguments for these methods.
   Note that 'inspect', 'modify', and 'monitor' are simply special
   cases of synchronous object methods.
 - The asynchronous methods that each object can produce.  Note that
   the 'alert' method is simply a special case of an asynchronous
   object method.

Object Identification
---------------------

Each object has a unique 64-bit identifier assigned by the server when
it creates the object. This identifier is used in all messages when
referring to an object.

By convention, ID 0 is reserved for the root object, namely the "server"
level.

Message Implementation
======================

Synchronous Method Model
------------------------

A synchronous method consists of one request from the CIC to the
server and one response from the server back to the CIC.

The general format of a request is:

    <request name = "methodname">
        [message arguments]
    </request>
    ----
    <otl request = "methodname">
        [message arguments]
    </otl>
    
The general format of a response is:

    <response name = "methodname">
        [message arguments]
    </response>
    ----
    <otl response = "methodname">
        [message arguments]
    </otl>

These are the standard synchronous methods we implement:

 - "inspect" - inspect a set of server objects.
 - "modify" - modify the properties of a set of server objects.
 - "monitor" - query or modify the watches on a set of objects.
 
Each request that the CIC sends results in exactly one response from the
server, with the same method name. We will probably define more methods,
especially on an object-by-object base as we progress with the operator
console implementation.

Asynchronous Method Model
-------------------------

An asynchronous method consists of one notify message from the CIC to
the server or vice-versa.

These are the standard asynchronous methods we implement:

 - "alert" - when a watched property has reached the specified value.

The 'Inspect' Method
--------------------

The 'inspect' method asks the server to provide a detailed description
of one or more objects:

    <request name = "inspect">
      [ <objectname id = "idvalue" expand = "0|1" /> ]...
    </request>
    ----
    <otl
        request = "inspect">
      [ <object name = "objectname" id = "idvalue" expand = "0|1" /> ]...
    </otl>

Where the 'expand' option (default 0) asks for a list of all child
objects. For example, to get the top-level server object and all its
children:

    <request name = "inspect">
        <server id = "0" expand = "1" />
    </request>
    ----
    <otl request = "inspect">
        <object name = "server" id = "0" expand = "1" />
    </otl>

The 'inspect' response provides details for a set of objects:

    <response name = "inspect">
      [ <objectname
            id = "idvalue"
            status = "ok|notfound|noaccess"
            children = "nbrchildren">
          [ <objectprop>objectpropvalue</objectprop> ]...
          [ <objectname ... /> ]...
        </objectname> ]...
    </response>
    ----
    <otl response = "inspect">
      [ <object
            name = "objectname"
            id = "idvalue"
            status = "ok|notfound|noaccess"
            children = "nbrofchildren>
          [ <field name = "objectprop">objectpropvalue</field> ]...
          [ <object name = "childname" id = "idvalue" /> ]...
        </object> ]...
    </otl>

For example, the inspect response for a freshly-started server instance
- with its default exchanges but no queues or connections - would be
something like:

    <response name = "inspect">
        <server id = "0" status = "ok" children = "32">
            <ipaddress>192.168.55.142</ipaddress>
            <port>7654</port>
            <connection_count>0</connection_count>
            <message_count>0</message_count>
            <octet_in_count>0</octet_in_count>
            <octet_out_count>0</octet_out_count>
            <exchange id = "1" />
            <exchange id = "2" />
            ...
            <exchange id = "n" />
        </server>
    </response>
    ----
    <otl response = "inspect">
        <object name = "server" id = "0" status = "ok" children = "32">
            <field name = "ipaddress">192.168.55.142</field>
            <field name = "port">7654</field>
            <field name = "connection_count">0</field>
            <field name = "message_count">0</field>
            <field name = "octet_in_count">0</field>
            <field name = "octet_out_count">0</field>
            <object name = "exchange" id = "1" />
            <object name = "exchange" id = "2" />
            ...
            <object name = "exchange" id = "n" />
        </object>
    </otl>
    
Note that the set of properties that the inspect method returns are
defined on a per-object basis later in this document.

The 'Modify' Method
-------------------

The 'modify' method asks the server to modify certain properties of one
or more specified objects:

    <request name = "modify">
      [ <objectname id = "idvalue">
          [ <objectprop>objectpropvalue</objectprop> ]...
        </objectname> ]...
    </request>
    ----
    <otl request = "modify">
      [ <object name = "objectname" id = "idvalue">
          [ <field name = "objectprop">objectpropvalue</field> ]...
        </object> ]...
    </otl>

The 'modify' response signals that whether the objects were modified
successfully or not:

    <response name = "modify">
      [ <objectname id = "idvalue" status = "ok|notfound|noaccess"> ]...
    </response >
    ----
    <otl response = "modify">
      [ <object
            name = "objectname"
            id = "idvalue"
            status = "ok|notfound|noaccess"> ]...
    </otl>

Note that the set of properties that can be modified are defined on
a per-object basis in the CIL specifications. 

The 'Monitor' Method
--------------------

The 'monitor' method asks the server to monitor certain properties of
one or more objects:

    <request name = "monitor">
      [ <objectname id = "idvalue" reset = "0|1">
          [ <objectprop
                watch = "watchtype"
                value = "watchvalue"
                alert = "alertmessage"
              [ route = "routingkey" ] /> ]...
        </objectname> ]...
    </request>
    ----
    <otl request = "monitor">
      [ <object name = "objectname" id = "idvalue" reset = "0|1">
          [ <field name = "objectprop">
              [ <watch
                    name  = "watchtype"
                    value = "watchvalue" 
                    alert = "alertmessage"
                  [ route = "routingkey" ] /> ]...
            </field> ]...
        </object> ]...
    </otl>

- The watchtypes are: eq, ne, lt, gt, le, ge, which correspond to the
  standard set of comparison operators. The watchvalue is a numeric
  value - only numeric and Boolean fields are monitorable.

- If the reset option is not specified, or is 0, the watches are added
  to those already present.  If the reset option is 1, the server will
  delete all existing watches before adding those specified (if any).

- Alerts are sent to the amq.system.alert exchange using the routing
  key, which defaults to "amq.<objectname>.<idvalue>".

The monitor reply lists all current watches for the specified object:

    <response name = "monitor">
      [ <objectname id = "idvalue">
          [ <objectprop
                watch = "watchtype"
                value = "watchvalue"
                alert = "alertmessage"
                route = "routingkey" /> ]...
        </objectname> ]...
    </request>
    ----
    <otl response = "monitor">
      [ <object name = "objectname" id = "idvalue">
          [ <watch
                name  = "watchtype"
                value = "watchvalue"
                alert = "alertmessage"
                route = "routingkey" /> ]...
        </object> ]...
    </otl>

The 'Alert' Method
-------------------

The 'alert' method tells the CIC that a watched property has reached
the specified value:

    <notify name = "alert">
        <objectname id = "idvalue">
            <objectprop alert = "alertmessage">objectpropvalue</objectprop>
        </objectname>
    </notify>
    ----
    <otl
        notify = "alert">
        <object name = "objectname" id = "idvalue">
            <field name = "objectprop" alert = "alertmessage">objectpropvalue</field>
        </object>
    </otl>

Message Transfer Protocol
=========================

Basic Content Class
-------------------

We will use the Basic content class, and these AMQP methods:

 - Basic.Publish
 - Basic.Consume
 - Basic.Deliver
 - Basic.Browse
 - Basic.Browse-Ok

Using the Basic content class means the operator console can be used in
AMQ servers that do not support JMS semantics but are built for file
transfer or content streaming. The Basic class is the only class that
all AMQ servers MUST support, according to the AMQP specifications.

Initialising a Console Session
------------------------------

Before sending methods to the server, the console interface layer - or
whatever application is acting as client - must create a temporary
private queue for replies:

 - Queue.Declare, no name, private = 1, auto-delete = 1.

It must then bind this queue to the amq.direct exchange:

 - Queue.Bind, queue=<provided name>, exchange=amq.direct,
   routing_key=<provided name>.

Sending a Method to The Server
------------------------------

The client sends a method to the server as follows:

 - The method is formatted as XML according to the specifications
   defined previously.
 - The client creates a Basic content containing this XML, and with
   the content type "text/xml".
 - The client sets the reply-to property to the name of its reply
   queue.  This name must not be encoded in any way.
 - The client sends this content to the amq.system exchange, using
   the Basic.Publish method and the routing_key "amq.console".
 - The client can then wait for a reply to arrive on its reply queue.

Subscribing to Alert Methods
----------------------------

The server sends alert methods to the amq.system.alert exchange,
which is a topic exchange.  It uses the routing key specified for
the watch.

Server Implementation
=====================

Operable Objects
----------------

We are concerned only with operable objects, those we can work with
via the operator console.

All operable objects are implemented as iCL asynchronous objects (using
the icl_smt framework). This ensures that objects can safely and
atomically process all methods they receive.

The inspect and modify methods are defined in an abstract iCL class that
uses GSL code generation - a type of templating - to produce the actual
code for each method instance.

Object Identification
---------------------

When an operable object is created (the new method), it takes a new
identification value. This will be done using a global 64-bit variable
that is atomically incremented.

Object Registry
---------------

The system exchange maintains a registry of all active operable objects.
This is a tree structure, held in memory, with each node consisting of:

 - A reference to the object.
 - A pointer to the parent node.
 - The object's ID value.
 - A linked list of child objects (mixed and unordered).
 - A pointer to a class descriptor.

The class descriptor defines a single object type, e.g. "queue", and has
these properties:

 - Short name of class, e.g. "queue".
 - Callback address of 'inspect' method.
 - Callback address of 'modify' method.
 
Class descriptors are created automatically when a specific class is
initialised - i.e. used for the first time. They never change during the
lifetime of the server.

The registry can do a lookup from object ID to registry node, so object
ID forms a primary key for accessing objects in the registry.

Object Registation
------------------

A new object registers by sending a "register" method to the system
exchange, which is an asynchronous object. The register method has these
arguments:

 - The ID of the new object.
 - The ID of the parent object.
 - The address of the corresponding class descriptor.

Object Deregistration
---------------------

The destroy method for an object sends a "cancel" method to the system
exchange. The cancel method has these arguments:

 - ID of object being destroyed

The 'Inspect' Method
--------------------

An inspect method can apply to several objects. When the system exchange
receives an inspect method, it decodes the XML to give a list of objects
to inspect. It sends a method to each object in turn, waiting for a
response. It collects these responses into a response XML and when it
has done each object, it sends the reply back to the client (using the
mechanism explained previously).

For simplicity, all XML encoding and decoding is done in the system
exchange only.  Data is passed between the system exchange and objects
in the form of field tables (the asl_field_list class).

The 'Modify' Method
-------------------

A modify method can apply changes to several objects. The system
exchange decodes the XML, and sends a modify method to each affected
object. It constructs a response and sends this back to the client.

The 'Monitor' Method
--------------------

The system exchange is responsible for monitoring watches.  It does
this by maintaining a list of watches and checking each one after
some regular interval - e.g. every 30 seconds.  It asks the watched
object to provide its properties ("inspect"), checks the properties
and if they hit the watch limit, sends an alert.

Once watch has provoked an alert, the system exchange will suppress
successive alerts unless there is significant variance - e.g. 5%.




