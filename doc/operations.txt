gdl
    title     = The OpenAMQ Console
    subtitle  = Operator Control for OpenAMQ Servers
    product   = OpenAMQ
    author    = iMatix Corporation <amq@imatix.com>
    date      = 2005/10/14
    copyright = Copyright (c) 2004-2005 JPMorgan
    version   = 1.0b
end gdl

OpenAMQ Console
***************

Summary
=======

Goals
-----

The OpenAMQ console is designed to allow remote configuration, control
and management of an OpenAMQ server, including:

 - Server and virtual host configuration.
 - Security configuration (authentication and access controls).
 - Monitoring of key entities (queues, etc.)
 - Collection of status information (performance, statistics)
 - Setting of watches (on queue size, etc.)
 - Administrative actions (purge queue, disconnect connection, etc.)

We want the console to have these features:

 - To be very rapid, even when many people are operating (different
   parts of) an OpenAMQ server.  The speed of reaction of the console
   is a very important part of its functionality.

 - To be portable to any desired user interface technology, including
   web, command-line, JMX, etc.  Ideally, end-users should be able to
   make customised operator interfaces, scripts, etc.  We want the
   console to be user-extensible.

 - To provide access to all "operable" internals of the server, i.e.
   to any object that may be tuned, configured, or managed.

 - To hide all aspects of the server that are not "operable", i.e.
   any object that should not be touched or seen.  The operator must
   not be able to cause harm by misuse of the console.

 - To have no significant impact on server performance or stability
   even when heavily used.  The console must be non-intrusive, and
   wholly safe.

 - Eventually, to be transactional, so that operations are completed
   fully, or not at all.

We want the console implementation to be:

 - Easily extensible as we extend its scope to cover more aspects of
   the OpenAMQ server.

 - Generic, so that the same console clients can work with arbitrary
   AMQ server implementations.

To achieve this, we will use certain abstractions.  Mainly, we will
not define any specific data model, but provide mechanisms for the
server to tell the client, "this is the data model I support".

Version 1
---------

This is a preliminary design.  We expect that the console will evolve
considerably.  The goal of this version is to provide the minimum needed
functionality in the simplest possible way.

General Console Architecture
============================

Server and Client Layers
------------------------

The console is built using the AMQP protocol.  That is, the server does
not export any user interface, but rather an API on top of which arbitrary
user interfaces can be built.  The simplest architecture is this:

    OpenAMQ Server           GUI or cmdline
    .-----------.             .-----------.
    |           |             |           |
    |  Console  | <==AMQP==>  |  Console  |
    |  Server   |             |  Client   |
    |           |             |           |
    `-----------'             `-----------'

Where the console client is responsible for the user interface -
command line or GUI.  A more sophisticated architecture uses a console
standard such as JMX so that it is easy to write arbitrary operator
applications:

    OpenAMQ Server               Proxy               GUI or cmdline
    .-----------.             .-----------.           .----------.
    |           |             |           |           |          |
    |  Console  | <==AMQP==>  |  Console  | <==JMX==> | Operator |
    |  Server   |             |  Client   |           |   Appl   |
    |           |             |           |           |          |
    `-----------'             `-----------'           `----------'

 - The console consists of a server component and a client component.

 - The console server is an application that is embedded into the
   OpenAMQ server.

 - The console client is an application written in an arbitrary
   language.

 - The console client and server communicate using AMQP.

The Server Schema
-----------------

The console works on a set of entities we call "objects".  In many
cases the console objects will match internal server objects, but this
is not mandatory.

Note: it is tiresome to use different terms for the definition of an
object, and an instance of an object.  When I say, "the model X coffee
machine can produce twenty cups of espresso per minute", it is clear
I am talking about the whole class of model X coffee machines.  When
I say, "the model X coffee machine on the third floor is broken", it
is clear I am talking about one specific instance.  So, we use the term
"object" to mean both the whole class of a certain type of object,
and a specific object instance of that class.

The collection of objects that the server supports is its "schema".

Every AMQ server can implement its own schema, and this is critical
to making a useful console - depending on the server implementation,
or configuration, we need different schemas.  It is not useful to
assume that all console clients know all schemas in advance.

The minimal server schema consists of exactly one object:

    server

All AMQ servers will support this schema, and all console clients will
assume it.  Note that this object is both the class and instance: there
will be exactly one server object for a running server.

The server can then extend the schema by adding arbitrary objects to
it:

    server
     :
     (arbitrary objects)

Objects can include objects, so we can build schemas like this:

    server
     :
     :-- vhost
     :    :
     :    :-- exchange
     :    :
     :    `-- queue
     :        :
     :        `-- consumer
     :
     `-- connection

Which represents the operable core of an OpenAMQ/0.9 server.  Note that
this schema is an example: the actual server schema is probably larger
and more complex.

Object Definition
-----------------

An object is defined as follows:

 - The object has a class name, e.g. "server", unique within the schema.
 - The object instance has a server-wide unique identifier.
 - The object has a set of 'views', which are sets of properties.
 - The object has a set of child objects.

Object views are composed of sets of fields, each defined as follows:

 - The field has a name.
 - The field has a type, explained later.
 - If the field is enumerated, it has a set of named values.
 - The field has a prompt, used to construct a user interface.
 - The field has a description, used to construct a user interface.

Standard Views
--------------

All objects have these two standard views:

 - "inspect" - containing the object fields that may be shown to the operator.
 - "modify" - containing the object fields that the operator may change.

Other views can be defined on an object-by-object basis.

Object Commands
---------------

All objects support these standard commands:

 - "meta" - returns the description of a specified object class.
 - "inspect" - returns an inspect view for a specified object.
 - "modify" - applies a modify view to a specified object.
 - "watch" - sets watches on fields from an object's inspect view.

We will extend the API with other commands at a later stage.

Object Identification
---------------------

Each object has a unique 64-bit identifier assigned by the server when it
creates the object. This identifier is used in all messages when referring
to an object.

By convention, ID 0 is reserved for the root object, "server".  This is
the only object that is guaranteed to be present in all server schemas.

The Console API
===============

General Design
--------------

The console API consists of two pieces:

 - Execute a command on a given object.  This consists of a request from
   the client to the server, and a reply back from the server to the client.

 - Notifications from the server.  These are sent asynchronously using the
   AMQP topic routing mechanisms.

The console uses the Basic content class, and these AMQP methods:

 - Basic.Publish
 - Basic.Consume and Basic.Deliver
 - Basic.Browse and Basic.Browse-Ok / Browse-Empty.

By using the Basic content class we ensure that the console works with all
future AMQ servers.  The Basic class is the only class that all AMQ servers
MUST support, according to the AMQP specifications.

The request-reply mechanism uses standard queues as follows:

 - Each client creates a temporary reply queue and binds this as usual
   for a reply queue.
 - Each request to the server specifies this queue in the "reply-to" field.

To implement a request-reply method, the client will:

 - Create a suitably-formatted message.
 - Set the reply-to field correctly to refer to its reply queue.
 - Use the Basic.Publish method to send the message to the amq.console
   exchange.
 - Wait for a reply on its reply queue.

The notification mechanism uses topic routing and subscription queues as
follows:

 - Each client wishing to receive notifications creates a temporary queue
   and binds this to the amq.console.notify exchange (a topic exchange).
 - The routing key used during binding specifies which notifications the
   client wishes to receive.
 - The client can bind the same queue many times with different routing
   keys.
 - The client can use the same queue both for replies and notifications.

Console Message Language
------------------------

All messages between the console client and the server are formatted using
an XML language we call "CML", the Console Message Language.  CML uses a
minimalistic XML syntax - no stylesheets, namespaces, document types, etc.

Here are some examples of CML:

    <cml version = "1.0">
        <meta class = "server" />
    </cml>

    <cml version = "1.0">
        <inspect object = "0" />
    </cml>

    <cml version = "1.0">
        <modify object = "0">
            <field name = "shutdown">1</field>
        </modify>
    </cml>

CML has a grammar that covers all possible server schemas:

    cml-command   = C:meta    S:meta
                  | C:inspect S:inspect
                  | C:modify  S:modify
                  | C:watch   S:watch

    C:meta        = <meta class = "class-name" />

    class-name    = valid-name

    valid-name    = {A-Za-z0-9-_.}...

    S:meta        = <meta class = "class-name">
                      [ view-meta ]...
                    </meta>

    view-meta     = <view name = "view-name">
                      [ field-meta ] ...
                    </view>

    view-name     = inspect | modify

    field-meta    = <field name = "field-name" type = "field-type"
                        prompt = "field-prompt">
                        field-text
                      [ enum-value ] ...
                    </field>

    field-name    = valid-name

    field-type    = string | int | bool | enum | action | object

    field-prompt  = valid-text

    valid-text    = {printable}...

    enum-value    = <value name = "value-name">field-value</value>

    value-name    = valid-text

    field-value   = string representation of allowed field value

    C:inspect     = <inspect object = "object-id" detail = "0|1" />

    object-id     = 0..maxlongint-1

    S:inspect     = <inspect object = "object-id" status = "object-status">
                      [ field-data ]...
                      [ object-data ]...
                    </inspect>

    object-status = ok | notfound | noaccess

    field-data    = <field name = "field-name">field-value</field>

    object-data   = <object class = "class-name" id = "object-id" />

    C:modify      = <modify object = "object-id">
                      [ field-data ] ...
                    </modify>

    S:modify      = <modify object = "object-id" status = "object-status" />

    C:watch       = <watch object = "object-id">
                      [ watch-field ]...
                    </watch>

    watch-field   = <field
                        name  = "field-name"
                        test  = "watch-type"
                        value = "watch-value"
                        alert = "alert-message"
                        route = "routing-key"
                        />

    watch-type    = eq | ne | lt | le | gt | ge

    watch

    S:watch       = <watch object = "object-id" status = "object-status">

                    </watch>


Field Types
-----------

string | int | bool | enum | action | object


The 'Meta' Command
------------------

The client may start a new session by doing a series of 'meta' commands
to get the server schema.  It first does 'meta' on the "server" object,
then repeats this for all child objects until the schema is completely
analysed.  It then uses the schema to generate user-interface screens,
JMX interfaces, command-line prompts, etc.

[Author's note: hopefully JMX allows its interfaces to be generated on
the fly...]

Here is an example of a 'meta' command request from client to server:

    <cml version = "1.0">
        <meta object = "vhost" />
    </cml>

And an example of the reply, which lists the methods and child objects
that make up the specified object:

    <cml version = "1.0">
        <meta object = "vhost">
            <method name = "inspect">
                <reply>
                    <field name = "path" type = "string" prompt = "Virtual host path">
                    The virtual host path is used to select the virtual host. The
                    default path is "/".
                    </field>
                    <field name = "locked" type = "boolean" prompt = "Locked down?">
                    When locked down, a virtual host cannot be used by applications.
                    </field>
                    <field name = "queues" type = "integer" prompt = "Number of queues">
                    Reports the number of queues currently defined for the virtual host.
                    </field>
                </reply>
            </method>
            <method name = "modify">
                <reply>
                    <field name = "locked" type = "boolean" prompt = "Locked down?">
                    When locked down, a virtual host cannot be used by applications.
                    </field>
                </reply>
            </method>
            <method name = "monitor">
                <request>

                </request>
                <reply>
                </reply>
            </method>
            <object name = "queue" />
            <object name = "exchange" />
        </meta>
    </cml>



We use a simple set of tags:

    <cml>
        <object>
            <field>

Where objects can contain other objects and fields.  Here is an example of an OTL message that shows metadata (object IDs and status),
object properties, and child objects:

    <cml name = "inspect">
        <object name = "server" id = "0" status = "ok">
            <field name = "ipaddress">192.168.55.62</field>
            <field name = "port">7654</field>
            <field name = "message count">0</field>
            <field name = "connection count">0</field>
            <field name = "octet in count">0</field>
            <field name = "octet out count">0</field>
            <object name = "exchange" id = "1">
                <field name = "name">amq.direct</field>
            </object>
            <object name = "exchange" id = "2">
                <field name = "name">amq.topic</field>
            </object>
            <object name = "exchange" id = "3">
                <field name = "name">amq.system</field>
            </object>
            <object name = "exchange" id = "4">
                <field name = "name">amq.system.alert</field>
            </object>
        </object>
    </cml>







Watches
-------

A watch is a concept designed to let an operator monitor specific
objects without having to watch them constantly. Watches are set on
specific properties of specific objects.  I.e. if you want to watch
the size of two different queues, this requires two watches.

While the specifics of watch implementation depend on the server, we
assume a model like this:

 - Watches are global to an OpenAMQ server.

 - A watch specifies some upper or lower limit for a property.

 - The console server will regularly check all watches.

 - When a watch limit is crossed, the console will send an alert
   message to the amq.console.alert exchange using the watch routing
   key.

 - All correctly-subscribed clients can receive these alerts.

Watches have the same lifespan as the objects they are applied to.
That is, durable objects have durable watches.  Note that in the
current OpenAMQ server implementation, all objects are temporary,
and so all watches are also temporary.


Message Implementation
======================

Synchronous Method Model
------------------------

A synchronous method consists of one request from the console client to the
server and one reply from the server back to the console client.

The general format of a request is:

    <cml request = "methodname">
        [message fields]
    </cml>

The general format of a reply is:

    <cml reply = "methodname">
        [message arguments]
    </cml>

These are the standard synchronous methods we implement:

 - "inspect" - inspect a set of server objects.
 - "modify" - modify the properties of a set of server objects.
 - "monitor" - query or modify the watches on a set of objects.

Each request that the console client sends results in exactly one reply from the
server, with the same method name. We will probably define more methods,
especially on an object-by-object base as we progress with the operator
console implementation.

Asynchronous Method Model
-------------------------

An asynchronous method consists of one notify message from the console client to
the server or vice-versa.

These are the standard asynchronous methods we implement:

 - "alert" - when a watched property has reached the specified value.

The 'Inspect' Method
--------------------

The 'inspect' method asks the server to provide a detailed description
of one or more objects:

    <cml
        request = "inspect">
      [ <object name = "objectname" id = "idvalue" expand = "0|1" /> ]...
    </cml>

Where the 'expand' option (default 0) asks for a list of all child
objects. For example, to get the top-level server object and all its
children:

    <cml request = "inspect">
        <object name = "server" id = "0" expand = "1" />
    </cml>

The 'inspect' reply provides details for a set of objects:

    <cml reply = "inspect">
      [ <object
            name = "objectname"
            id = "idvalue"
            status = "ok|notfound|noaccess"
            children = "nbrofchildren>
          [ <field name = "objectprop">objectpropvalue</field> ]...
          [ <object name = "childname" id = "idvalue" /> ]...
        </object> ]...
    </cml>

For example, the inspect reply for a freshly-started server instance
- with its default exchanges but no queues or connections - would be
something like:

    <cml reply = "inspect">
        <object name = "server" id = "0" status = "ok" children = "32">
            <field name = "ipaddress">192.168.55.142</field>
            <field name = "port">7654</field>
            <field name = "connection_count">0</field>
            <field name = "message_count">0</field>
            <field name = "octet_in_count">0</field>
            <field name = "octet_out_count">0</field>
            <object name = "exchange" id = "1" />
            <object name = "exchange" id = "2" />
            ...
            <object name = "exchange" id = "n" />
        </object>
    </cml>
    
Note that the set of properties that the inspect method returns are
defined on a per-object basis later in this document.

The 'Modify' Method
-------------------

The 'modify' method asks the server to modify certain properties of one
or more specified objects:

    <cml request = "modify">
      [ <object name = "objectname" id = "idvalue">
          [ <field name = "objectprop">objectpropvalue</field> ]...
        </object> ]...
    </cml>

The 'modify' reply signals that whether the objects were modified
successfully or not:

    <cml reply = "modify">
      [ <object
            name = "objectname"
            id = "idvalue"
            status = "ok|notfound|noaccess"> ]...
    </cml>

Note that the set of properties that can be modified are defined on
a per-object basis in the CIL specifications. 

The 'Monitor' Method
--------------------

The 'monitor' method asks the server to monitor certain properties of
one or more objects:

    <cml request = "monitor">
      [ <object name = "objectname" id = "idvalue" reset = "0|1">
          [ <field name = "objectprop">
              [ <watch
                    name  = "watchtype"
                    value = "watchvalue"
                    alert = "alertmessage"
                  [ route = "routingkey" ] /> ]...
            </field> ]...
        </object> ]...
    </cml>

- The watchtypes are: eq, ne, lt, gt, le, ge, which correspond to the
  standard set of comparison operators. The watchvalue is a numeric
  value - only numeric and Boolean fields are monitorable.

- If the reset option is not specified, or is 0, the watches are added
  to those already present.  If the reset option is 1, the server will
  delete all existing watches before adding those specified (if any).

- Alerts are sent to the amq.console.alert exchange using the routing
  key, which defaults to "amq.<objectname>.<idvalue>".

The monitor reply lists all current watches for the specified object:

    <cml reply = "monitor">
      [ <object name = "objectname" id = "idvalue">
          [ <watch
                name  = "watchtype"
                value = "watchvalue"
                alert = "alertmessage"
                route = "routingkey" /> ]...
        </object> ]...
    </cml>

The 'Alert' Method
-------------------

The 'alert' method tells the console client that a watched property has reached
the specified value:

    <cml
        notify = "alert">
        <object name = "objectname" id = "idvalue">
            <field name = "objectprop" alert = "alertmessage">objectpropvalue</field>
        </object>
    </cml>

Message Transfer Protocol
=========================

Server Implementation
=====================

Operable Objects
----------------

We are concerned only with operable objects, those we can work with
via the operator console.

All operable objects are implemented as iCL asynchronous objects (using
the icl_smt framework). This ensures that objects can safely and
atomically process all methods they receive.

The inspect and modify methods are defined in an abstract iCL class that
uses GSL code generation - a type of templating - to produce the actual
code for each method instance.

Object Identification
---------------------

When an operable object is created (the new method), it takes a new
identification value. This will be done using a global 64-bit variable
that is atomically incremented.

Object Registry
---------------

The system exchange maintains a registry of all active operable objects.
This is a tree structure, held in memory, with each node consisting of:

 - A reference to the object.
 - A pointer to the parent node.
 - The object's ID value.
 - A linked list of child objects (mixed and unordered).
 - A pointer to a class descriptor.

The class descriptor defines a single object type, e.g. "queue", and has
these properties:

 - Short name of class, e.g. "queue".
 - Callback address of 'inspect' method.
 - Callback address of 'modify' method.
 
Class descriptors are created automatically when a specific class is
initialised - i.e. used for the first time. They never change during the
lifetime of the server.

The registry can do a lookup from object ID to registry node, so object
ID forms a primary key for accessing objects in the registry.

Object Registation
------------------

A new object registers by sending a "register" method to the system
exchange, which is an asynchronous object. The register method has these
arguments:

 - The ID of the new object.
 - The ID of the parent object.
 - The address of the corresponding class descriptor.

Object Deregistration
---------------------

The destroy method for an object sends a "cancel" method to the system
exchange. The cancel method has these arguments:

 - ID of object being destroyed

The 'Inspect' Method
--------------------

An inspect method can apply to several objects. When the system exchange
receives an inspect method, it decodes the XML to give a list of objects
to inspect. It sends a method to each object in turn, waiting for a
reply. It collects these replis into a reply XML and when it
has done each object, it sends the reply back to the client (using the
mechanism explained previously).

For simplicity, all XML encoding and decoding is done in the system
exchange only.  Data is passed between the system exchange and objects
in the form of field tables (the asl_field_list class).

The 'Modify' Method
-------------------

A modify method can apply changes to several objects. The system
exchange decodes the XML, and sends a modify method to each affected
object. It constructs a reply and sends this back to the client.

The 'Monitor' Method
--------------------

The system exchange is responsible for monitoring watches.  It does
this by maintaining a list of watches and checking each one after
some regular interval - e.g. every 30 seconds.  It asks the watched
object to provide its properties ("inspect"), checks the properties
and if they hit the watch limit, sends an alert.

Once watch has provoked an alert, the system exchange will suppress
successive alerts unless there is significant variance - e.g. 5%.




In the OpenAMQ server, requests are handled by the standard system
exchange "amq.console". Responses are sent to a temporary reply queue
created by the console interface layer.

Asynchronous information - alerts - are sent to the amq.console.alert
exchange, and console interface layer(s) get these alerts using a
pub/sub model. Alerts are published with a topic-style routing key that
allows selective subscription to specific types of alert.



Before sending methods to the server, the client creates a temporary private
queue for replies:

 - Queue.Declare, no name, private = 1, auto-delete = 1.

It then binds this queue to the amq.direct exchange:

 - Queue.Bind, queue=<provided name>, exchange=amq.direct,
   routing_key=<provided name>.

