gdl
    title     = OpenAMQ Console
    subtitle  = Operator Control for OpenAMQ Servers
    product   = OpenAMQ
    author    = iMatix Corporation <amq@imatix.com>
    date      = 2005/10/14
    copyright = Copyright (c) 2004-2005 JPMorgan
    version   = 1.0b
end gdl

OpenAMQ Console
***************

Summary
=======

Goals
-----

The OpenAMQ console is designed to allow remote configuration, control
and management of an OpenAMQ server, including:

 - Server and virtual host configuration.
 - Security configuration (authentication and access controls).
 - Monitoring of key entities (queues, etc.)
 - Collection of status information (performance, statistics)
 - Setting of watches (on queue size, etc.)
 - Administrative actions (purge queue, disconnect connection, etc.)

We want the console to have these features:

 - To be very rapid, even when many people are operating (different
   parts of) an OpenAMQ server.  The speed of reaction of the console
   is a very important part of its functionality.

 - To be portable to any desired user interface technology, including
   web, command-line, JMX, etc.  Ideally, end-users should be able to
   make customised operator interfaces, scripts, etc.  We want the
   console to be user-extensible.

 - To provide access to all "operable" internals of the server, i.e.
   to any object that may be tuned, configured, or managed.

 - To hide all aspects of the server that are not "operable", i.e.
   any object that should not be touched or seen.  The operator must
   not be able to cause harm by misuse of the console.

 - To have no significant impact on server performance or stability
   even when heavily used.  The console must be non-intrusive, and
   wholly safe.

 - Eventually, to be transactional, so that operations are completed
   fully, or not at all.

We want the console implementation to be:

 - Easily extensible as we extend its scope to cover more aspects of
   the OpenAMQ server.

 - Generic, so that the same console clients can work with arbitrary
   AMQ server implementations.

To achieve this, we will use certain abstractions.  Mainly, we will
not define any specific data model, but provide mechanisms for the
server to tell the client, "this is the data model I support".

Version 1
---------

This is a preliminary design.  We expect that the console will evolve
considerably.  The goal of this version is to provide the minimum needed
functionality in the simplest possible way.

General Console Architecture
============================

Server and Client Layers
------------------------

The console is built using the AMQP protocol.  That is, the server does
not export any user interface, but rather an API on top of which arbitrary
user interfaces can be built.  The simplest architecture is this:

    OpenAMQ Server           GUI or cmdline
    .-----------.             .-----------.
    |           |             |           |
    |  Console  | <==AMQP==>  |  Console  |
    |  Server   |             |  Client   |
    |           |             |           |
    `-----------'             `-----------'

Where the console client is responsible for the user interface -
command line or GUI.  A more sophisticated architecture uses a console
standard such as JMX so that it is easy to write arbitrary operator
applications:

    OpenAMQ Server               Proxy               GUI or cmdline
    .-----------.             .-----------.           .----------.
    |           |             |           |           |          |
    |  Console  | <==AMQP==>  |  Console  | <==JMX==> | Operator |
    |  Server   |             |  Client   |           |   Appl   |
    |           |             |           |           |          |
    `-----------'             `-----------'           `----------'

 - The console consists of a server component and a client component.

 - The console server is an application that is embedded into the
   OpenAMQ server.

 - The console client is an application written in an arbitrary
   language.

 - The console client and server communicate using AMQP.

The Server Schema
-----------------

The console works on a set of entities we call "objects".  In many
cases the console objects will match internal server objects, but this
is not mandatory.

Note: it is tiresome to use different terms for the definition of an
object, and an instance of an object.  When I say, "the model X coffee
machine can produce twenty cups of espresso per minute", it is clear
I am talking about the whole class of model X coffee machines.  When
I say, "the model X coffee machine on the third floor is broken", it
is clear I am talking about one specific instance.  So, we use the term
"object" to mean both the whole class of a certain type of object,
and a specific object instance of that class.

The collection of objects that the server supports is its "schema".

Every AMQ server can implement its own schema, and this is critical
to making a useful console - depending on the server implementation,
or configuration, we need different schemas.  It is not useful to
assume that all console clients know all schemas in advance.

The minimal server schema consists of one object:

    server

All AMQ servers will support this schema, and all console clients will
assume it.  Note that this object is both the class and instance: there
will be exactly one server object for a running server.

The server can then extend the schema by adding arbitrary objects to
it:

    server
     :
     (arbitrary objects)

Objects can include objects, so we can build schemas like this:

    server
     :
     :-- vhost
     :
     :-- exchange
     :
     :-- queue
     :    :
     :    `-- consumer
     :
     `-- connection

Which represents the operable core of an OpenAMQ/0.9 server.  Note that
this schema is an example: the actual server schema is probably larger
and more complex.

Object Definition
-----------------

An object is defined as follows:

 - It has a class name, e.g. "server", unique within the schema.

 - Each object instance has a server-wide unique identifier.

 - The object supports a set of synchronous methods, which we explain below.

 - The object has a set of child objects.

An object method consists of a request from client to server and a reply
from server to client.  Each object method is defined as follows:

 - It has a name, unique within the object.

 - It has a set of request arguments.

 - It has a set of reply arguments.

 - It has a description, used to construct a user interface.

Objects do not have any operable properties as such.  All data about
objects and changes made to objects are carried as methods between the
client and the server.

Each method argument is defined as follows:

 - It has a name.

 - It has a type: string, integer, time, Boolean, enumerated, or object.

 - If an enumerated property, it has a set of named values.

 - It has a prompt, used to construct a user interface.

 - It has a description, used to construct a user interface.

Object Identification
---------------------

Each object has a unique 64-bit identifier assigned by the server when it
creates the object. This identifier is used in all messages when referring
to an object.

By convention, ID 0 is reserved for the root object, which is the "server".

This is the only object that is guranteed to be present in all server
schemas.

The Console API
===============

General Design
--------------

The console API consists of three pieces:

 - Get the structure of an object (class).  This consists of a request from
   the client to the server, with a reply back from the server to the
   client.

 - Execute a method on a given object.  This consists of a request from the
   client to the server, with a reply back from the server to the client.

 - Notifications from the server.  These are sent asynchronously using the
   AMQP topic routing mechanisms.

The console uses the Basic content class, and these AMQP methods:

 - Basic.Publish
 - Basic.Consume and Basic.Deliver
 - Basic.Browse and Basic.Browse-Ok / Browse-Empty.

By using the Basic content class we ensure that the console works with all
future AMQ servers.  The Basic class is the only class that all AMQ servers
MUST support, according to the AMQP specifications.

The request-reply mechanism uses standard queues as follows:

 - Each client creates a temporary reply queue and binds this as usual
   for a reply queue.

 - Each request to the server specifies this queue in the "reply-to" field.

To implement a request-reply method, the client must:

 - Create a suitably-formatted message.

 - Set the reply-to field correctly to refer to its reply queue.

 - Use the Basic.Publish method to send the message to the amq.console
   exchange.

 - Wait for a reply on its reply queue.

The notification mechanism uses topic routing and subscription queues as
follows:

 - Each client wishing to receive notifications creates a temporary queue
   and binds this to the amq.console.notify exchange.

 - The routing key used during binding specifies which notifications the
   client wishes to receive.

 - The client can bind the same queue many times with different routing
   keys.

 - The client can use the same queue both for replies and notifications.

Console Message Language
------------------------

All messages between the console client and the server are formatted using
simple XML. We use a minimalistic XML syntax - no stylesheets, namespaces,
document types, etc.

We define an XML language: CML, the console message language - to carry
console API commands between the console server and console client.  CML
has the following overall syntax:

    <cml version = "1.0" name = "request|reply|notify" >
        <object name = "objectname" method = "methodname" id = "objectid">
            ...
        </object>
    </cml>





We use a simple set of tags:

    <cml>
        <object>
            <field>

Where objects can contain other objects and fields.  Here is an example of an OTL message that shows metadata (object IDs and status),
object properties, and child objects:

    <cml name = "inspect">
        <object name = "server" id = "0" status = "ok">
            <field name = "ipaddress">192.168.55.62</field>
            <field name = "port">7654</field>
            <field name = "message count">0</field>
            <field name = "connection count">0</field>
            <field name = "octet in count">0</field>
            <field name = "octet out count">0</field>
            <object name = "exchange" id = "1">
                <field name = "name">amq.direct</field>
            </object>
            <object name = "exchange" id = "2">
                <field name = "name">amq.topic</field>
            </object>
            <object name = "exchange" id = "3">
                <field name = "name">amq.system</field>
            </object>
            <object name = "exchange" id = "4">
                <field name = "name">amq.system.alert</field>
            </object>
        </object>
    </cml>







Watches
-------

A watch is a concept designed to let an operator monitor specific
objects without having to watch them constantly. Watches are set on
specific properties of specific objects.  I.e. if you want to watch
the size of two different queues, this requires two watches.

While the specifics of watch implementation depend on the server, we
assume a model like this:

 - Watches are global to an OpenAMQ server.

 - A watch specifies some upper or lower limit for a property.

 - The console server will regularly check all watches.

 - When a watch limit is crossed, the console will send an alert
   message to the amq.console.alert exchange using the watch routing
   key.

 - All correctly-subscribed clients can receive these alerts.

Watches have the same lifespan as the objects they are applied to.
That is, durable objects have durable watches.  Note that in the
current OpenAMQ server implementation, all objects are temporary,
and so all watches are also temporary.


Message Implementation
======================

Synchronous Method Model
------------------------

A synchronous method consists of one request from the console client to the
server and one reply from the server back to the console client.

The general format of a request is:

    <cml request = "methodname">
        [message arguments]
    </cml>

The general format of a reply is:

    <cml reply = "methodname">
        [message arguments]
    </cml>

These are the standard synchronous methods we implement:

 - "inspect" - inspect a set of server objects.
 - "modify" - modify the properties of a set of server objects.
 - "monitor" - query or modify the watches on a set of objects.

Each request that the console client sends results in exactly one reply from the
server, with the same method name. We will probably define more methods,
especially on an object-by-object base as we progress with the operator
console implementation.

Asynchronous Method Model
-------------------------

An asynchronous method consists of one notify message from the console client to
the server or vice-versa.

These are the standard asynchronous methods we implement:

 - "alert" - when a watched property has reached the specified value.

The 'Inspect' Method
--------------------

The 'inspect' method asks the server to provide a detailed description
of one or more objects:

    <cml
        request = "inspect">
      [ <object name = "objectname" id = "idvalue" expand = "0|1" /> ]...
    </cml>

Where the 'expand' option (default 0) asks for a list of all child
objects. For example, to get the top-level server object and all its
children:

    <cml request = "inspect">
        <object name = "server" id = "0" expand = "1" />
    </cml>

The 'inspect' reply provides details for a set of objects:

    <cml reply = "inspect">
      [ <object
            name = "objectname"
            id = "idvalue"
            status = "ok|notfound|noaccess"
            children = "nbrofchildren>
          [ <field name = "objectprop">objectpropvalue</field> ]...
          [ <object name = "childname" id = "idvalue" /> ]...
        </object> ]...
    </cml>

For example, the inspect reply for a freshly-started server instance
- with its default exchanges but no queues or connections - would be
something like:

    <cml reply = "inspect">
        <object name = "server" id = "0" status = "ok" children = "32">
            <field name = "ipaddress">192.168.55.142</field>
            <field name = "port">7654</field>
            <field name = "connection_count">0</field>
            <field name = "message_count">0</field>
            <field name = "octet_in_count">0</field>
            <field name = "octet_out_count">0</field>
            <object name = "exchange" id = "1" />
            <object name = "exchange" id = "2" />
            ...
            <object name = "exchange" id = "n" />
        </object>
    </cml>
    
Note that the set of properties that the inspect method returns are
defined on a per-object basis later in this document.

The 'Modify' Method
-------------------

The 'modify' method asks the server to modify certain properties of one
or more specified objects:

    <cml request = "modify">
      [ <object name = "objectname" id = "idvalue">
          [ <field name = "objectprop">objectpropvalue</field> ]...
        </object> ]...
    </cml>

The 'modify' reply signals that whether the objects were modified
successfully or not:

    <cml reply = "modify">
      [ <object
            name = "objectname"
            id = "idvalue"
            status = "ok|notfound|noaccess"> ]...
    </cml>

Note that the set of properties that can be modified are defined on
a per-object basis in the CIL specifications. 

The 'Monitor' Method
--------------------

The 'monitor' method asks the server to monitor certain properties of
one or more objects:

    <cml request = "monitor">
      [ <object name = "objectname" id = "idvalue" reset = "0|1">
          [ <field name = "objectprop">
              [ <watch
                    name  = "watchtype"
                    value = "watchvalue"
                    alert = "alertmessage"
                  [ route = "routingkey" ] /> ]...
            </field> ]...
        </object> ]...
    </cml>

- The watchtypes are: eq, ne, lt, gt, le, ge, which correspond to the
  standard set of comparison operators. The watchvalue is a numeric
  value - only numeric and Boolean fields are monitorable.

- If the reset option is not specified, or is 0, the watches are added
  to those already present.  If the reset option is 1, the server will
  delete all existing watches before adding those specified (if any).

- Alerts are sent to the amq.console.alert exchange using the routing
  key, which defaults to "amq.<objectname>.<idvalue>".

The monitor reply lists all current watches for the specified object:

    <cml reply = "monitor">
      [ <object name = "objectname" id = "idvalue">
          [ <watch
                name  = "watchtype"
                value = "watchvalue"
                alert = "alertmessage"
                route = "routingkey" /> ]...
        </object> ]...
    </cml>

The 'Alert' Method
-------------------

The 'alert' method tells the console client that a watched property has reached
the specified value:

    <cml
        notify = "alert">
        <object name = "objectname" id = "idvalue">
            <field name = "objectprop" alert = "alertmessage">objectpropvalue</field>
        </object>
    </cml>

Message Transfer Protocol
=========================

Server Implementation
=====================

Operable Objects
----------------

We are concerned only with operable objects, those we can work with
via the operator console.

All operable objects are implemented as iCL asynchronous objects (using
the icl_smt framework). This ensures that objects can safely and
atomically process all methods they receive.

The inspect and modify methods are defined in an abstract iCL class that
uses GSL code generation - a type of templating - to produce the actual
code for each method instance.

Object Identification
---------------------

When an operable object is created (the new method), it takes a new
identification value. This will be done using a global 64-bit variable
that is atomically incremented.

Object Registry
---------------

The system exchange maintains a registry of all active operable objects.
This is a tree structure, held in memory, with each node consisting of:

 - A reference to the object.
 - A pointer to the parent node.
 - The object's ID value.
 - A linked list of child objects (mixed and unordered).
 - A pointer to a class descriptor.

The class descriptor defines a single object type, e.g. "queue", and has
these properties:

 - Short name of class, e.g. "queue".
 - Callback address of 'inspect' method.
 - Callback address of 'modify' method.
 
Class descriptors are created automatically when a specific class is
initialised - i.e. used for the first time. They never change during the
lifetime of the server.

The registry can do a lookup from object ID to registry node, so object
ID forms a primary key for accessing objects in the registry.

Object Registation
------------------

A new object registers by sending a "register" method to the system
exchange, which is an asynchronous object. The register method has these
arguments:

 - The ID of the new object.
 - The ID of the parent object.
 - The address of the corresponding class descriptor.

Object Deregistration
---------------------

The destroy method for an object sends a "cancel" method to the system
exchange. The cancel method has these arguments:

 - ID of object being destroyed

The 'Inspect' Method
--------------------

An inspect method can apply to several objects. When the system exchange
receives an inspect method, it decodes the XML to give a list of objects
to inspect. It sends a method to each object in turn, waiting for a
reply. It collects these replis into a reply XML and when it
has done each object, it sends the reply back to the client (using the
mechanism explained previously).

For simplicity, all XML encoding and decoding is done in the system
exchange only.  Data is passed between the system exchange and objects
in the form of field tables (the asl_field_list class).

The 'Modify' Method
-------------------

A modify method can apply changes to several objects. The system
exchange decodes the XML, and sends a modify method to each affected
object. It constructs a reply and sends this back to the client.

The 'Monitor' Method
--------------------

The system exchange is responsible for monitoring watches.  It does
this by maintaining a list of watches and checking each one after
some regular interval - e.g. every 30 seconds.  It asks the watched
object to provide its properties ("inspect"), checks the properties
and if they hit the watch limit, sends an alert.

Once watch has provoked an alert, the system exchange will suppress
successive alerts unless there is significant variance - e.g. 5%.




