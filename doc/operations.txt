jmx
    - mbeans = management beans
    - properties read/write
        - properties structured
    - schema describes this
    - remove views
    - single schema operation
        - schema name & version
        - as static file delivered with server
    - object ids -> full path
    - configuration objects are separate from runtime objects
        - separate tree in schema
    - clustering: one console 
    
gdl
    title     = The AMQ Console
    subtitle  = Operator Control for AMQ Servers
    product   = OpenAMQ
    author    = iMatix Corporation <amq@imatix.com>
    date      = 2005/10/14
    copyright = Copyright (c) 2004-2005 JPMorgan
    version   = 1.0b
end gdl

The AMQ Console
***************

Summary
=======

Goals
-----

The AMQ console is designed to allow remote configuration, control
and management of an AMQ server, including:

 - Server and virtual host configuration.
 - Security configuration (authentication and access controls).
 - Monitoring of key entities (queues, etc.)
 - Collection of status information (performance, statistics)
 - Setting of watches (on queue size, etc.)
 - Administrative actions (purge queue, disconnect connection, etc.)

We want the console to have these features:

 - To be very rapid, even when many people are operating (different
   parts of) an AMQ server.  The speed of reaction of the console
   is a very important part of its functionality.

 - To be portable to any desired user interface technology, including
   web, command-line, JMX, etc.  Ideally, end-users should be able to
   make customised operator interfaces, scripts, etc.  We want the
   console to be user-extensible.

 - To provide access to all "operable" internals of the server, i.e.
   to any object that may be tuned, configured, or managed.

 - To hide all aspects of the server that are not "operable", i.e.
   any object that should not be touched or seen.  The operator must
   not be able to cause harm by misuse of the console.

 - To have no significant impact on server performance or stability
   even when heavily used.  The console must be non-intrusive, and
   wholly safe.

 - Eventually, to be transactional, so that operations are completed
   fully, or not at all.

Meta or Not?
------------

The main design question is/was, does the console implement a specific
data model (schema) or rather a meta-model capable of supporting any
given server implementation.

For example, do we hard-code the fact that the server is composed of
virtual hosts, queues, exchanges, etc. in a specific schema?  This
approach has the advantage of being explicit and easy to understand.

But it has some strong disadvantages. First, operational control is
necessarily tied to actual server functionality... that is, the entities
we want to control are by definition related to the internal design of
the server. While it is true that certain entities are defined by the
AMQP protocol and therefore present in all servers, other entities are
not. For example, security consists of entities (access control lists,
user groups, etc.) which are completely server-specific. If we define a
standard AMQ console schema that includes these, we force our security
model on all AMQ server implementations, or we create an AMQ console
that will only work with our specific server implementation. Both
options are undesirable. In making an open standard, it is desirable
that every layer is reusable and generic.

Not only is a single hard-coded console schema bad for reusability, it
is also a problem for change management.  These are some of the issues:

 - Any change to the console server will need matching changes to the
   console client.

 - We will get version incompatibilities with old clients unable to
   work with new servers and vice-versa.  This can be managed somewhat
   by keeping schemas backwards-compatible but it is not sustainable
   over any schema refactoring.

 - Any network with different versions of the server will need
   different versions of the clients as well.

In our experience these problems can be simply and cheaply avoided by
using a meta-schema from the start.

Version 1
---------

This is a preliminary design.  We expect that the console will evolve
considerably.  The goal of this version is to provide the minimum needed
functionality in the simplest possible way.

General Console Architecture
============================

Server and Client Layers
------------------------

The console is built using the AMQP protocol.  That is, the server does
not export any user interface, but rather an API on top of which arbitrary
user interfaces can be built.  The simplest architecture is this:

      AMQ Server              GUI or cmdline
    .-----------.             .-----------.
    |           |             |           |
    |  Console  | <==AMQP==>  |  Console  |
    |  Server   |             |  Client   |
    |           |             |           |
    `-----------'             `-----------'

Where the console client is responsible for the user interface -
command line or GUI.  A more sophisticated architecture uses a console
standard such as JMX so that it is easy to write arbitrary operator
applications:

      AMQ Server                 Proxy               GUI or cmdline
    .-----------.             .-----------.           .----------.
    |           |             |           |           |          |
    |  Console  | <==AMQP==>  |  Console  | <==JMX==> | Operator |
    |  Server   |             |  Client   |           |   Appl   |
    |           |             |           |           |          |
    `-----------'             `-----------'           `----------'

 - The console consists of a server component and a client component.

 - The console server is an application that is embedded into the
   AMQ server.

 - The console client is an application written in an arbitrary
   language.

 - The console client and server communicate using AMQP.

The Server Schema
-----------------

The console works on a set of entities we call "objects".  In many
cases the console objects will match internal server objects, but this
is not mandatory.

Note: it is tiresome to use different terms for the definition of an
object, and an instance of an object.  When I say, "the model X coffee
machine can produce twenty cups of espresso per minute", it is clear
I am talking about the whole class of model X coffee machines.  When
I say, "the model X coffee machine on the third floor is broken", it
is clear I am talking about one specific instance.  So, we use the term
"object" to mean both the whole class of a certain type of object,
and a specific object instance of that class.

The collection of objects that the server supports is its "schema".

Every AMQ server can implement its own schema, and this is critical
to making a useful console - depending on the server implementation,
or configuration, we need different schemas.  It is not useful to
assume that all console clients know all schemas in advance.

The minimal server schema consists of exactly one object:

    server

All AMQ servers will support this schema, and all console clients will
assume it.  Note that this object is both the class and instance: there
will be exactly one server object for a running server.

The server can then extend the schema by adding arbitrary objects to
it:

    server
     :
     (arbitrary objects)

Objects can include objects, so we can build schemas like this:

    server
     :
     :-- vhost
     :    :
     :    :-- exchange
     :    :
     :    `-- queue
     :        :
     :        `-- consumer
     :
     `-- connection

Which represents the operable core of an OpenAMQ/0.9 server.  Note that
this schema is an example: the actual server schema is probably larger
and more complex.

Object Definition
-----------------

An object is defined as follows:

 - The object has a class name, e.g. "server", unique within the schema.
 - The object instance has a server-wide unique identifier.
 - The object has a set of 'views', which are sets of properties.
 - The object has a set of child objects.

Object views are composed of sets of fields, each defined as follows:

 - The field has a name.
 - The field has a type, explained later.
 - If the field is enumerated, it has a set of named values.
 - The field has a prompt, used to construct a user interface.
 - The field has a description, used to construct a user interface.

Standard Views
--------------

All objects have these two standard views:

 - "inspect" - containing the object fields that may be shown to the
    operator.
 - "modify" - containing the object fields that the operator may change.

We will extend the API with other views at a later stage.

Object Commands
---------------

All objects support these standard commands:

 - "meta" - returns the description of a specified object class.
 - "inspect" - returns an inspect view for a specified object.
 - "modify" - applies a modify view to a specified object.
 - "watch" - sets watches on fields from an object's inspect view.

We will extend the API with other commands at a later stage.

Object Identification
---------------------

Each object has a unique 64-bit identifier assigned by the server when it
creates the object. This identifier is used in all messages when referring
to an object.

By convention, ID 0 is reserved for the root object, "server".  This is
the only object that is guaranteed to be present in all server schemas.

Watches
-------

Watch are tools that let an operator monitor specific objects without
having to watch them constantly. Watches are set on specific properties
of specific objects.  I.e. to watch the size of two different queues
requires two watches.

While the specifics of watch implementation depend on the server, we
assume a model like this:

 - A watch specifies an upper or lower limit for a numeric property.

 - The server regularly check all watches, for instance every 10 seconds.

 - When a watch limit is crossed, the console sends a notification
   using the AMQP topic exchange mechanisms.

 - All correctly-subscribed clients can receive these notifications.

Watches have the same lifespan as the objects they are applied to.  That
is, durable objects have durable watches.  Note that in the current
OpenAMQ server implementation, all objects are temporary, and so all
watches are also temporary.

The Console API
===============

General Design
--------------

The console API consists of two pieces:

 - Execute a command on a given object.  This consists of a request from
   the client to the server, and a reply back from the server to the client.

 - Notifications from the server.  These are sent asynchronously using the
   AMQP topic routing mechanisms.

The console uses the Basic content class, and these AMQP methods:

 - Basic.Publish
 - Basic.Consume and Basic.Deliver
 - Basic.Browse and Basic.Browse-Ok / Browse-Empty.

By using the Basic content class we ensure that the console works with all
future AMQ servers.  The Basic class is the only class that all AMQ servers
MUST support, according to the AMQP specifications.

The request-reply mechanism uses standard queues as follows:

 - Each client creates a temporary reply queue and binds this as usual
   for a reply queue.
 - Each request to the server specifies this queue in the "reply-to" field.

To implement a request-reply method, the client will:

 - Create a suitably-formatted message.
 - Set the reply-to field correctly to refer to its reply queue.
 - Use the Basic.Publish method to send the message to the amq.console
   exchange.
 - Wait for a reply on its reply queue.

The notification mechanism uses topic routing and subscription queues as
follows:

 - Each client wishing to receive notifications creates a temporary queue
   and binds this to the amq.console.notify exchange (a topic exchange).
 - The routing key used during binding specifies which notifications the
   client wishes to receive.
 - The client can bind the same queue many times with different routing
   keys.
 - The client can use the same queue both for replies and notifications.

Console Message Language
------------------------

All messages between the console client and the server are formatted using
an XML language we call "CML", the Console Message Language.  CML uses a
minimalistic XML syntax - no stylesheets, namespaces, document types, etc.

Here are some examples of CML:

    <cml version = "1.0">
        <meta class = "server" />
    </cml>

    <cml version = "1.0">
        <inspect object = "0" />
    </cml>

    <cml version = "1.0">
        <modify object = "0">
            <field name = "shutdown">1</field>
        </modify>
    </cml>

CML has a grammar that covers all possible server schemas. Client requests
are shown as "C:", server responses as "S:":

    cml            = <cml version = "1.0">
                        cml-command
                     </cml>

    cml-command    = C:meta    S:meta
                   | C:inspect S:inspect
                   | C:modify  S:modify
                   | C:watch   S:watch
                   | S:notify

    C:meta         = <meta class = "class-name" />

    class-name     = valid-name

    valid-name     = {A-Za-z0-9-_.}...

    S:meta         = <meta class = "class-name" status = "reply-status" >
                       [ meta-view ]...
                       [ meta-object ]...
                     </meta>

    reply-status   = ok | notfound | noaccess | invalid

    meta-view      = <view name = "view-name">
                       [ meta-field ] ...
                     </view>

    view-name      = inspect | modify

    meta-field     = <field
                         name = "field-name"
                       [ type = "field-type" ]
                       [ prompt = "field-prompt" ]>
                       [ field-text ]
                       [ enum-value ] ...
                     </field>

    field-name     = valid-name

    field-type     = (string) | int | bool | action | object

    field-prompt   = valid-text

    valid-text     = {printable}...

    enum-value     = <value name = "value-name">field-value</value>

    value-name     = valid-text

    field-value    = string representation of allowed field value

    meta-object     = <object class = "class-name" />

    C:inspect      = <inspect object = "object-id" [ detail = "ask-detail" ] />

    object-id      = 0..maxlongint-1

    ask-detail     = (0) | 1

    S:inspect      = <inspect
                        object   = "object-id"
                      [ children = "child-count" ]
                      [ watches  = "watch-count" ]
                        status   = "reply-status">
                       [ field-data ]...
                       [ object-data ]...
                     </inspect>

    child-count    = 0..maxint - 1

    watch-count    = 0..maxint - 1

    field-data     = <field name = "field-name">field-value</field>

    object-data    = <object class = "class-name" id = "object-id" />

    C:modify       = <modify object = "object-id">
                       [ field-data ] ...
                     </modify>

    S:modify       = <modify object = "object-id" status = "reply-status" />

    C:watch        = <watch object = "object-id" [reset = "ask-reset"] >
                       [ watch-field ]...
                     </watch>

    watch-field    = <field
                         name  = "field-name"
                       [ test  = "watch-type" ]
                         value = "watch-value"
                       [ route = "routing-key" ]
                         >[alert-message]</field>

    watch-type     = eq | ne | lt | le | gt | (ge)

    watch-value    = integer

    alert-message  = valid-text

    routing-key    = valid-name

    ask-reset      = (0) | 1

    S:watch        = <watch object = "object-id" status = "reply-status">
                       [ watch-field ]...
                     </watch>

    S:notify       = <notify object = "object-id">
                        [ notification ]...
                        [ <field name = "field-name">
                            notification
                        </field> ]...
                     </notify>

    notification   = <alert>alert-message</alert>
                     <cause>cause-message</cause>

    cause-message  = valid-text

Field Types
-----------

The goal of defining fields is to allow the automatic production of user
interface forms without too much work.  We allow these types of field:

 - string: defines a string field.  The maximum value of a string field
   is 255 octets when an object is modified, and no limit on output.
   This is the default type.
 - int: defines an integer.  Integers are assumed to be unsigned 32 bits.
 - bool: defines a boolean value, which can be shown as a check box.
 - action: defines a form action, only allowed in the modify view.
 - object: defines a relationship to another object.

String and integer fields can be enumerated, with one or more values.
These would show as radio options (for 3-4 or fewer fields) or select
boxes (for 5 or more options), e.g.:

    <field name = "status" type = "int" prompt = "Operational status">
        <value name = "not ready"    >0</value>
        <value name = "active"       >1</value>
        <value name = "shutting down">2</value>
    </field>

A field enumeration must be respecified in each view where the field
is used.

Note: this is a minimalistic typing model that we will probably want to
refine over time, e.g. defining the shown and maximum length for strings
and integers, and allowing multiline text fields.

The 'Meta' Command
------------------

The 'meta' commmand asks the server for a class description.  The server
responds with the definition of the specified class.  The top-level class
is always "server".

For example:

    C: <cml version = "1.0">
          <meta class = "server" />
       </cml>

    S: <cml version = "1.0">
          <meta class = "server" status = "ok">
             <view name = "inspect">
                <field name = "ip-address" prompt = "Server IP address" />
                <field name = "port"       prompt = "Port for connections" />
                <field name = "version"    prompt = "Server software version" />
                <field name = "platform"   prompt = "Server platform" />
             </view>
             <view name = "modify">
             </view>
             <object class = "vhost" />
             <object class = "connection" />
          </meta>
       </cml>

The console client should start by doing a 'meta' command on "server" and
then repeating this for each child class, building up a tree, until it has
fully explored the schema.

The reply-status field defines whether the command was successful or not.
This field has these possible values:

 - 'ok' means the command completed successfully.
 - 'notfound' means the specified class (or object, for other commands)
   did not exist.
 - 'noaccess' means the client application was not allowed to execute the
   command.
 - 'invalid' means the command was wrongly formatted or incorrect.

The 'Inspect' Command
---------------------

The 'inspect' command asks the server for the inspect view of a specific
object.  This command takes an object ID as argument, and will return
either just the inspect view for that object, or also a list of all
child objects.

The top-level "server" object always has an ID zero, so the client will
inspect this object before looking at others.

For example:

    C: <cml version = "1.0">
          <inspect object = "0" detail = "1" />
       </cml>

    S: <cml version = "1.0">
          <inspect object = "0" children = "2" status = "ok">
             <field name = "ip-address">192.168.55.142</field>
             <field name = "port">7654</field>
             <field name = "version">0.9c2</field>
             <field name = "platform">Linux</field>
             <object class = "exchange" id = "1" />
             <object class = "exchange" id = "2" />
          </inspect>
       </cml>

The 'Modify' Command
--------------------

The 'modify' command provides a set of fields (from the object's modify
view) and asks the server to change a specific object accordingly.  For
example:

    C: <cml version = "1.0">
          <modify object = "2">
             <field name = "enabled">0</field>
          </modify >
       </cml>

    S: <cml version = "1.0">
          <modify object = "2" status = "ok" />
       </cml>

If the client specifies fields that are not valid (not in the modify
view), the server will respond with an "invalid" status.

The 'Watch' Command
-------------------

The 'watch' command sets, removes, or queries the watches for a
specific object.  The command works as follows:

 - If the 'reset' option is set to 1, all existing watches on the object
   are deleted.
 - Any watches specified are applied to the object.
 - The server responds with the set of all watches on the object.

This gives the client full control over the set of watches that are active
for any given object.

For example, to reset all watches:

    C: <cml version = "1.0">
          <watch object = "2" reset = "1" />
       </cml>

    S: <cml version = "1.0">
          <watch object = "2" status = "ok" />
       </cml>

To add a watch to the object:

    C: <cml version = "1.0">
          <watch object = "2">
             <field name = "binding-count" value = "10000">
             Exchange is getting overloaded
             </field>
          </watch>
       </cml>

    S: <cml version = "1.0">
          <watch object = "2" status = "ok">
             <field name = "binding-count" test = "gt" value = "10000"
                route = "amq.exchange.2.binding-count">Exchange is
                getting overloaded
             </field>
          </watch>
       </cml>

 - The watch tests are: eq, ne, lt, gt, le, ge, which correspond to the
   standard set of comparison operators.  The default test is "ge".

 - The watched value is a numeric value - only numeric and Boolean fields
   can be watched.

 - Notifications sent to the amq.console.notify exchange using the routing
   key, which defaults to "amq.<classname>.<idvalue>.<fieldname>".

The 'Notify' Command
--------------------

The server broadcasts warnings, error reports, and watch alarms using
'notify' commands.  Any correctly subscribed AMQP client can get these
notifications.

The notification consists of an alert message and an explanation (the
'cause').  The notification is attached either to an object or to a
specific field in the object.  For example:

    S: <cml version = "1.0">
          <notify object = "2" >
             <field name = "binding-count">
                <alert>Exchange is getting overloaded</alert>
                <cause>Exchange 'binding-count' is now at 10200 (limit 10000)</cause>
             </field>
          </notify>
       </cml>

