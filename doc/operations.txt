jmx
    - properties read/write
        - properties structured
    - schema describes this
    - remove views
    - single schema operation
        - schema name & version
        - as static file delivered with server
    - object ids -> full path
    - configuration objects are separate from runtime objects
        - separate tree in schema
    - clustering: one console 
    
gdl
    title     = The AMQ Console
    subtitle  = Operator Control for AMQ Servers
    product   = OpenAMQ
    author    = iMatix Corporation <amq@imatix.com>
    date      = 2005/10/24
    copyright = Copyright (c) 2004-2005 JPMorgan
    version   = 1.1a
end gdl

Overview
********

Goals
=====

The AMQ console is designed to allow remote configuration, control
and management of an AMQ server, including:

 - Server and virtual host configuration.
 - Security configuration (authentication and access controls).
 - Monitoring of key entities (queues, etc.)
 - Collection of status information (performance, statistics)
 - Setting of watches (on queue size, etc.)
 - Administrative actions (purge queue, disconnect connection, etc.)

We want the console to have these features:

 - To be very rapid, even when many people are operating (different
   parts of) an AMQ server.  The speed of reaction of the console
   is a very important part of its functionality.

 - To be portable to any desired user interface technology, including
   web, command-line, JMX, etc.  Ideally, end-users should be able to
   make customised operator interfaces, scripts, etc.  We want the
   console to be user-extensible.

 - To be generally compatible with conventional console abstractions,
   e.g. Java management beans.
   
 - To provide access to all "operable" internals of the server, i.e.
   to any object that may be tuned, configured, or managed.

 - To hide all aspects of the server that are not "operable", i.e.
   any object that should not be touched or seen.  The operator must
   not be able to cause harm by misuse of the console.

 - To have no significant impact on server performance or stability
   even when heavily used.  The console must be non-intrusive, and
   wholly safe.

 - Eventually, to be transactional, so that operations are completed
   fully, or not at all.

 - Lastly, to be self-describing, using data schemas that clients can
   refer to, adapting statically or dynamically as suitable.

General Console Architecture
============================

Server and Client Layers
------------------------

The console is built using the AMQP protocol.  That is, the server does
not export any user interface, but rather an API on top of which arbitrary
user interfaces can be built.  The simplest architecture is this:

      AMQ Server              GUI or cmdline
    .-----------.             .-----------.
    |           |             |           |
    |  Console  | <==AMQP==>  |  Console  |
    |  Server   |             |  Client   |
    |           |             |           |
    `-----------'             `-----------'

Where the console client is responsible for the user interface -
command line or GUI.  A more sophisticated architecture uses a console
standard such as JMX so that it is easy to write arbitrary operator
applications:

      AMQ Server                 Proxy               GUI or cmdline
    .-----------.             .-----------.           .----------.
    |           |             |           |           |          |
    |  Console  | <==AMQP==>  |  Console  | <==JMX==> | Operator |
    |  Server   |             |  Client   |           |   Appl   |
    |           |             |           |           |          |
    `-----------'             `-----------'           `----------'

 - The console consists of a server component and a client component.

 - The console server is an application that is embedded into the
   AMQ server.

 - The console client is an application written in an arbitrary
   language.

 - The console client and server communicate using AMQP.

The Server Schema
=================

We define that:

 - The console works on a set of entities we call "objects".

 - The collection of objects that the server supports is its "schema".

 - Schemas are given globally-unique names and versions.
 
We will generally use the term "object" to mean both the whole class of
a certain type of object, and a specific object instance of that class,
depending on context. When the context is ambiguous we will say "object
instance" and "object class" to be explicit.

Every AMQ server can implement its own schema, depending on its specific
functionality. We do not assume that all console clients know all
schemas in advance.

This is an example of a schema structure:

    server
     :
     :-- vhost
     :    :
     :    :-- exchange
     :    :
     :    `-- queue
     :        :
     :        `-- consumer
     :
     `-- connection

(This represents the operable core of an OpenAMQ/0.9 server.)

Object, Fields, and Methods
===========================

Objects are constructed as arbitrarily-complex hierarchical structures,
representing entities in the server.

An object is defined as follows:

 - The object has a class name, e.g. "server", unique within the schema.
 - Each object instance has a numeric identifier.
 - The object is composed of zero or more data fields (the object's
   properties).
 - The object may contain one or more child objects.
 - The object may allow one or more methods.

A data field is defined as follows:

 - The field has a name.
 - The field has a data type.
 - The field may be restricted to a set of named values.
 - The field has a label, used to construct a user interface.
 - The field has a description, used to construct a user interface.
 - The field has a set of access indicators (inspect, modify).
 - The field may contain one or more child fields.

Methods accept a number of arguments and perform some action on an
object, and return a status value. A method is defined as follows:

 - The method has an internal name.
 - The method has a label, used to construct a user interface.
 - The method carries zero or more data fields (the method's arguments).
 - The method has a description, used to construct a user interface.

Commands
========

The API consists of these commands:

 - "schema" - returns the server schema.
 - "inspect" - returns the properties of a specific object.
 - "modify" - modifies the properties of a specific object.
 - "method" - executes a named method on a specific object.
 - "watch" - sets watches on fields of a specific object.
 - "notify" - (from server to client) send a notification.

Object Identification
=====================

Each object has a unique 64-bit identifier assigned by the server when
it creates the object. This identifier is used in all messages when
referring to an object.

ID 0 (zero) always represents the root object.

Watches
=======

Watch are tools that let an operator monitor specific objects without
having to watch them constantly. Watches are set on specific properties
of specific objects. I.e. to watch the size of two different queues
requires two watches.

While the specifics of watch implementation depend on the server, we
assume a model like this:

 - A watch specifies an upper or lower limit for a numeric property.

 - The server regularly check all watches, for instance every 10 seconds.

 - When a watch limit is crossed, the console sends a notification
   using the AMQP topic exchange mechanisms.

 - All correctly-subscribed clients can receive these notifications.

Watches have the same lifespan as the objects they are applied to. That
is, durable objects have durable watches. We assume that any mechanism
in the server for serialising objects is also capable of serialising
watches on objects. Note that in the current OpenAMQ server
implementation, all objects are temporary, and so all watches are also
temporary. 

The Console API
***************

General Design
==============

The console API consists of two pieces:

 - Execute a command on a given object. This consists of a request
   from the client to the server, and a reply back from the server to
   the client.

 - Get a notification from the server. Notifications are sent
   asynchronously using the AMQP topic routing mechanisms.

The console API consist of Basic content messages, exchanged using these
AMQP methods:

 - Basic.Publish
 - Basic.Consume and Basic.Deliver
 - Basic.Browse and Basic.Browse-Ok / Browse-Empty.

By using the Basic content class we ensure that the console works with all
future AMQ servers.  The Basic class is the only class that all AMQ servers
MUST support, according to the AMQP specifications.

The request-reply mechanism uses standard queues as follows:

 - Each client creates a temporary reply queue and binds this as usual
   for a reply queue.
 - Each request to the server specifies this queue in the "reply-to" field.

To implement a request-reply method, the client will:

 - Create a suitably-formatted message.
 - Set the reply-to field correctly to refer to its reply queue.
 - Use the Basic.Publish method to send the message to the amq.console
   exchange.
 - Wait for a reply on its reply queue.

The notification mechanism uses topic routing and subscription queues as
follows:

 - Each client wishing to receive notifications creates a temporary queue
   and binds this to the amq.console.notify exchange (a topic exchange).
 - The routing key used during binding specifies which notifications the
   client wishes to receive.
 - The client can bind the same queue many times with different routing
   keys.
 - The client can use the same queue both for replies and notifications.

Console Message Language
========================

All messages between the console client and the server are formatted using
an XML language we call "CML", the Console Message Language.  CML uses a
minimalistic XML syntax - no stylesheets, namespaces, document types, etc.

Here are some examples of CML:

    <cml version = "1.0">
        <schema />
    </cml>

    <cml version = "1.0">
        <inspect object = "0" />
    </cml>

    <cml version = "1.0">
        <modify object = "0">
            <field name = "active">0</field>
        </modify>
    </cml>

CML has a grammar that covers all possible server schemas. Client requests
are shown as "C:", server responses as "S:":

    cml             = <cml version = "1.0">
                         cml-command
                      </cml>

    cml-command     = C:schema  S:schema
                    | C:inspect S:inspect
                    | C:modify  S:modify
                    | C:method  S:method
                    | C:watch   S:watch
                    | S:notify

    C:schema        = <schema />

    S:schema        = <schema
                         name = "schema-name"
                         version = "schema-version"
                         status = "reply-status" >
                       [ schema-object ]...
                      </schema>

    schema-name     = valid-name

    valid-name      = {A-Za-z0-9-_.}...

    schame-version  = valid-name

    reply-status    = ok | notfound | noaccess | invalid

    schema-object   = <object class = "class-name">
                       [ schema-field ]...
                       [ schema-method ]...
                       [ schema-object ]...
                      </object>

    class-name      = valid-name

    schema-field    = group-field | simple-field
    
    group-field     = <field
                         name = "field-name"
                       [ label = "field-label" ]>
                       [ field-text ]
                       [ field-access ]...
                       [ schema-field ]...
                      </field>

    field-name      = valid-name

    field-label     = valid-text

    valid-text      = {printable}...

    field-text      = valid-text

    field-access    = <allow access = "access-type" />

    access-type     = inspect | modify
    
    simple-field    = <field
                         name = "field-name"
                       [ type = "field-type" ]
                       [ label = "field-label" ]>
                       [ field-text ]
                       [ enum-value ] ...
                       [ field-access ]...
                     </field>

    field-type      = string | int | bool | object

    enum-value      = <value name = "value-name">field-value</value>

    value-name      = valid-text

    field-value     = string representation of allowed field

    schema-method   = <method name = "method-name">
                       [ schema-field ]...
                      </method>

    method-name     = valid-name
    
    C:inspect       = <inspect object = "object-id" [ detail = "ask-detail" ] />

    object-id       = 0..maxlongint-1

    ask-detail      = (0) | 1

    S:inspect       = <inspect
                         object   = "object-id"
                       [ children = "child-count" ]
                       [ watches  = "watch-count" ]
                         status   = "reply-status">
                        [ field-data ]...
                        [ object-data ]...
                      </inspect>

    child-count     = 0..maxint - 1

    watch-count     = 0..maxint - 1

    field-data      = <field name = "field-name">field-value</field>

    object-data     = <object class = "class-name" id = "object-id" />

    C:modify        = <modify object = "object-id">
                        [ field-data ] ...
                      </modify>

    S:modify        = <modify object = "object-id" status = "reply-status" />

    C:method        = <method object = "object-id" name = "method-name">
                        [ field-data ] ...
                      </method>

    S:method        = <method object = "object-id" status = "reply-status" />

    C:watch         = <watch object = "object-id" [reset = "ask-reset"] >
                        [ watch-field ]...
                      </watch>

    watch-field     = <field
                          name  = "field-name"
                        [ test  = "watch-type" ]
                          value = "watch-value"
                        [ route = "routing-key" ]
                          >[alert-message]
                      </field>

    watch-type      = eq | ne | lt | le | gt | (ge)

    watch-value     = integer

    alert-message   = valid-text

    routing-key     = valid-name

    ask-reset       = (0) | 1

    S:watch         = <watch object = "object-id" status = "reply-status">
                        [ watch-field ]...
                      </watch>

    S:notify        = <notify object = "object-id">
                         [ notification ]...
                         [ <field name = "field-name">
                             notification
                         </field> ]...
                      </notify>

    notification    = <alert>alert-message</alert>
                      <cause>cause-message</cause>

    cause-message   = valid-text

Field Types
===========

The goal of defining fields is to allow the automatic production of user
interface forms without too much work.  We allow these types of field:

 - string: defines a string field.  The maximum value of a string field
   is 255 octets when an object is modified, and no limit on output.
   This is the default type.
 - int: defines an integer. Integers are unsigned 32 bits.
 - bool: defines a boolean value, which can be shown as a check box.
 - object: defines a relationship to another object.

String and integer fields can be enumerated, with one or more values.
These would show as radio options (for 3-4 or fewer fields) or select
boxes (for 5 or more options), e.g.:

    <field name = "status" type = "int" label = "Operational status">
        <value name = "not ready"    >0</value>
        <value name = "active"       >1</value>
        <value name = "shutting down">2</value>
    </field>

Note: this is a minimalistic typing model that we will probably want to
refine over time, e.g. defining the shown and maximum length for strings
and integers, and allowing multiline text fields.

The 'schema' Command
==================

The 'schema' commmand asks the server for a class description.  The server
responds with the definition of the specified class.  The top-level class
is always "server".

For example:

    C: <cml version = "1.0">
          <schema class = "server" />
       </cml>

    S: <cml version = "1.0">
          <schema class = "server" status = "ok">
             <view name = "inspect">
                <field name = "ip-address" label = "Server IP address" />
                <field name = "port"       label = "Port for connections" />
                <field name = "version"    label = "Server software version" />
                <field name = "platform"   label = "Server platform" />
             </view>
             <view name = "modify">
             </view>
             <object class = "vhost" />
             <object class = "connection" />
          </schema>
       </cml>

The console client should start by doing a 'schema' command on "server" and
then repeating this for each child class, building up a tree, until it has
fully explored the schema.

The reply-status field defines whether the command was successful or not.
This field has these possible values:

 - 'ok' means the command completed successfully.
 - 'notfound' means the specified class (or object, for other commands)
   did not exist.
 - 'noaccess' means the client application was not allowed to execute the
   command.
 - 'invalid' means the command was wrongly formatted or incorrect.

The 'Inspect' Command
=====================

The 'inspect' command asks the server for the inspect view of a specific
object.  This command takes an object ID as argument, and will return
either just the inspect view for that object, or also a list of all
child objects.

The top-level "server" object always has an ID zero, so the client will
inspect this object before looking at others.

For example:

    C: <cml version = "1.0">
          <inspect object = "0" detail = "1" />
       </cml>

    S: <cml version = "1.0">
          <inspect object = "0" children = "2" status = "ok">
             <field name = "ip-address">192.168.55.142</field>
             <field name = "port">7654</field>
             <field name = "version">0.9c2</field>
             <field name = "platform">Linux</field>
             <object class = "exchange" id = "1" />
             <object class = "exchange" id = "2" />
          </inspect>
       </cml>

The 'Modify' Command
====================

The 'modify' command provides a set of fields (from the object's modify
view) and asks the server to change a specific object accordingly.  For
example:

    C: <cml version = "1.0">
          <modify object = "2">
             <field name = "enabled">0</field>
          </modify >
       </cml>

    S: <cml version = "1.0">
          <modify object = "2" status = "ok" />
       </cml>

If the client specifies fields that are not valid (not in the modify
view), the server will respond with an "invalid" status.

The 'Watch' Command
===================

The 'watch' command sets, removes, or queries the watches for a
specific object.  The command works as follows:

 - If the 'reset' option is set to 1, all existing watches on the object
   are deleted.
 - Any watches specified are applied to the object.
 - The server responds with the set of all watches on the object.

This gives the client full control over the set of watches that are active
for any given object.

For example, to reset all watches:

    C: <cml version = "1.0">
          <watch object = "2" reset = "1" />
       </cml>

    S: <cml version = "1.0">
          <watch object = "2" status = "ok" />
       </cml>

To add a watch to the object:

    C: <cml version = "1.0">
          <watch object = "2">
             <field name = "binding-count" value = "10000">
             Exchange is getting overloaded
             </field>
          </watch>
       </cml>

    S: <cml version = "1.0">
          <watch object = "2" status = "ok">
             <field name = "binding-count" test = "gt" value = "10000"
                route = "amq.exchange.2.binding-count">Exchange is
                getting overloaded
             </field>
          </watch>
       </cml>

 - The watch tests are: eq, ne, lt, gt, le, ge, which correspond to the
   standard set of comparison operators.  The default test is "ge".

 - The watched value is a numeric value - only numeric and Boolean fields
   can be watched.

 - Notifications sent to the amq.console.notify exchange using the routing
   key, which defaults to "amq.<classname>.<idvalue>.<fieldname>".

The 'Notify' Command
====================

The server broadcasts warnings, error reports, and watch alarms using
'notify' commands.  Any correctly subscribed AMQP client can get these
notifications.

The notification consists of an alert message and an explanation (the
'cause').  The notification is attached either to an object or to a
specific field in the object.  For example:

    S: <cml version = "1.0">
          <notify object = "2" >
             <field name = "binding-count">
                <alert>Exchange is getting overloaded</alert>
                <cause>Exchange 'binding-count' is now at 10200 (limit 10000)</cause>
             </field>
          </notify>
       </cml>

