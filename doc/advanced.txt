gdl
    title     = Advanced
    subtitle  = Advanced use of OpenAMQ
    product   = OpenAMQ
    author    = iMatix Corporation
    date      = 2008/04/12
    copyright = Copyright (c) 1996-2007 iMatix Corporation
    version   = 1.0
end gdl

Server configuration
*********************

Built-in help
=============

The amq_server command provides built-in help on all command-line options and
configuration settings.  To get a summary of options, type this command:

    amq_server -h
    
To get a complete explanation, type this:

    amq_server --help | more

These are the basic command options:

    -w directory     Working directory for server (current)
    -s filename      Load custom settings from file (amq_server.cfg)
    -X comment       Comment, has no effect
    -q               Quiet mode: no messages (no)
    -b               Run as background server process (no)
    -f               Run as foreground console process (yes)
    -i               Show program statistics when ending (no)
    -v               Show version information
    -h               Show summary of command-line options
    --help           Show detailed configuration help

Main command-line options
=========================

You can also set configuration options directly from the command line. These are
the most commonly used configuration options and their command-line syntax:
    
    --port 5672         Server port for clients
    --listen *          Address (local network interface) to listen on
    --monitor 0         Monitor interval, seconds
    --dump_state 60     Dump state interval, seconds
    --debug_route 0     Debug message routing?
    --debug_queue 0     Debug queue activity?
    --debug_peering 0   Debug peering messages?
    --heartbeat 2       Heartbeat timer, seconds
    --backup            Failover backup host:port
    --primary           Failover primary host:port
    --attach            Enable auto-federation to specified host

port = "5672":
    Specifies the port on which the server should open its connections.
    Default value is 5672.                                             
listen = "*":
    Specifies the network interface on which the server should listen for
    connections. By default this is *, meaning all interfaces. You would 
    choose to set an address when you use OpenAMQ on a server with       
    multiple network interfaces, e.g. routing between two networks.      
    Default value is *.                                                  
monitor = "0":
    Specifies the interval in seconds at which the server will report its 
    message rates. If zero, no monitoring is shown. The recommended value 
    is 1, if monitoring is desired. Default value is 0. This option can be
    changed at runtime.                                                   
dump_state = "60":
    Specifies the interval at which the server will report its state. This
    shows the number of messages, queues, consumers, etc. used by the     
    server. If zero, no state is logged. Default value is 60. This option 
    can be changed at runtime.                                            
debug_route = "0":
    Specifies whether exchange routing is logged or not. Set this option
    when you are debugging a message routing design. For production use,
    we recommend you do not set this option. Default value is 0. This   
    option can be changed at runtime.                                   
debug_queue = "0":
    Specifies whether queue dispatching is logged or not. Set this option 
    when you are debugging message processing in the server. For          
    production use, we recommend you do not set this option. Default value
    is 0. This option can be changed at runtime.                          
debug_peering = "0":
    Specifies whether peering activity is logged or not. Set this option  
    if you need to debug server federation (message forwarding). For      
    production use, we recommend you do not set this option. Default value
    is 0. This option can be changed at runtime.                          
heartbeat = "2":
    Defines the timeout for connection heartbeating. Default value is 2.
    This option can be changed at runtime.                              
backup = "":
    Used when running the primary server, specifies the failover backup 
    server for the high-availability pair. Use the internet name of the 
    backup server as 'host' or 'host:port' if it is not running on port 
    5672. Do not specify this option together with the 'primary' option.
    Default value is .                                                  
primary = "":
    Used when running the backup server, specifies the failover primary 
    server for the high-availability pair. Use the internet name of the 
    primary server as 'host' or 'host:port' if it is not running on port
    5672. Do not specify this option together with the 'backup' option. 
    Default value is .                                                  
attach = "":
    If specified, the server will auto-federate to the specified parent   
    OpenAMQ server. This federates three exchanges: amq.service (a direct 
    exchange) using a service federation; amq.data (a topic exchange)     
    using a fanout federation; and amq.dataex (a headers exchange) using a
    fanout exchange. This gives you an instant enterprise service bus     
    (ESB) based on a spoke-and-hub model. You can fine-tune               
    auto-federation using the --attach-login and --attach-vhost options.  
    Default value is .                                                    

Creating a configuration file
=============================

OpenAMQ lets you set options in several ways:

 1. On the command-line, which has an immediate effect on that instance of the
    server.
 2. In the default configuration file, 'amq_server.cfg', which has an effect 
    on all instances of the server started after that file is edited.
 3. In a per-server configuration file, specified using the -s option when you
    run amq_server.
    
You can also edit amq_server_base.cfg but this is bad practice, since new
versions of that file are installed with each release, and you would thus lose
configuration settings after an update.

In general we recommend that you use the command line to test desired
configuration options and when you are satisfied with them, place them into a
configuration file.

OpenAMQ configuration files use an XML syntax, consisting of sections that are
easy to understand and edit.  When you run "amq_server --help" it explains for
each option how to add it to a config file.

For example:

    /config/server/port - Server port for clients
        From command-line: --port newvalue
        Specifies the port on which the server should open its connections.
        Current value is '5672'. Default value is '5672'

Is saved as:

    amq_server.cfg:
    <config>
        <server port = "5672" />
    </config>
    
You must merge sections together, e.g.:

    amq_server.cfg:
    <config>
        <server
            port = "5672"
            listen = "*"
            queue_timeout = "0"
            vhost = "/"
        />
        <resources
            monitor = "0"
            dump_state = "60"
        />
        <logging
            debug_route = "0"
            debug_queue = "0"
            debug_peering = "0"
        />
    </config>

Configuration file path
=======================

OpenAMQ will search for configuration files in:

 1. The current directory (the server working directory if you use the -w
    option).
 2. Each directory on the PATH environment variable.
 
It will first search for and load (if found) the amq_server_base.cfg file.  It
will then search for and load (if found) the amq_server.cfg file.  Finally it
will override any setting taken from these files with the options specified on
the command line.

Debugging complex configuration files
=====================================

You can debug configuration files if you become unsure which one(s) are being
used by a server process:

 * Add <echo>Some message</echo> into the file inside the <config> item.
 * Start the server and see what messages are echoed.

For example:

    amq_server.cfg:
    <config>
        <echo>Config file for cluster testing</echo>
    </config>

Then, running the server:

    > amq_server
    ...
    2008-05-02 16:58:25: I: amq_server.cfg: Config file for cluster testing
    ...

Tuning the memory allocator
===========================

OpenAMQ uses a memory subsystem that can be tuned for different purposes. The
tradeoff is between performance, and reporting of errors for debugging and to
detect memory leaks.

The memory subsystem selects an 'allocator' depending on the value of the
ALLOCATOR environment variable:

ALLOCATOR=thin:
    The thin allocator tracks memory leaks and reports these when the server
    stops.  This is the default allocator for production builds (when OpenAMQ
    is built with BOOM_MODEL=release).
ALLOCATOR=fat:
    The fat allocator tracks memory leaks and reports the source file and line
    number for any leak.  This is the default allocator for debug builds. (when 
    OpenAMQ is built with BOOM_MODEL=debug).
ALLOCATOR=direct:
    The direct allocator does no memory leak detection, and no debug tracking.
    It is a very thin layer over the system memory allocator (malloc).  This is
    usually the fastest allocator.

We recommend that in a high-performance scenario (over 20k messages per second)
you use ALLOCATOR=direct, while in normal scenarios you leave the default
setting.  As with all tuning options, test before and after using throughput
and latency tests.

The choice of memory allocator, as well as build model (release vs debug) can
also have a significant impact on the performance of client applications that do
over 20k messages in or out per second.  The fastest configuration in most cases
is ALLOCATOR=direct and BOOM_MODEL=mt,release.

Tuning the client
*****************

Via a configuration file
========================

The WireAPI client library cannot be tuned via command-line options.  It uses
an XML configuration file called amq_wireapi.cfg.  This file, if present, can
set any of the following options:

    <config>
        <tuning
            tcp_nodelay = "1"
            tcp_rcvbuf = "0"
            tcp_sndbuf = "0"
            arrived_low_water = "0"
            arrived_high_water = "0"
        />
    </config>

tcp_nodelay = "1":
    If this value is 1, socket data is written immediately, which is     
    usually good for latency. If this value is 0, data is buffered until 
    there is a full packet, which is usually good for throughput. Default
    value is 1. This option can be changed at runtime.                   
tcp_rcvbuf = "0":
    If this value is greater than zero, the connection to the server will
    use the specified value. Note: setting this value is delicate, do not
    use this option unless you know what you are doing. Default value is 
    0. This option can be changed at runtime.                            
tcp_sndbuf = "0":
    If this value is greater than zero, the connection to the server will
    use the specified value. Note: setting this value is delicate, do not
    use this option unless you know what you are doing. Default value is 
    0. This option can be changed at runtime.                            
arrived_low_water = "0":
    Number of messages in arrived queue when message flow from server is
    started again after it had been switched off on high water mark.    
    Default value is 0.                                                 
arrived_high_water = "0":
    Number of messages in arrived queue when message flow from server is
    stopped. If this property is 0, message flow is never switched off. 
    Default value is 0.                                                 

Via the environment
===================

The WireAPI library accepts these environment variables:

WIREAPI_VERBOSE=1
    If set to 1, causes all errors and warnings to be printed.  If set to 0,
    the WireAPI library is silent, and assumes that the application will do
    all necessary error reporting.  Default value is 0.
WIREAPI_SLOW=1
    If set to 1, causes the client to operate very slowly.  This can be used
    for testing, especially to simulate applications that are not reading
    messages rapidly.  Note that since WireAPI is multithreaded, messages will
    be collected from the server rapidly even if the calling application is
    blocked or slow.  Setting the WIREAPI_SLOW variable to 1 will cause 
    backlogs to be kept on the server instead.  Do not use this in any normal
    scenario, it will (obviously) create serious performance issues.

Logging subsystem
*****************

General description
===================

The OpenAMQ server keeps three levels of logs in the *logs* subdirectory:

1. Alert logs, which contain all errors and alerts.
2. Daily logs, which contain normal activity data, as well as all the
   contents of the alert logs.
3. Debug logs, which contain debugging and tracing output as requested by
   runtime or configuration options, as well as all the contents of the
   daily logs.

Each server process opens three log files, which are named thus:

    alert_[portnumber].log
    daily_[portnumber].log
    debug_[portnumber].log

The log files are cycled when the server restarts, or at midnight. The cycle
process does the following:

1. It closes the current log files (if the server is still running).
2. It moves the log files to the *archive* subdirectory.
3. It optionally executes a user-configurable archiving command.
4. It reopens new log files for the application.

To disable logging
==================

Use the --keep_logs 0 command-line option to disable logging, or this fragment
in amq_server.cfg:

    <logging
        keep_logs = "0"
    />

Logged data
===========

The OpenAMQ log files are text, intended for human readability rather than
formalised scanning.

A user or script never needs to scan multiple log files from one server since
they are hierarchical: thus the debug logs contain //all// logged data.

This is an example the logs produced by a short server run.

The alert log:

    2006-05-14 18:30:04: I: amq_server binding to 192.168.55.64:5672
    2006-05-14 18:30:04: I: amq_server binding to 192.168.55.107:5672
    2006-05-14 18:30:04: I: amq_server binding to 127.0.0.1:5672
    2006-05-14 18:30:05: I: server ready for incoming AMQ connections
    2006-05-14 18:30:10: I: cnn=1 msg=2 mem=2K/10439K exc=7 que=1 csm=1 bnd=2

The daily log:

    2006-05-14 18:30:04: I: starting virtual host '/'
    2006-05-14 18:30:04: I: amq_server binding to 192.168.55.64:5672
    2006-05-14 18:30:04: I: amq_server binding to 192.168.55.107:5672
    2006-05-14 18:30:04: I: amq_server binding to 127.0.0.1:5672
    2006-05-14 18:30:05: I: server ready for incoming AMQ connections
    2006-05-14 18:30:07: I: start login from=127.0.0.1:40441 -
                            product=OpenAMQ Kernel Client version=1.0c0
    2006-05-14 18:30:07: I: valid login from=127.0.0.1:40441 user=console -
                            group=console
    2006-05-14 18:30:10: I: cnn=1 msg=2 mem=2K/10439K exc=7 que=1 csm=1 bnd=2
    2006-05-14 18:30:12: I: start login from=127.0.0.1:40442 -
                            product=OpenAMQ Kernel Client version=1.0c0

The debug log:

    2006-05-14 18:30:04: ###########  Process Environment Variables  ###########
    2006-05-14 18:30:04: KDE_MULTIHEAD=false
    2006-05-14 18:30:04: SSH_AGENT_PID=1821
    2006-05-14 18:30:04: TERM=vt220
    2006-05-14 18:30:04: ...
    2006-05-14 18:30:04: ##############  Configuration Settings  ###############
    2006-05-14 18:30:04: port=5672
    2006-05-14 18:30:04: background=0
    2006-05-14 18:30:04: queue_timeout=0
    2006-05-14 18:30:04: max_memory_mb=512
    2006-05-14 18:30:04: per_client=0
    2006-05-14 18:30:04: ...
    2006-05-14 18:30:07: I: start login from=127.0.0.1:40441 -
                         product=OpenAMQ Kernel Client version=1.0c0
    2006-05-14 18:30:07: I: valid login from=127.0.0.1:40441 user=console -
                         group=console
    2006-05-14 18:30:07: X: bind     $default$: queue=#0
    2006-05-14 18:30:07: X: compile  $default$: routing_key=#0
    2006-05-14 18:30:07: X: bind     amq.direct: queue=#0
    2006-05-14 18:30:07: X: compile  amq.direct: routing_key=#0
    2006-05-14 18:30:07: X: publish  amq.system: routing_key=amq.console
    2006-05-14 18:30:07: X: publish  amq.direct: routing_key=#0
    2006-05-14 18:30:07: X: route    amq.direct: routing_key=#0
    2006-05-14 18:30:07: X: deliver  queue=#0
    2006-05-14 18:30:07: X: publish  amq.system: routing_key=amq.console
    2006-05-14 18:30:07: X: publish  amq.direct: routing_key=#0
    2006-05-14 18:30:07: X: route    amq.direct: routing_key=#0
    2006-05-14 18:30:07: X: deliver  queue=#0
    2006-05-14 18:30:07: X: publish  amq.system: routing_key=amq.console
    2006-05-14 18:30:07: X: publish  amq.direct: routing_key=#0
    2006-05-14 18:30:07: X: route    amq.direct: routing_key=#0
    2006-05-14 18:30:07: X: deliver  queue=#0
    2006-05-14 18:30:08: I: incoming rate=10 mean=10 peak=10
    2006-05-14 18:30:08: I: outgoing rate=5 mean=5 peak=5 iomean=15
    2006-05-14 18:30:12: I: start login from=127.0.0.1:40442 -
                         product=OpenAMQ Kernel Client version=1.0c0

Custom log file names
=====================

You can override the names of the log files using these command-line options:

    --alert_log alert.log          Error log file name
    --daily_log daily.log          Daily log file name
    --debug_log debug.log          Debug log file name

You can also specify these in the amq_server.cfg configuration file.

Custom log file cycling
=======================

The built-in cycling mechanism just copies old log files to the archive
subdirectory and renames them using the current date and time.

You can customise the cycling mechanism by specifying your own cycling command,
which is a shell command that amq_server will execute after moving the log files
to their archive directory. The log file name is passed to this command as its
first and only argument:

    --archive_cmd value            Archive log file command

You can also specify this in the amq_server.cfg configuration file.

Server tracing options
======================

You can set various server debug and trace levels using these command-line
options:

    --debug_route 0                Debug message routing?
    --debug_queue 0                Debug queue activity?
    --debug_cluster 0              Debug cluster messages?
    --debug_console 0              Debug console I/O?
    --trace 0                      Protocol trace level

You can also specify these in the amq_server.cfg configuration file.

Log file format
===============

Logged data always shows the date and time, then a single letter to indicate the
type or severity of the message. E is an error, W is a warning, I indicates an
information message, and other letters are used to trace different types of
activity.
   
Monitoring the server
*********************

There are several ways to monitor a running OpenAMQ server process:

 1. Using the operating systems' process monitoring tools.
 2. Using the server's own monitoring output (--dump_state).
 3. Using the OpenAMQ Console ('amq_shell'), described below.

When using the operating system monitoring tools, you will want to look mainly
at the server's CPU and memory consumption.

The simplest way is to run the server using the --dump_state option. The
following example asks for output every five seconds:

    amq_server --dump_state 5

You can redirect the output to a dump file, and monitor the dump file using, on
a Unix, Linux or Mac OS/X system:

    tail -f name-of-dump-file

Command-line console
********************

The amq_shell provides a command-line administration tool for OpenAMQ. You can
use this tool by hand, or automatically in shell scripts. Normal OpenAMQ users
can view information; super users can also change the server's state, e.g.
killing blocked connections or over-full queues.

Console command line
====================

Run this command:

    amq_shell -u username -p password

These are the command-line options:

    -s hostname      Server hostname and :port (localhost)

If the amq_server is running on a different system and/or non-standard port,
use the -s option to specify the correct !servername:port!.

    -V virtualhost   Specify cluster virtual host

You need this when working with servers that are in a cluster configuration.
The cluster virtual host you specify must match that specified in the cluster
configuration.

    -u user          User name for console access (guest)

Specify the user name for the connection.

    -p password      Password for console access (guest)

Specify the password for the connection.

    -e "commands"    Run shell commands, delimited by ;

Specify a list of commands to run, which can be any commands that you may
type when in the amq_shell prompt (see below).

    -x filename      Save all status data as XML

Saves all printed data as an XML file, useful if you want to re-process the
data mechanically afterwards.

    -t level         Set trace level (default = 0)

Used to debug the communications between the Console and the OpenAMQ server.

    -b               Show server status and then exit

Show a summary of the server status, without entering the prompt.

    -r               Report all active local servers

Scan the current system for all OpenAMQ servers running on ports 4096-8192.
Will not attempt to look for servers above or below that range.

    -q               Show all server queues and exit

Show a summary list of all the server's queues, without entering the prompt.

    -c               Show all server connections and exit

Show a summary list of all the server's connections, without entering the prompt.

    -d               Show date and time in shell output

Add the date and time to all printed messages.

The Console prompt
==================

When the Console connects successfully to the default or specified OpenAMQ
server it will display a prompt so that you can enter commands:

    amq_shell/1.2b0 - Management Console for OpenAMQ Brokers
    Copyright (c) 2007 iMatix Corporation

    Connected to OpenAMQ Server/1.2b0 on 62.176.172.196:5672

     server = "OpenAMQ 1.2b0" 
     Date, time server started ............. 2007-03-15T12:55+01:00
     Broker is locked? ..................... no
     Memory used for all data .............. 10604K
     Memory used for messages .............. 1K
     Number of queued messages ............. 2
     Number of queue consumers ............. 1
     Number of queue bindings .............. 2
     Number of message exchanges ........... 8 [ls exchange]
     Number of shared queues ............... 0 [ls queue]
     Number of connections ................. 1 [ls connection]
     [shutdown] [lock] [shake]
    /62.176.172.196:5672>

Note that:

 * The available actions are listed in square brackets.  For example when
   you are looking at a server these are the available actions:

    [shutdown] [lock] [shake]

 * Type 'help' at any prompt to get explanations.  These commands are
   available at all times:

    Command            Has this effect
    -------            -------------------
    ls | dir           Show server and all children
    nnn                Look at item [nnn] (nnn is a number)
    ?text              Look at item matching text
    /                  Return to server item
    .                  Refresh current item
    ..                 Move back to previous item
    set name value     Set object property
    help               Show this text
    exit | quit        Leave the OpenAMQ shell

High-availability failover
**************************

OpenAMQ provides two distint clustering functionalities:

1. High-availability failover in which a pair of servers act as primary and
   backup so that if one server crashes, the other will still be available.
2. Federation, in which servers, or high-availability pairs, are built into 
   wide area networks, also known as 'federations'.

In this section we explain how to use high-availability failover.

High-availability scenarios
===========================

In general, OpenAMQ is designed to never crash.  Further, if it crashes it is
designed to be restartable very rapidly.  In other words, failover to a backup
server may be more complex, and less suitable, than simply restarting a single
primary server.

It makes sense to consider a failover solution when the data being carried over
the AMQP network is important enough to warrant a second physical server.  Even
when servers are well-specified, with redundant power supplies and disks, there
remains a chance of a fatal hardware failure.

For such scenarios, OpenAMQ offers a straight-forward failover model.

Note: the current implementation of the OpenAMQ client APIs do not allow
failover to be mixed with federation. This is a known limitation and scheduled
to be removed in a future update.

Simple example
==============

This failover.pal program demonstrates failover:

    <?xml?>
    <!-- 
        Demonstration of failover
        This script connects to a high-availability pair and sends messages to
        itself.  It runs in a loop, and reports the status of the failover pair.
        -->
    <pal script = "amq_pal_gen"5
        <session server = "localhost:5555 localhost:6666" failover = "5000">
            <if name = "server_port" value = "5555">
                <echo>Connected to primary server</echo>
            </if>
            <else>
                <echo>Connected to backup server</echo>
            </else>
            <wait />
        </session>
    </pal>
    
To build this, run the command 'pal failover'. We start two OpenAMQ servers as
follows, in two separate windows:

    amq_server --port 5555 --backup localhost:6666
    amq_server --port 6666 --primary localhost:5555


We demonstrate failover by starting the 'failover' test program and then killing
the primary server:

    $ failover
    Connected to primary server
    14:17:14: W: connection to server was lost, failing over
    14:17:15: E: connection to server failed: Socket error: Connection refused (localhost:5555)
    Connected to backup server
        
Client-side support
===================

WireAPI does not at present include failover support. This will be added in a
future release. For now, applications need to implement failover themselves in
the following manner (this is taken from the PAL framework, which implements
failover):

 - detect a failed connection, which is indicated by the connection>alive
   property being false, and the connection->reply_code being 100.
 - wait for some short interval (for example, five seconds).
 - reconnect to the failover server.
 
To do this properly, an application needs to know the primary and the backup
servers. Typically it knows this by splitting the server name into two tokens.

Here is an example C function that connects to the failover pair:

//  We set these global variables
static amq_client_connection_t *s_connection;
static amq_client_session_t *s_session;

static int s_establish_session (char *server_name)
{
    icl_longstr_t
        *auth_data;                     //  Login authorisation
    ipr_token_list_t
        *host_list;                     //  List of known hosts
    ipr_token_t
        *token;                         //  Next host to try
    int
        rc = 0;                         //  Return code

    //  Both connection and session must be null when we start
    assert (!s_connection && !s_session);
    
    //  Login using default guest credentials
    auth_data = amq_client_connection_auth_plain ("guest", "guest");
    
    //  Split host name into tokens, and check we have one or two names
    host_list = ipr_token_split (server_name);
    assert (ipr_token_list_count (host_list) == 1 
         || ipr_token_list_count (host_list) == 2);

    token = ipr_token_list_first (host_list);
    while (token) {
        s_connection = amq_client_connection_new (
            token->value, virtual_host, auth_data, instance_name, trace_level, 30000);
        if (s_connection) {
            ipr_token_unlink (&token);
            break;
        }
        token = ipr_token_list_next (&token);
    }
    ipr_token_list_destroy (&host_list);
    icl_longstr_destroy (&auth_data);

    if (s_connection) {
        s_connection->silent = TRUE;
        s_get_connection_symbols ();
        s_session = amq_client_session_new (s_connection);
        if (s_session) {
            s_session->silent = TRUE;
            s_start_time = apr_time_now ();     //  Restart the clock
        }
        else {
            icl_console_print ("E: could not open session to server");
            rc = -1;
        }
    }
    else {
        icl_console_print ("E: could not connect to %s", server_name);
        rc = -1;
    }
    return (rc);
}

static int
s_connection_failed (void)
{
    if (s_connection && !s_connection->alive && s_connection->reply_code == 100)
        return (1);
    else
        return (0);
}

    //  Try once more to connect to all listed servers
    exit_failover_1:
        icl_console_print ("W: connection to server was lost, failing over");
        amq_client_session_destroy (&s_session);
        amq_client_connection_destroy (&s_connection);
        apr_sleep (1000 * 1000);
        continue;                  //  Start session once again


Failover configuration
======================

Debugging failover
==================

Workled examples
================

Tuning failover
===============


Application support
===================

For HA clustering to work, applications must connect to first the primary
server, and if that fails, the backup server. Applications must use the correct
order (primary, then secondary).

Note that full HA support may be added at a later stage to WireAPI clients.

Cookbook
========

We take two servers, running on the same or different systems. One server is the
primary, one is the backup. When the cluster starts, the primary is master and
the backup is slave. If the primary dies, the backup takes over the role of
master. If the primary comes back, it remains slave. To reset the cluster,
restart the backup.

HA Configuration
================

You can share the same configuration for both servers by specifying the key
options on the command-line.  In amq_server.cfg, add this section:

    <cluster
        vhost = "/"
        primary_peer = "localhost:5555"
        backup_peer = "localhost:6666"
    />

Then start the two servers as follows (you can use any legal values for the
port numbers):

    amq_server --port 5555 --is_primary 1
    amq_server --port 6666 --is_backup 1

Alternatively you can use two separate configuration files, with the primary
server using this:

    <cluster
        vhost = "/"
        is_primary = "1"
        backup_peer = "localhost:6666"
    />

And the backup server using this:

    <cluster
        vhost = "/"
        is_backup = "1"
        primary_peer = "localhost:5555"
    />

Virtual host setting
====================

The virtual host (vhost) setting is used to ensure that connecting applications
are using the correct cluster. This value must match the value used by
applications.  Use a setting that matches the environment, e.g. "debug" or 
"test".

Federation
**********

Federation lets you chain OpenAMQ servers together.  This solves certain
problems of scaling, e.g. letting you define regional hubs that speak to a
global central server.  Federation is especially useful in high-volume pub-sub
scenarios.

Cookbook
========

We connect an exchange on one server (or HA pair of servers) to the matching
exchange on a remote server (or HA pair of servers).

The local exchange either sends messages to the remote exchange, or subscribes
to messages from it.

There are four message transfer modes:

1. Subscriber forwarding - the local exchange requests messages from the remote
   exchange.
2. Full forwarding - the local exchange forwards all messages to the remote
   exchange.
3. Default forwarding - the local exchange forwards only unmatched messages to
   the remote exchange.
4. Bidirectional forwarding - the local exchange forwards to the remote 
   exchange, and vice versa.

Subscription forwarding
=======================

The classic scenario is when local applications want to receive topic data
published centrally.

The configuration looks like this:

    <federation
        name = "exchange-name"
        vhost = "virtual-host-name"
        host = "remotehost:port"
        login = "peering"
        mode = "1"
    />

All bindings made to the specified exchange are copied to the specified remote
host exchange.

Most often used with topic or headers exchanges.

Worked example:

 - A set of clients in a regional office need to get market data from a
   central server.

 - The configuration is done entirely at the regional office by defining an
   MTA that connects the market data exchanges on both servers.

 - When data is published centrally, any messages that match requests from
   the regional applications are forwarded to the regional server.

Full message forwarding
=======================

The classic scenario is when local applications want to publish data both to
local clients and remote ones.

The configuration looks like this:

    <federation
        name = "exchange-name"
        vhost = "virtual-host-name"
        host = "remotehost:port"
        login = "peering"
        mode = "2"
    />

All messages published to the local exchange are automatically published to the
remote exchange as well.

Most often used with topic or headers exchanges.

Default message forwarding
==========================

The classic scenario is when local applications want to use services that could
be either local, or remote.

The configuration looks like this:

    <federation
        name = "exchange-name"
        vhost = "virtual-host-name"
        host = "remotehost:port"
        login = "peering"
        mode = "3"
    />

All messages published to the local exchange are automatically published to the
remote exchange only if they are not delivered locally.

Most often used with direct exchanges so that services can be placed either
locally or remotely, invisibly to the applications.

Bidirectional forwarding
========================

Bidirectional mode (4) passes messages on particular exchange from in both
directions. You cannot achieve this behaviour by combining modes 1 and 2 as
every message would be circulated endlessly between the two servers. However,
note that this mode is not particularly efficient. For best performance create
two exchanges instead of a single one and pass messages only in appropriate
directions.

The configuration looks like this:

    <federation
        name = "exchange-name"
        vhost = "virtual-host-name"
        host = "remotehost:port"
        login = "peering"
        mode = "3"
    />

