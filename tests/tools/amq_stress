#!/usr/bin/perl
use strict;

use IO::Handle;
use Getopt::Long;
use Pod::Usage;
use Time::HiRes;
use POSIX ":sys_wait_h";

# Variables used to map the command line options to, and their defaults.
my $man = 0;
my $help = 0;
my $color = 0;
my $debug = 0;
my $processes = 1;
my $killexpr = undef;
my $exec = undef;
my $subchild = 0;
my $respawncount = 0;
my $stop = 0;
my $killsig = 2;

# Parse the options from the command line.
GetOptions('help|?'     => \$help, 
           'man'        => \$man,
           'debug!'     => \$debug,
           'color|c!'   => \$color,
           'stop|s!'   =>  \$stop,
           'exec|e=s'   => \$exec,
           'kill|k=s'   => \$killexpr,
           'signal|s=s' => \$killsig,
           'number|n=n' => \$processes,
           'respawn|r=n' => \$respawncount,
          ) or pod2usage(2);

pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;
pod2usage(1) unless $exec;

# Global variables used to keep track of parent/child relations.
our $parent = $$;
our $childnr;

# Signal handeling
sub quit { print "[$$] SIGINT received. quitting...\n" if $debug; reap(); exit; }
sub reap { print "[$$] {$?} reaping child...\n" if $debug; wait(); }
sub alarm { if($subchild != 0) { print "+++ Automatic kill($killsig,$subchild) sent. killing pid [$subchild] +++\n"; kill ($killsig,$subchild); } } 
$SIG{ALRM} = \&alarm;
$SIG{CHLD} = \&reap;
$SIG{INT} = \&quit;

# A pipe to let the children communicate to the parent.
pipe (CHILD_OUT, PARENT_IN);
CHILD_OUT->autoflush(1);
PARENT_IN->autoflush(1);

# Start spawning processes from here on.
spawn ($processes);

if ($$ == $parent) {
    # The parent process.
    sub stop { print ":::::::::::::::::::::::: kill -HUP $$ ::::::::::::::::::::::::::::\n"; kill (1, -$$); }
    $SIG{USR1} = \&stop;
    close PARENT_IN;
    while (chomp (my $line = <CHILD_OUT>)) {
        print $line."\n";
    }
    print "[$$]{p} waiting for children to finish\n";
    wait (); 
    print "[$$]{p} finished\n";
    close CHILD_OUT;
} else {
    # The child process.
    close CHILD_OUT;
    
    for (my $i = 0; $i <= $respawncount; $i++) {
        my ($hl,$dl);
        $hl = '['.(int(($childnr%16)/7)).';3'.($childnr%7 || 7)."m" if ($color);
        $dl = '[1;37m' if ($color);
       
        my $evalcmd = $exec;
        $evalcmd =~ s/\$i/$childnr/g;
        $evalcmd =~ s/{([^}]*)}/eval "$1"/eg;
        
        $subchild = open (CMD,"$evalcmd |");
        my $evalkillexpr;
        if ($killexpr) {
            $evalkillexpr = $killexpr;
            $evalkillexpr =~ s/\$i/$childnr/g;
            $evalkillexpr =~ s/{([^}]*)}/eval "$1"/eg;
            $evalkillexpr =~ s/[^\d.]//g;
            Time::HiRes::alarm $evalkillexpr;
        }
        print "<<< spawning: '$evalcmd'";
        print " kill in [${evalkillexpr}s] " if($evalkillexpr);
        print ">>>\n";
        
        while (chomp (my $line = <CMD>)) {
            print PARENT_IN $hl."[$subchild]{".$childnr."} $line $dl\n";
        }
        if ($?) {
            # I'm not sure $? is set correctly here, not using these for now
            my $retvalue = $? >> 8;
            my $signal = $? >> 127;
            my $coredump = $? >> 128;
            if($stop) {
                close CMD;
                close CHILD_OUT;
                close PARENT_IN;
                kill (10, $parent);
                exit($?);
            }
        }
        close CMD;
    }
    close PARENT_IN;
}


# A subroutine to spawn (fork) the children.
sub spawn {
    my $count = shift;
    for (my $i = 1; $i <= $count; $i++) {
        $childnr = $i;
        my $childpid = fork ();
        # Get out of the loop if we're in the child process, 
        # only the parent should spawn children
        last if $childpid == 0;
    }
}

    

__END__

=head1 NAME

amq_stress - A stress test tool which spawns other processes.

=head1 AUTHOR

Tim Esselens <tim@imatix.net>

=head1 SYNOPSIS

amq_stress [options] --exec program

 the string provided to the exec and kill argument can contain some magic:
 - every $i will be replaced with the number of the current child process (counting from 1 to total children)
 - every {} (block) will be eval'ed

 examples:
    
    amq_stress -n 10 --exec "echo this is child \$i";
    amq_stress -n 10 --exec 'echo this is child $i'";
    amq_stress -n 10 --exec 'echo this is child $i with a random number: { int(rand(10)) }';
    amq_stress -n 10 --exec './amq_client -n { int(rand(10) * 1000) } 2>&1';
    amq_stress -n 10 -r 2 --kill '{ rand(10) }' --exec './amq_client -n { int(rand(10) * 1000) } 2>&1';
    amq_stress -s 9 -c -n 2 -r 4 -k 1 -e 'echo "sleeping..."; sleep 10; echo $i {rand 10} {rand 20}'

=head1 OPTIONS

=over 8

=item B<--exec>
The program that will be spawned.

=item B<--number>
Number of children to spawn.

=item B<--kill>
Time in seconds before killing the child.

=item B<--signal>
Signal number to kill with. ie: SIG_INT = 2, (see man kill)

=item B<--stop>
Stop all other children if one of them fails

=item B<--respawn>
Number of times to respawn the children if they die or finish.

=item B<--help>
Print a brief help message and exits.

=item B<--man>
Prints the manual page and exits.

=item B<--color>
Output in color on ansi capable terminals.

=item B<--debug>
Be a bit more verbose, only usefull when developing spawn.

=back

=head1 NOTE

Every command line option can be written in its short form, for example --exec can
also be written as --exe or -e.

Only STDOUT is colorized, use 2>&1 to redirect STDERR to STDOUT so it is colorized too.

=head1 DESCRIPTION

B<amq_stress> will spawn several processes of the desired binary.

=cut
