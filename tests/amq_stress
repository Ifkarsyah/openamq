#!/usr/bin/perl
use strict;

use IO::Handle;
use Getopt::Long;
use Pod::Usage;
use Time::HiRes;
use POSIX ":sys_wait_h";

# Variables used to map the command line options to, and their defaults.
my $man = 0;
my $help = 0;
my $color = 0;
my $debug = 0;
my $processes = 1;
my $killexpr = undef;
my $exec = undef;

# Parse the options from the command line.
GetOptions('help|?'     => \$help, 
           'man'        => \$man,
           'debug!'     => \$debug,
           'color|c!'   => \$color,
           'exec|e=s'   => \$exec,
           'kill|k=s'   => \$killexpr,
           'number|n=n' => \$processes,
          ) or pod2usage(2);

pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;
pod2usage(1) unless $exec;

# Global variables used to keep track of parent/child relations.
our $parent = $$;
our $childnr;


# Signal handeling
sub quit { print "[$$] SIGINT received. quitting...\n" if $debug; reap(); }
sub reap { print "[$$] reaping child...\n" if $debug; wait(); }
sub alarm { print "+".('-'x79)."\n| Automatic SIG_INT sent. killing pid [$$]\n+".('-'x80)."\n\n"; `echo killing $$ >> /tmp/log; kill -2 $$ && echo kill OK || echo kill NOK`; } 
$SIG{CHLD} = \&reap;
$SIG{INT} = \&quit;

# A pipe to let the children communicate to the parent.
pipe (CHILD_OUT, PARENT_IN);
CHILD_OUT->autoflush(1);
PARENT_IN->autoflush(1);

# Start spawning processes from here on.
spawn ($processes);

if ($$ == $parent) {
    # The parent process.
    close PARENT_IN;
    while (chomp (my $line = <CHILD_OUT>)) {
        print $line."\n";
    }
    print "[$$]{p} waiting for children to finish\n";
    wait (); 
    print "[$$]{p} finished\n";
    close CHILD_OUT;
} else {
    # The child process.
    close CHILD_OUT;
   
    $SIG{ALRM} = \&alarm;
    $SIG{INT} =  \&x; # should be default
    sub x { print "INT ARRIVED\n\n\n";};
    $SIG{CHLD} = 'DEFAULT';
    
    if($killexpr) {
        $killexpr =~ s/\$i/$childnr/g;
        $killexpr =~ s/{([^}]*)}/eval "$1"/eg;
        $killexpr =~ s/[^\d.]//g;
        Time::HiRes::alarm $killexpr;
    }
    
    my ($hl,$dl);
    $hl = '['.(int(($childnr%16)/7)).';3'.($childnr%7 || 7)."m" if ($color);
    $dl = '[1;37m' if ($color);
    
    $exec =~ s/\$i/$childnr/g;
    $exec =~ s/{([^}]*)}/eval "$1"/eg;
    
    if($childnr == 1) { print (('-'x100)."\n"); }
    print $hl."[$$]{$childnr} spawning: '$exec'";
    print " WILL BE KILLED IN $killexpr seconds" if($killexpr);
    print $dl."\n";
    if($childnr == $processes) { print (('-'x100)."\n\n\n\n"); }
    
    open (CMD,"$exec |");
    while (chomp (my $line = <CMD>)) {
        print PARENT_IN $hl."[$$]{".$childnr."} $line $dl\n";
    }
    close PARENT_IN;
}


# A subroutine to spawn (fork) the children.
sub spawn {
    my $count = shift;
    for (my $i = 1; $i <= $count; $i++) {
        $childnr = $i;
        my $childpid = fork ();
        # Get out of the loop if we're in the child process, 
        # only the parent should spawn children
        last if $childpid == 0;
    }
}

    

__END__

=head1 NAME

amq_stress - A stress test tool which spawns other processes.

=head1 AUTHOR

Tim Esselens <tim@imatix.net>

=head1 SYNOPSIS

amq_stress [options] --exec program

 the string provided to the exec and kill argument can contain some magic:
 - every $i will be replaced with the number of the current child process (counting from 1 to total children)
 - every {} (block) will be eval'ed

 examples:
    amq_stress -n 10 --exec "echo this is child \$i";
    amq_stress -n 10 --exec 'echo this is child $i'";
    amq_stress -n 10 --exec 'echo this is child $i with a random number: { int(rand(10)) }';
    amq_stress -n 10 --exec './amq_client -n { int(rand(10) * 1000) } -Q queue_$i -b 500 -r 10 2>&1';
    amq_stress -n 10 --kill '{ rand(10) }' --exec './amq_client -n { int(rand(10) * 1000) } -Q queue_$i -b 500 -r 10 2>&1';

=head1 OPTIONS

=over 8

=item B<--exec>
The program that will be spawned.

=item B<--number>
Number of children to spawn.

=item B<--help>
Print a brief help message and exits.

=item B<--man>
Prints the manual page and exits.

=item B<--color>
Output in color on ansi capable terminals.

=item B<--kill>
Time in seconds (float), after which the child will be send a SIG_INT

=item B<--debug>
Be a bit more verbose, only usefull when developing amq_stress.

=back

=head1 NOTE

Every command line option can be written in its short form, for example --exec can
also be written as --exe or -e.

Only STDOUT is colorized, use 2>&1 to redirect STDERR to STDOUT so it is colorized too.

=head1 DESCRIPTION

B<amq_stress> will spawn several processes of the desired binary.

=cut
