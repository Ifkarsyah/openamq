#!/usr/bin/perl
use strict;

use IO::Handle;
use Getopt::Long;
use Pod::Usage;
use Time::HiRes;
use POSIX ":sys_wait_h";

# Variables used to map the command line options to, and their defaults.
my $man = 0;
my $help = 0;
my $color = 0;
my $debug = 0;
my $processes = 1;
my $killexpr = undef;
my $exec = undef;
my $subchild = 0;
my $respawncount = 0;

# Parse the options from the command line.
GetOptions('help|?'     => \$help, 
           'man'        => \$man,
           'debug!'     => \$debug,
           'color|c!'   => \$color,
           'exec|e=s'   => \$exec,
           'kill|k=s'   => \$killexpr,
           'number|n=n' => \$processes,
           'respawn|r=n' => \$respawncount,
          ) or pod2usage(2);

pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;
pod2usage(1) unless $exec;

# Global variables used to keep track of parent/child relations.
our $parent = $$;
our $childnr;


# Signal handeling
sub quit { print "[$$] SIGINT received. quitting...\n" if $debug; reap(); exit; }
sub reap { print "[$$] reaping child...\n" if $debug; wait(); }
sub alarm { print "+++ Automatic SIG_INT sent. killing pid [$subchild] +++\n"; kill (2,$subchild); } 
$SIG{ALRM} = \&alarm;
$SIG{CHLD} = \&reap;
$SIG{INT} = \&quit;

# A pipe to let the children communicate to the parent.
pipe (CHILD_OUT, PARENT_IN);
CHILD_OUT->autoflush(1);
PARENT_IN->autoflush(1);

# Start spawning processes from here on.
spawn ($processes);

if ($$ == $parent) {
    # The parent process.
    close PARENT_IN;
    while (chomp (my $line = <CHILD_OUT>)) {
        print $line."\n";
    }
    print "[$$]{p} waiting for children to finish\n";
    wait (); 
    print "[$$]{p} finished\n";
    close CHILD_OUT;
} else {
    # The child process.
    close CHILD_OUT;
    
    for(my $i = 0; $i <= $respawncount; $i++) {
        if($killexpr) {
            $killexpr =~ s/\$i/$childnr/g;
            $killexpr =~ s/{([^}]*)}/eval "$1"/eg;
            $killexpr =~ s/[^\d.]//g;
            Time::HiRes::alarm $killexpr;
        }
        
        my ($hl,$dl);
        $hl = '['.(int(($childnr%16)/7)).';3'.($childnr%7 || 7)."m" if ($color);
        $dl = '[1;37m' if ($color);
        
        $exec =~ s/\$i/$childnr/g;
        $exec =~ s/{([^}]*)}/eval "$1"/eg;
        
        print "<<< spawning: '$exec'";
        print " kill in [${killexpr}s] " if($killexpr);
        print ">>>\n";
        
        $subchild = open (CMD,"$exec |");
        while (chomp (my $line = <CMD>)) {
            print PARENT_IN $hl."[$subchild]{".$childnr."} $line $dl\n";
        }
        close CMD;
    }
    close PARENT_IN;
}


# A subroutine to spawn (fork) the children.
sub spawn {
    my $count = shift;
    for (my $i = 1; $i <= $count; $i++) {
        $childnr = $i;
        my $childpid = fork ();
        # Get out of the loop if we're in the child process, 
        # only the parent should spawn children
        last if $childpid == 0;
    }
}

    

__END__

=head1 NAME

amq_stress - A stress test tool which spawns other processes.

=head1 AUTHOR

Tim Esselens <tim@imatix.net>

=head1 SYNOPSIS

amq_stress [options] --exec program

 the string provided to the exec and kill argument can contain some magic:
 - every $i will be replaced with the number of the current child process (counting from 1 to total children)
 - every {} (block) will be eval'ed

 examples:
    amq_stress -n 10 --exec "echo this is child \$i";
    amq_stress -n 10 --exec 'echo this is child $i'";
    amq_stress -n 10 --exec 'echo this is child $i with a random number: { int(rand(10)) }';
    amq_stress -n 10 --exec './amq_client -n { int(rand(10) * 1000) } -Q queue_$i -b 500 -r 10 2>&1';
    amq_stress -n 10 -r 2 --kill '{ rand(10) }' --exec './amq_client -n { int(rand(10) * 1000) } -Q queue_$i -b 500 -r 10 2>&1';

=head1 OPTIONS

=over 8

=item B<--exec>
The program that will be spawned.

=item B<--number>
Number of children to spawn.

=item B<--kill>
Time in seconds (float), after which the child will be send a SIG_INT

=item B<--respawn>
Number of times to respawn the children if they die or finish.

=item B<--help>
Print a brief help message and exits.

=item B<--man>
Prints the manual page and exits.

=item B<--color>
Output in color on ansi capable terminals.

=item B<--debug>
Be a bit more verbose, only usefull when developing amq_stress.

=back

=head1 NOTE

Every command line option can be written in its short form, for example --exec can
also be written as --exe or -e.

Only STDOUT is colorized, use 2>&1 to redirect STDERR to STDOUT so it is colorized too.

=head1 DESCRIPTION

B<amq_stress> will spawn several processes of the desired binary.

=cut
