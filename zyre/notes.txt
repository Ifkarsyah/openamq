JSON parser in C
new XML parser that is known solid

synchronization with AMQP
    - what feeds come from OpenAMQ:
        - shared queues -> feedname
        - all exchanges
    - when AMQP provides feed,
        - create in restms object if new

    amqp_name
        - pipe: private name
        - feed: private or public name

creating a new resource, e.g. pipe in feed
    - parse XML and get specification - OK
    - check if valid child resource
    - ask restms to create it for us
    - continue with whatever work is needed

    - we need to check that resource child type is valid
    - restms can create resource
    - arguments
        - context (includes type and XML)
        - ourselves (as parent)
    - restms needs to check if resource already exists or not
        - create with name is idempotent
        - name is attribute of XML item
    - restms can create the resource and attach it to the parent
        - and either pass immediately or send it the XML spec
        - and then we can respond OK or Created
    - maybe attach-to-parent can be method
    - maybe configure-resource can be method

    zyre_resource_t
        *domain_factory;                //  Domain resource factory
    self->domain_factory = zyre_domain__zyre_resource_factory (NULL, NULL, NULL, NULL);
    zyre_restms__zyre_resource_bind (self, self->domain_factory);
    resource = zyre_resource_factory (self->domain_factory, NULL, self->resources, "domain", "");
    zyre_restms__zyre_resource_bind (self, resource);
    zyre_resource_unlink (&resource);

    //  Create new resource of specified type
    ipr_looseref_t
        *looseref;
    zyre_resource_t
        *factory,
        *resource;

    looseref = ipr_looseref_list_first (self->zyre_resource_factory_list);
    while (looseref) {
        factory = (ipr_demo_resource_t *) (looseref->object);
        if (streq (factory->name, "my-type")) {
            resource = zyre_resource_factory (factory, "item-name");
            break;                  //  Have a match
        }
        looseref = ipr_looseref_list_next (&looseref);
    }

- create resource factories at startup


POST to URI
    - parse XML
    - if missing, ok
    - if illegal XML, not ok

new resource
    calculate URI
    look for existing resource
    if exists
        200 ok
    else
        parse XML
            when getting request
            parse json (really?) or xml
                do json later only
                document limitation
            if invalid, 400 Bad request
            else pass first child item
            if other content type, don't parse
                - pass null
        create object as specified
        create new resource for URI
        201 created
        attach resource to parent
            add looseref to parent's list
            set parent in object
        get resource XML from object

new resource from openamq
    always public resource
    always locked


domain, feed, pipe, join, message
    report
    accept


    zyre_backend_request_feed_create (self->backend, "service", "test.service");
    zyre_backend_request_feed_create (self->backend, "direct", "test.direct");
    zyre_backend_request_pipe_create (self->backend, "fifo", "test.pipe");
    zyre_backend_request_join_create (self->backend,
        "test.pipe", "direct", "test.direct", "routing-key");
    zyre_backend_request_join_create (self->backend,
        "test.pipe", "service", "test.service", "*");

zyre_content class
    content_type
    content_encoding
    bucket (limit content to 2MB for now)
        overflow to file, later
        limitation needs to be documented


- in openamq, synchronize back with zyre
    - add method Feed.Sync to class
    - if server gets this, syncs all exchange & shared queues back to RestMS




    - zyre_resource_new (table,


- handle in zyre_restms class:
    Domain  GET POST (feed, pipe)
    Feed    GET PUT DELETE POST (message)
    Pipe    GET PUT DELETE POST (join)
    Join    GET PUT DELETE
    Message GET DELETE
    Content GET DELETE




define pipe that sends messages back to feed
    - allows proxy selection, macroisation

define fair queue mechanism that takes input from several feeds but fairly
    - implement natively in openamq?
    - ...?



HTTP headers

C:
If-Match: "entity-tag" | "*"
    Conditional PUT, update entry if entry still has the same Etag
    Else 412 Precondition failed, with Date: header
    If any other error (except 2xx or 412) would happen, must happen anyhow
    "*" means only if the entity already exists, MUST NOT if the entity does not exist
If-Modified-Since: date
    Conditional GET, 304 Not Modified if entry has same or older date
    If any other error (except 200 or 304) behaviour is as for normal GET
If-None-Match: "entity-tag" | "*"
    Conditional GET, get 304 Not Modified if entry has the same Etag
    "*" means only if entity does not exist, MUST NOT if the entity does exist
    used to prevent race conditions between PUTs
If-Range: "entity-tag"
    Used together with Range: header (for getting files?)
    Gets 206 Partial Content range if entity matches
    Gets 200 OK whole content if entity does not match
If-Unmodified-Since: date
    Does operation only if entity has not been modified since date
    Else returns 412 Precondition failed
    If any other error (except 2xx or 412), behaviour is as if absent

S:
ETag: "entity-tag"
    Date-Size-Inode or Date-Size
Last-Modified: date
    Last date of modification
Location: absolute-uri
    For 201 Created and for 3xx responses


Implement exchange logic in zyre and do federation

config
    amqp server name
    amqp server login and password
    client logins
        - basic auths
        - not same as openamq credentials


RESTful extensions to AMQP
    - RestMS protocol class
    - * in topics matches empty routing-key
    - empty topic segments are allowed (".value")

