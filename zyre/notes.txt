synchronization with AMQP
    - keep list of pipes
    - keep list of feeds
    - keep list of joins
        - create/destroy instructions from front
        - based on URI

    - if amqp provides us with feed
        - add to list if not already defined

    pipe
        pipe_table
    feed
        feed_table
    join
        join_list


    zyre_restms_domain
    zyre_restms_pipe
    zyre_restms_feed
    zyre_restms_etc.

    //  Create new resource of specified type
    ipr_looseref_t
        *looseref;
    zyre_resource_t
        *factory,
        *resource;

    looseref = ipr_looseref_list_first (self->zyre_resource_factory_list);
    while (looseref) {
        factory = (ipr_demo_resource_t *) (looseref->object);
        if (streq (factory->name, "my-type")) {
            resource = zyre_resource_factory (factory, "item-name");
            break;                  //  Have a match
        }
        looseref = ipr_looseref_list_next (&looseref);
    }




new resource
    calculate URI
    look for existing resource
    if exists
        200 ok
    else
        parse XML
            when getting request
            parse json (really?) or xml
                do json later only
                document limitation
            if invalid, 400 Bad request
            else pass first child item
            if other content type, don't parse
                - pass null
        create object as specified
        create new resource for URI
        201 created
        attach resource to parent
            add looseref to parent's list
            set parent in object
        get resource XML from object

new resource from openamq
    always public resource
    always locked


domain, feed, pipe, join, message
    report
    accept


zyre_content class
    content_type
    content_encoding
    bucket (limit content to 2MB for now)
        overflow to file, later
        limitation needs to be documented


- in openamq, synchronize back with zyre
    - add method Feed.Sync to class
    - if server gets this, syncs all exchange & shared queues back to RestMS




    - zyre_resource_new (table,


- handle in zyre_restms class:
    Domain  GET POST (feed, pipe)
    Feed    GET PUT DELETE POST (message)
    Pipe    GET PUT DELETE POST (join)
    Join    GET PUT DELETE
    Message GET DELETE
    Content GET DELETE




define pipe that sends messages back to feed
    - allows proxy selection, macroisation

define fair queue mechanism that takes input from several feeds but fairly
    - implement natively in openamq?
    - ...?



HTTP headers

C:
If-Match: "entity-tag" | "*"
    Conditional PUT, update entry if entry still has the same Etag
    Else 412 Precondition failed, with Date: header
    If any other error (except 2xx or 412) would happen, must happen anyhow
    "*" means only if the entity already exists, MUST NOT if the entity does not exist
If-Modified-Since: date
    Conditional GET, 304 Not Modified if entry has same or older date
    If any other error (except 200 or 304) behaviour is as for normal GET
If-None-Match: "entity-tag" | "*"
    Conditional GET, get 304 Not Modified if entry has the same Etag
    "*" means only if entity does not exist, MUST NOT if the entity does exist
    used to prevent race conditions between PUTs
If-Range: "entity-tag"
    Used together with Range: header (for getting files?)
    Gets 206 Partial Content range if entity matches
    Gets 200 OK whole content if entity does not match
If-Unmodified-Since: date
    Does operation only if entity has not been modified since date
    Else returns 412 Precondition failed
    If any other error (except 2xx or 412), behaviour is as if absent

S:
ETag: "entity-tag"
    Date-Size-Inode or Date-Size
Last-Modified: date
    Last date of modification
Location: absolute-uri
    For 201 Created and for 3xx responses


Implement exchange logic in zyre and do federation

config
    amqp server name
    amqp server login and password
    client logins
        - basic auths
        - not same as openamq credentials


RESTful extensions to AMQP
    - RestMS protocol class
    - * in topics matches empty routing-key
    - empty topic segments are allowed (".value")

