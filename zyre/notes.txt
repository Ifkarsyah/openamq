- multiple messages
    <message ... />
- no content, headers only
    <message ...>
        <content href="{staged content uri}" />
    </message>
- if no such content, 404
- else deletes content on sending
    <message ...>
        <content type="{mime type}" encoding="{text encoding}">content body</content>
    </message>
- document message sending & receiving in detail
- document use case for RestMS
- document: server MAY decode content before sending if encoding is "base64"
    The Base16, Base32, and Base64 Data Encodings
    http://tools.ietf.org/html/rfc4648


- if client times out and pipe is still waiting, tries to send to invalid content

- multiple messages
my $content = <<EOF;
<restms>
  <message address="address.multi.1" message_id="ID1">
    <header name="serial-number" value="0001" />
    <content>It's too cold</content>
  </message>
  <message address="address.multi.2" message_id="ID2">
    <header name="serial-number" value="0002" />
    <content>It's too hot</content>
  </message>
  <message address="address.multi.3" message_id="ID3">
    <header name="message_id" value="ID3" />
    <header name="serial-number" value="0003" />
    <content>It's just right!</content>
  </message>
</restms>
EOF
$restms->raw ("POST", "/restms/feed/default", $content);

- feed security
    - password on creation
    - provide in posts

- join selftest
- test pipe asynchrony
- test message content vs. embedded
- test message batching


#   Test public service feed
my $feed = $restms->feed_create ("test.service", "service");
my $pipe = $restms->pipe_create ("fifo");
my $join = $restms->join_create ($pipe, $feed, "*");

$restms->content ("This is a request", "text/plain");
$restms->send ($feed);
$message = $restms->recv ($pipe);
$restms->delete ($feed);
$restms->delete ($pipe);
$restms->delete ($join);

#   --------- Topic publish/subscribe

#
#   --------- Errors ----------------
#   Invalid URI path
$restms->raw ("GET",    "/restms/invalid", undef, 400);
$restms->raw ("PUT",    "/restms/invalid", undef, 400);
$restms->raw ("DELETE", "/restms/",        undef, 400);
$restms->raw ("POST",   "/restms/invalid", undef, 400);

#   Non-existent resources
$restms->raw ("GET",  "/restms/domain/none", undef, 404);
$restms->raw ("PUT",  "/restms/pipe/nosuch", undef, 404);
$restms->raw ("POST", "/restms/feed/nosuch", undef, 404);

#   Badly structured documents
my $feed = $restms->feed_create ("test.service", "service");
$restms->raw ("PUT", $feed, '<restms/>', 400);
$restms->raw ("PUT", $feed, '<restmas><type="fanout" /></restmas>', 400);
$restms->raw ("PUT", $feed, '<restms><fud type="fanout" /></restms>', 400);
$restms->raw ("PUT", $feed, '<restms><feed type="fanout" />', 400);

#   Bad pipe types
$restms->pipe_create ("fido", 400);

#   Bad feed types
$restms->feed_create ("test.fanin", "fanin", 400);
$restms->get    ("/restms/feed/test.fanin", 404);
$restms->put    ("/restms/feed/test.fanin", '<restms><domain title="New title"/></restms>', 404);
$restms->delete ("/restms/feed/test.fanin");
$feed = $restms->feed_create ("test.fanin", "fanout");
$restms->delete ($feed);

#   Bad feed types
my $feed = $restms->feed_create ("test.fanout", "fanin", 400);

#   Invalid joins
my $feed = $restms->feed_create ("test.fanout", "fanout");
my $pipe = $restms->pipe_create ("fifo");
$restms->join_create ($pipe, "", "*", 400);
$restms->join_create ($pipe, "/restms/feed/unknown", "*", 400);
$restms->join_create ("/restms/pipe/unknown", $feed, "*", 404);
$restms->delete ($feed);
$restms->delete ($pipe);




need to learn GIT and make gitub for restms work
    - specs, sample code
    - addons
    restms.org


live.zyre.com

zyre.com
    - documentation
    - examples
    - binaries, packages


JSON parser in C
new XML parser that is known solid

synchronization with AMQP
    - what feeds come from OpenAMQ:
        - shared queues -> feedname
        - all exchanges
    - when AMQP provides feed,
        - create in restms object if new


new resource from openamq
    always public resource
    always locked

- in openamq, synchronize back with zyre
    - add method Feed.Sync to class
    - if server gets this, syncs all exchange & shared queues back to RestMS



AMQP synchronization
    - resource->private property

Rainey
    - JPMC, DJ followup
    - AMQP WG meetings each week: attend, report
    - follow issues on openamq.org
    - assist at FOSDEM
    - logo for X5
    - black t-shirts for X5 & FOSDEM

zyre_content class
    content_type
    content_encoding
    bucket (limit content to 2MB for now)
        overflow to file, later
        limitation needs to be documented


define pipe that sends messages back to feed
    - allows proxy selection, macroisation

define fair queue mechanism that takes input from several feeds but fairly
    - implement natively in openamq?
    - ...?



Implement exchange logic in zyre and do federation

config
    amqp server name
    amqp server login and password
    client logins
        - basic auths
        - not same as openamq credentials


RESTful extensions to AMQP
    - RestMS protocol class
    - * in topics matches empty routing-key
    - empty topic segments are allowed (".value")

