- implement joins
- catch duplicate joins
- report duplicate join
- catch other errors during configuration
- create default feed
- default join from all pipes to default feed
- filter default feed & joins in backend
- pipe report joins
    OK
- RestMS class needs to fix error handling
    OK
- multiple messages
    OK
    <message ... />
- no content, headers only
    OK
    <message ...>
        <content href="{staged content uri}" />
    </message>
- if no such content, 404
- else deletes content on sending
    OK
    <message ...>
        <content type="{mime type}" encoding="{text encoding}">content body</content>
    </message>
    OK
- DELETE content on feed
    OK
- GET content on feed
<?xml version="1.0"?>
<restms xmlns = "http://www.imatix.com/schema/restms">
    <content type = "text/plain" length = "19" />
</restms>
    OK
- set private properly on resources
    OK
- get content
    - return bucket of data and type
    OK
- get content headers into message resource
    OK
- report message headers at get
    OK
- get feed, address fields from Basic.Deliver
    OK

- document message sending & receiving in detail
- document use case for RestMS
- document: server MAY decode content before sending if encoding is "base64"
    The Base16, Base32, and Base64 Data Encodings
    http://tools.ietf.org/html/rfc4648


asynclets
    - generate message resource with no content and 'waiting'
    - when get that message, don't respond
        - mark pipe as waiting point to asynclet
    - when content arrives,
        - if pipe is waiting, get asynclet
        - configure with message data
        - respond to client thread
            - save portal in message

get pipe
    - list messages
    - add asynclet

get message
    - if synchronous,
        get message details
    - if asynchronous
        - do not
        wait until message arrives
        get method does not reply immediately



RestMS classes

    $restms = RestMS->new (hostname)

    $resource = $restms->resource_new ()
    RestMS::Resource->new ($restms)


    $domain = $restms->new_domain ();

    $domain = RestMS::Domain->new ($restms);
    ->get
    ->put
    ->delete
    -> return reply code
    ->

    create object: by posting to parent
    new needs to specify parent
    and also name
    tries to fetch object

    ->new (parent, name)


need to learn GIT and make gitub for restms work
    - specs, sample code
    - addons
    restms.org

zyre.com
    - documentation
    - examples
    - binaries, packages


JSON parser in C
new XML parser that is known solid

synchronization with AMQP
    - what feeds come from OpenAMQ:
        - shared queues -> feedname
        - all exchanges
    - when AMQP provides feed,
        - create in restms object if new


new resource from openamq
    always public resource
    always locked

- in openamq, synchronize back with zyre
    - add method Feed.Sync to class
    - if server gets this, syncs all exchange & shared queues back to RestMS



AMQP synchronization
    - resource->private property

Rainey
    - JPMC, DJ followup
    - AMQP WG meetings each week: attend, report
    - follow issues on openamq.org
    - assist at FOSDEM
    - logo for X5
    - black t-shirts for X5 & FOSDEM

zyre_content class
    content_type
    content_encoding
    bucket (limit content to 2MB for now)
        overflow to file, later
        limitation needs to be documented


define pipe that sends messages back to feed
    - allows proxy selection, macroisation

define fair queue mechanism that takes input from several feeds but fairly
    - implement natively in openamq?
    - ...?



Implement exchange logic in zyre and do federation

config
    amqp server name
    amqp server login and password
    client logins
        - basic auths
        - not same as openamq credentials


RESTful extensions to AMQP
    - RestMS protocol class
    - * in topics matches empty routing-key
    - empty topic segments are allowed (".value")

