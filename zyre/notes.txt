A RestMS application can be as simple as this fully working "Hello World!" example in Perl:

[[code]]
#!/usr/bin/perl
#   Hello World application for RestMS
#
use LWP::UserAgent;
use HTTP::Request::Common;

my $hostname = $ARGV [0]? $ARGV [0]: "localhost";
my $base = "http://$hostname/restms";
my $ua = new LWP::UserAgent;
$ua->agent ('Perl');
$ua->credentials ($hostname, "RestMS", "guest", "guest");

#   In one step, create a pipe named 'world', create a fanout feed named
#   'ping', and create a join on all messages, using address string 'hello':
my $response = $ua->request (PUT "$base/pipe/world/hello\@ping/fanout");
$response->code == 200 || die;

my $response = $ua->request (POST "$base/hello\@ping",
    Content => "Hello World!\n");
$response->code == 200 || die;

#   Message goes into feed and then comes back to our pipe
my $response = $ua->request (GET "$base/pipe/world/");
$response->code == 200 || die;
print $response->content;
[[/code]]


terminology

* asynclet
* Resource - a network-addressable data object or service identified by a URI.
* Domain - a collection of RestMS resources managed by one server or virtual host.
* Feed - the target for
document
element
property
attribute
document root
resource root




- If app always invents new pipe, will not get message delivered reliably as message may go to other pipe.  Needs to cache pipe name and reuse when starting, example is digest-amqp.pl.
- If app always requests same pipe and fails to delete message, will loop on getting message.  Need to perhaps limit number of deliveries.
- If service creates feed, requester needs to use service@amq.direct rather than address@service, which is ugly.  To make address@service work, Zyre needs to know what services exist, this needs to come from the AMQP server.  It also needs to get errors if service does not exist (mandatory + returned messages).
    -> OpenAMQ synch all back onto zyre
    -> zyre does not need to define own services...



RestMS

- restms.digistan.org microsite
-> restms.org template
-> restms@digistan.org email list
-> examples, wiki, implementations


define pipe that sends messages back to feed
    - allows proxy selection, macroisation

define fair queue mechanism that takes input from several feeds but fairly
    - implement natively in openamq?
    - ...?

stream pipe
nozzles on post messages too
    post to nozzle - idempotent
    post to nozzle - idempotent
    delete nozzle


HTTP headers

C:
If-Match: "entity-tag" | "*"
    Conditional PUT, update entry if entry still has the same Etag
    Else 412 Precondition failed, with Date: header
    If any other error (except 2xx or 412) would happen, must happen anyhow
    "*" means only if the entity already exists, MUST NOT if the entity does not exist
If-Modified-Since: date
    Conditional GET, 304 Not Modified if entry has same or older date
    If any other error (except 200 or 304) behaviour is as for normal GET
If-None-Match: "entity-tag" | "*"
    Conditional GET, get 304 Not Modified if entry has the same Etag
    "*" means only if entity does not exist, MUST NOT if the entity does exist
    used to prevent race conditions between PUTs
If-Range: "entity-tag"
    Used together with Range: header (for getting files?)
    Gets 206 Partial Content range if entity matches
    Gets 200 OK whole content if entity does not match
If-Unmodified-Since: date
    Does operation only if entity has not been modified since date
    Else returns 412 Precondition failed
    If any other error (except 2xx or 412), behaviour is as if absent

S:
ETag: "entity-tag"
    Date-Size-Inode or Date-Size
Last-Modified: date
    Last date of modification
Location: absolute-uri
    For 201 Created and for 3xx responses



implement exchange logic in zyre and do federation


config
    amqp server name
    amqp server login and password
    client logins
        - basic auths
        - not same as openamq credentials

- if-modified-since
- cache-control
- last-modified-time

=====

Not supported:

* Does not allow binding arguments (headers) yet.

RESTful extensions to AMQP
    - RestMS protocol class
    - * in topics matches empty routing-key
    - empty topic segments are allowed (".value")
    - Basic.Consume is assertive, idempotent
        - note that must not allow same tag on different queues
        -> Subsumed in restms protocol class
    - Queue.Declare private queues are scoped per connection
        - names uniquified on server, automatically
        - in declare, consume, cancel, bind, delete
        -> This is not implemented in OpenAMQ yet but should be
        -> Subsumed in restms protocol class
    - Queue.Delete is assertive
        - if queue does not exist, still returns Delete-Ok
        -> Subsumed in restms protocol class
