Zyre work
    - Vinoski's comments on RestMS


ETag: "somevalue"
    If new HTTP response contains same Etag as older one, no further downloading is done, the contents are assumed to be the same.
If-None-Match: "somevalue"


If-Match: "entity-tag" | "*"
    Conditional PUT, update entry if entry still has the same Etag
    Else 412 Precondition failed, with Date: header
    If any other error (except 2xx or 412) would happen, must happen anyhow
    "*" means only if the entity already exists, MUST NOT if the entity does not exist
If-Modified-Since: date
    Conditional GET, 304 Not Modified if entry has same or older date
    If any other error (except 200 or 304) behaviour is as for normal GET
If-None-Match: "entity-tag" | "*"
    Conditional GET, get 304 Not Modified if entry has the same Etag
    "*" means only if entity does not exist, MUST NOT if the entity does exist
    used to prevent race conditions between PUTs
If-Range: "entity-tag"
    Used together with Range: header (for getting files?)
    Gets 206 Partial Content range if entity matches
    Gets 200 OK whole content if entity does not match
If-Unmodified-Since: date
    Does operation only if entity has not been modified since date
    Else returns 412 Precondition failed
    If any other error (except 2xx or 412), behaviour is as if absent

Last-Modified: date
    Last date of modification
Location: absolute-uri
    For 201 Created and for 3xx responses



The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

Key words for use in RFCs to Indicate Requirement Levels
http://tools.ietf.org/html/rfc2119

Terminolgy

Resource - a network-addressable data object or service identified by a URI.
Collection - A Resource that contains a set of Member Resources. Collections are represented as Atom Feeds. See Section 9.
Workspace - A named group of Collections. See Section 8.1.
Service Document - A document that describes the location and capabilities of one or more Collections, grouped into Workspaces. See Section 8.
Category Document - A document that describes the categories allowed in a Collection. See Section 7.

The RestMS Protocol specifies operations for publishing and editing Resources using HTTP. It uses RestMS-formatted representations to describe the state and metadata of those Resources. It defines how Collections of Resources can be organized, and it specifies formats to support their discovery, grouping and categorization.

The Atom Publishing Protocol uses HTTP methods to author Member Resources as follows:

* GET is used to retrieve a representation of a known Resource.
* POST is used to create a new, dynamically named, Resource. When the client submits non-Atom-Entry representations to a Collection for creation, two Resources are always created -- a Media Entry for the requested Resource, and a Media Link Entry for metadata about the Resource that will appear in the Collection.
* PUT is used to edit a known Resource. It is not used for Resource creation.
* DELETE is used to remove a known Resource.

The Atom Protocol only covers the creating, editing, and deleting of Entry and Media Resources. Other Resources could be created, edited, and deleted as the result of manipulating a Collection, but the number of those Resources, their media types, and effects of Atom Protocol operations on them are outside the scope of this specification.

While specific HTTP status codes are shown in the interaction diagrams below, an AtomPub client should be prepared to handle any status code. For example, a PUT to a Member URI could result in the return of a "204 No Content" status code, which still indicates success.

Creating a Resource
C:POST to collection URI + Content body (member)
S:201 Created + Location: Member entry URI + Content body (

Editing a Resource
1. Retrieve
C:GET to member URI
S:200 OK + content body

2. Update
C:PUT to member URI
S:200 OK

3. Delete
C:DELETE to member URI
S:200 OK

6.2 Document Extensibility

Unrecognized markup in an Atom Publishing Protocol document is considered "foreign markup" as defined in Section 6 of the Atom Syndication Format [RFC4287]. Foreign markup can be used anywhere within a Category or Service Document unless it is explicitly forbidden. Processors that encounter foreign markup MUST NOT stop processing and MUST NOT signal an error. Clients SHOULD preserve foreign markup when transmitting such documents.


links are 'href' not 'uri'

Entry document
    - client may specify one
    - server may specify different/modified one
    entry = pipe...?

<?xml version="1.0"?>
<entry xmlns="http://www.w3.org/2005/Atom">
    <title>Atom-Powered Robots Run Amok</title>
    <id>urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a</id>
    <updated>2003-12-13T18:30:02Z</updated>
    <author><name>John Doe</name></author>
    <content>Some text.</content>
    <link rel="edit"
        href="http://example.org/edit/first-post.atom"/>
</entry>

Client should GET before modifying with PUT, and should preserve any unknown data that is not intentionally modified.

Implementers are advised to pay attention to cache controls and to make use of the mechanisms available in HTTP when editing Resources, in particular, entity-tags as outlined in [NOTE-detect-lost-update]. Clients are not assured to receive the most recent representations of Collection Members using GET if the server is authorizing intermediaries to cache them.

Mechanism to edit with minimal conflicts
GET resource
Before saving
    GET resource
    If-None-Match: <etag>
    -> 200 OK if changed by someone else
    -> 304 Not Modified if not changed
Save with check
    PUT resource
    If-Match <etag>

Slug -> message ID
    -> pipe name
    -> feed name


8.2 Slug: Header

The value of the Slug entity-header is a "slug", i.e. a short name identifying a resource.

  Slug = "Slug" ":" *TEXT

Resources have modification/creation dates.
GET has no side effects
PUT updates a resource
POST creates a new resource

- use of "Feed" is confusing for Atom people

***********************************************

issues in restms

- If app always invents new pipe and nozzle, will not get message delivered reliably.  Needs to cache pipe name and reuse when starting, example is digest-amqp.pl.
- If app always requests same pipe/nozzle and fails to delete message, will loop on getting message.  Need to perhaps limit number of deliveries.
- If service creates feed, requester needs to use service@amq.direct rather than address@service, which is ugly.  To make address@service work, Zyre needs to know what services exist, this needs to come from the AMQP server.  It also needs to get errors if service does not exist (mandatory + returned messages).



RestMS

- restms.digistan.org microsite
-> restms.org template
-> restms@digistan.org email list
-> examples, wiki, implementations


define pipe that sends messages back to feed
    - allows proxy selection, macroisation

define fair queue mechanism that takes input from several feeds but fairly
    - implement natively in openamq?
    - ...?

stream pipe
nozzles on post messages too
    post to nozzle - idempotent
    post to nozzle - idempotent
    delete nozzle


implement exchange logic in zyre and do federation


config
    amqp server name
    amqp server login and password
    client logins
        - basic auths
        - not same as openamq credentials

- if-modified-since
- cache-control
- last-modified-time

=====

Not supported:

* Does not allow binding arguments (headers) yet.

RESTful extensions to AMQP
    - RestMS protocol class
    - * in topics matches empty routing-key
    - empty topic segments are allowed (".value")
    - Basic.Consume is assertive, idempotent
        - note that must not allow same tag on different queues
        -> Subsumed in restms protocol class
    - Queue.Declare private queues are scoped per connection
        - names uniquified on server, automatically
        - in declare, consume, cancel, bind, delete
        -> This is not implemented in OpenAMQ yet but should be
        -> Subsumed in restms protocol class
    - Queue.Delete is assertive
        - if queue does not exist, still returns Delete-Ok
        -> Subsumed in restms protocol class
