++ Worked examples

In this section we take two typical examples - a service-oriented network, and a publish-subscribe network - and we implement them in both AMQP and RestMS.  These examples demonstrate how RestMS works by comparison to AMQP, and the examples are useful starting points for real applications.  AMQP and RestMS applications are fully interoperable.

+++ Fortune service example

In this example we show how to implement a service that returns a random message, also called a "fortune cookie".  The fortune service works as follows:

* A client sends a request message to a fortune service.
* The fortune service responds with something witty.

We will first implement the service and client using AMQP methods.  We will then implement the same service and client using low-level RestMS HTTP methods.  We assume the RestMS server is running on port 80 at host.com, and we show only HTTP headers that are relevant to the example.

Here is the message format used by the fortune service.  The request message takes this form (using the RestMS notation):

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message reply_to="{reply to}" />
</restms>
[[/code]]

And the response message takes this form:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message address="reply_to">
    <header name="fortune" value="{fortune cookie text}" />
  </message>
</restms>
[[/code]]

For simplicity, we do not show the '<?xml version="1.0"?>' entity and the "xmlns" attribute in the later examples, but these are required in actual code.

Note that in this example we are carrying the message data in the message envelope.  RestMS also lets us carry data as separate "contents", but this is more complex and not useful to explain here.

Message routing for this example works as follows:

* Clients send their requests to a service called "fortune"
* The fortune service responds to the reply-to value of the message.
* In both cases, messages are routed via the default feed (or default exchange in AMQP terms).

++++ AMQP fortune service

The fortune service starts by creating a shared queue:

[[code]]
C: Queue.Declare queue="fortune" exclusive="0" auto-delete="1"
S: Queue.Declare-Ok
[[/code]]

It does not need to bind the queue, since it will use the default binding.  It consumes from the queue:

[[code]]
C: Basic.Consume queue="fortune"
S: Basic.Consume-Ok
[[/code]]

The message arrives from the server:

[[code]]
S:Basic.Deliver exchange="" routing_key="fortune" reply_to="RESTMS_B4B4"
[[/code]]

If we assume we're using the RestMS client that we explained later, the reply_to attribute will be "RESTMS_B4B4".  If the client is an AMQP client, the reply_to attribute will be the name of a private queue owned by that client.

The fortune service formats an AMQP message, setting the headers field 'fortune' to the fortune text it wishes to send.  It then sends the message to the AMQP server:

[[code]]
C: Basic.Publish exchange="" routing-key="RESTMS_B4B4"
    headers: { fortune="Complexity is the swamp, simplicity the mountain top" }
[[/code]]

++++ AMQP fortune client

The fortune client starts by creating an exclusive server-named queue:

[[code]]
C: Queue.Declare queue="" exclusive="1"
S: Queue.Declare-Ok queue="auto:0123"
[[/code]]

It does not need to bind the queue, since it will use the default binding.  It consumes from the queue:

[[code]]
C: Basic.Consume queue="auto:1023"
S: Basic.Consume-Ok
[[/code]]

The client then sends a request message to the fortune service:

[[code]]
C: Basic.Publish exchange="" routing-key="fortune" reply_to="auto:1023"
[[/code]]

When the message arrives, the server delivers it to the client:

[[code]]
S:Basic.Deliver exchange="" routing_key="fortune"
    headers: { fortune="Complexity is the swamp, simplicity the mountain top" }
[[/code]]

The client unpacks the headers table and takes the "fortune" field, which contains the response from the fortune service.

++++ RestMS fortune service

First, the fortune service creates a public feed named "fortune", by posting a feed specification to the default domain:

[[code]]
Client:
-------------------------------------------------
POST /restms/domain/
Content-Type: application/restms+xml;type=feed

<restms>
  <feed name="fortune" type="service" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml;type=feed
Location: http://host.com/restms/feed/fortune

<restms>
  <feed name="fortune" type="service" />
</restms>
[[/code]]

The fortune service then creates a pipe:

[[code]]
Client:
-------------------------------------------------
POST /restms/domain/
Content-Type: application/restms+xml;type=pipe

<restms>
  <pipe type="fifo" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml;type=pipe
Location: http://host.com/restms/resource/C4FE

<restms>
  <pipe type="fifo" reply_to="RESTMS_C4FE">
    <!-- All pipes are automatically joined to the default feed -->
    <join
        href="http://host.com/restms/resource/BA5F"
        address="RESTMS_C4FE"
        feed="http://host.com/restms/feed/" />
    <!-- All pipes contain an asynclet for the next message -->
    <message
        href="http://host.com/restms/resource/F00D"
        async="1" />
  </pipe>
</restms>
[[/code]]

The fortune service does not expect to be addressed by its reply_to attribute, but rather by the service name "fortune".  It thus creates a join from its pipe to the fortune feed, by POSTing a join specification to the pipe URI.

[[code]]
Client:
-------------------------------------------------
POST /restms/resource/C4FE
Content-Type: application/restms+xml;type=join

<restms>
  <join address="*" feed="http://host.com/restms/feed/fortune" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml;type=join
Location: http://host.com/restms/resource/B33F

<restms>
  <join address="*" feed="http://host.com/restms/feed/fortune" />
</restms>
[[/code]]

The fortune service then retrieves the message asynclet, and thus waits for an incoming message:

[[code]]
Client:
-------------------------------------------------
GET /restms/resource/FOOD
[[/code]]

When a client eventually posts a message to the fortune feed, the RestMS server delivers it to our fortune service, which has been waiting:

[[code]]
Server:
-------------------------------------------------
HTTP/1.1 200 OK
Content-Type: application/restms+xml;type=join

<restms>
  <message
    reply_to="RESTMS_B4B4"
    feed="http://host.com/restms/feed/fortune"
    next="http://host.com/restms/resource/DE55" />
</restms>
[[/code]]

The fortune service then replies with a suitable fortune cookie, by posting a message to the default feed using the reply_to attribute of the request as the address:

[[code]]
Client:
-------------------------------------------------
POST /restms/feed/
Content-Type: application/restms+xml;type=message

<restms>
  <message address="RESTMS_B4B4">
    <header
      name="fortune"
      value="Complexity is the swamp, simplicity the mountain top" />
  </message>
</restms>

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

And the fortune service repeats the process by retrieving the next message asynclet, and thus waiting once more for an incoming message:

[[code]]
Client:
-------------------------------------------------
HTTP/1.1 200 OK
GET /restms/resource/DE55
[[/code]]

When the fortune service decides to end, it deletes its pipe:

[[code]]
Client:
-------------------------------------------------
DELETE /restms/resource/C4FE

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

++++ RestMS fortune client

The fortune client creates a pipe by posting a pipe specification document to the default domain:

[[code]]
Client:
-------------------------------------------------
POST /restms/domain/
Content-Type: application/restms+xml;type=pipe

<restms>
  <pipe type="fifo" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml;type=pipe
Location: http://host.com/restms/resource/B4B4

<restms>
  <pipe type="fifo" reply_to="RESTMS_B4B4">
    <join
        href="http://host.com/restms/resource/00DA"
        address="RESTMS_B4B4"
        feed="http://host.com/restms/feed/" />
    <message
        href="http://host.com/restms/resource/C137"
        async="1" />
  </pipe>
</restms>
[[/code]]

The client posts a message to the fortune feed, specifying the reply_to attribute:

[[code]]
Client:
-------------------------------------------------
POST /restms/feed/fortune
Content-Type: application/restms+xml;type=message

<restms>
  <message reply_to="RESTMS_B4B4" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

The fortune client then retrieves the message asynclet, and thus waits for an incoming message:

[[code]]
Client:
-------------------------------------------------
GET /restms/resource/C137
[[/code]]

And when the fortune service responds, the client gets its reply message from the server:

[[code]]
Server:
-------------------------------------------------
HTTP/1.1 200 OK
Content-Type: application/restms+xml;type=message

<restms>
  <message address="RESTMS_B4B4">
    <header
      name="fortune"
      value="Complexity is the swamp, simplicity the mountain top" />
  </message>
</restms>
[[/code]]

The fortune client then deletes its pipe:

[[code]]
Client:
-------------------------------------------------
DELETE /restms/resource/B4B4

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

+++ Newsfeed publish-subscribe example

In this example we show how to implement a topic-based newsfeed service that distributes news articles using a hierarchical categorization structure.  The newsfeed service works as follows:

* A news publisher sends a stream of news covering various categories.
* Clients subscribe to and receive messages from specific news categories.

We will implement a publisher and a subscriber using AMQP methods.  We will then implement the same publisher and subscriber using low-level RestMS HTTP methods.  We assume the RestMS server is running on port 80 at host.com, and we show only HTTP headers that are relevant to the example.

Here is the message format for the newsfeed:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message address="{news category}">
    <header name="title" value="{news item title}" />
    <header name="body" value="{news item body}" />
  </message>
</restms>
[[/code]]

For simplicity, we do not show the '<?xml version="1.0"?>' entity and the xmlns attribute in the later examples, but these are required in actual code.

Note that in this example we are carrying the message data in the message envelope.  RestMS also lets us carry data as separate "contents", but this is more complex and not useful to explain here.

As an example we will use this news category tree:

[[code]]
rec
   |
   o- pets
   |  |
   |  o- cats
   |  |
   |  o- dogs
   |
   o- cars
[[/code]]

News categories are written with periods separating each level, like this: "rec.pets.cats".  Subscribers can request specific categories, or use wildcards: '*' specifies any value for one level, '#' specifies any value for any number of levels.

Our sample news stream contains these news items (we show the news category and the item title):

[[code]]
rec.pets.dogs   Montreal: Canine Championship series opens
rec.cars        The oil shock: does it affect you?
rec.pets.dogs   Steroids: the ugly truth from Montreal
rec.pets.cats   Cat vs. dog: facts or fictions?
rec.pets.dogs   Montreal in chaos: winner is a cat!
rec.cars        Red, white, or blue: what it says about you
rec.cars        Parking - who, where, why: a new survey
rec.pets.cats   Superiority: it comes naturally
[[/code]]

++++ AMQP newsfeed publisher

The news publisher first declares a topic exchange called "newsfeed":

[[code]]
Exchange.Declare exchange="newsfeed" type="topic"
[[/code]]

It then publishes news items to the newsfeed exchange (the news item title is a headers field):

[[code]]
C:Basic.Publish exchange="newsfeed" routing_key="rec.pets.dogs"
    headers: { title="Montreal: Canine Championship series opens" }
C:Basic.Publish exchange="newsfeed" routing_key="rec.cars"
    headers: { title="The oil shock: does it affect you?" }
C:Basic.Publish exchange="newsfeed" routing_key="rec.pets.dogs"
    headers: { title="Steroids: the ugly truth from Montreal" }
C:Basic.Publish exchange="newsfeed" routing_key="rec.pets.cats"
    headers: { title="Cat vs. dog: facts or fictions?" }
C:Basic.Publish exchange="newsfeed" routing_key="rec.pets.dogs"
    headers: { title="Montreal in chaos: winner is a cat!" }
C:Basic.Publish exchange="newsfeed" routing_key="rec.cars"
    headers: { title="Red, white, or blue: what it says about you" }
C:Basic.Publish exchange="newsfeed" routing_key="rec.cars"
    headers: { title="Parking - who, where, why: a new survey" }
C:Basic.Publish exchange="newsfeed" routing_key="rec.pets.cats"
    headers: { title="Superiority: it comes naturally" }
[[/code]]

++++ AMQP newsfeed subscriber

Our example news subscriber wants all news in "rec.pets".  It starts by creating a private queue:

[[code]]
C: Queue.Declare queue="" exclusive="1"
S: Queue.Declare-Ok queue="auto:0021"
[[/code]]

It creates a binding for "rec.pets.*" and then consumes from the queue:

[[code]]
C: Queue.Bind queue="auto:0021" exchange="newsfeed" routing_key="rec.pets.*"
S: Queue.Bind-Ok
C: Basic.Consume queue="auto:0021"
S: Basic.Consume-Ok
[[/code]]

The subscriber then waits for messages, and receives these:

[[code]]
S:Basic.Deliver exchange="newsfeed" routing_key="rec.pets.dogs"
    headers: { title="Montreal: Canine Championship series opens" }
S:Basic.Deliver exchange="newsfeed" routing_key="rec.pets.dogs"
    headers: { title="Steroids: the ugly truth from Montreal" }
S:Basic.Deliver exchange="newsfeed" routing_key="rec.pets.cats"
    headers: { title="Cat vs. dog: facts or fictions?" }
S:Basic.Deliver exchange="newsfeed" routing_key="rec.pets.dogs"
    headers: { title="Montreal in chaos: winner is a cat!" }
S:Basic.Deliver exchange="newsfeed" routing_key="rec.pets.cats"
    headers: { title="Superiority: it comes naturally" }
[[/code]]

++++ RestMS newsfeed publisher

The news publisher first declares a public topic feed called "newsfeed", by posting a feed specification to the default domain:

[[code]]
Client:
-------------------------------------------------
POST /restms/domain/
Content-Type: application/restms+xml;type=feed

<restms>
  <feed name="newsfeed" type="topic" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml;type=feed
Location: http://host.com/restms/feed/newsfeed

<restms>
  <feed name="newsfeed" type="topic" />
</restms>
[[/code]]

It then publishes a batch of news items to the newsfeed feed:

[[code]]
Client:
-------------------------------------------------
POST /restms/feed/newsfeed
Content-Type: application/restms+xml;type=message

<restms>
  <message address="rec.pets.dogs">
    <header name="title" value="Montreal: Canine Championship series opens" />
  </message>
  <message address="rec.cars">
    <header name="title" value="The oil shock: does it affect you?" />
  </message>
  <message address="rec.pets.dogs">
    <header name="title" value="Steroids: the ugly truth from Montreal" />
  </message>
  <message address="rec.pets.cats">
    <header name="title" value="Cat vs. dog: facts or fictions?" />
  </message>
  <message address="rec.pets.dogs">
    <header name="title" value="Montreal in chaos: winner is a cat!" />
  </message>
  <message address="rec.cars">
    <header name="title" value="Red, white, or blue: what it says about you" />
  </message>
  <message address="rec.cars">
    <header name="title" value="Parking - who, where, why: a new survey" />
  </message>
  <message address="rec.pets.cats">
    <header name="title" value="Superiority: it comes naturally" />
  </message>
</restms>

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

++++ RestMS newsfeed subscriber

The subscriber creates a pipe on which to receive news items, and the server responds with a pipe description that includes the asynclet on which the subscriber can wait to get the next incoming message:

[[code]]
Client:
-------------------------------------------------
POST /restms/domain/
Content-Type: application/restms+xml;type=pipe

<restms>
  <pipe type="fifo" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml;type=pipe
Location: http://host.com/restms/resource/F33D

<restms>
  <pipe type="fifo">
    <message
        href="http://host.com/restms/resource/33D1"
        async="1" />
  </pipe>
</restms>
[[/code]]

The subscriber retrieves the message asynclet, and thus waits for an incoming message:

[[code]]
Client:
-------------------------------------------------
GET /restms/resource/33D1
[[/code]]

And when a news item arrives, the client gets it from the server:

[[code]]
Server:
-------------------------------------------------
HTTP/1.1 200 OK
Content-Type: application/restms+xml;type=message

<restms>
  <message address="rec.pets.dogs">
    <header name="title" value="Montreal: Canine Championship series opens" />
  </message>
</restms>
[[/code]]

When the subscriber has finished, it deletes its pipe:

[[code]]
Client:
-------------------------------------------------
DELETE /restms/resource/F33D

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]
