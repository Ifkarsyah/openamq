++ AMQP technical interoperability

We look at the interoperability of the messaging products, i.e. how to connect a RestMS server to an AMQP server or network.  The main issues we must address are:

* Whether the AMQP server supports the necessary RestMS semantics
* How the RestMS server mirrors resources to and from the AMQP server
* How the RestMS server routes messages to and from the AMQP server

+++ The RestMS extension class

There are some significant differences between the RESTful model we implement in RestMS, and the AMQP model for resource management.  It would be possible, in theory and in time, to modify the AMQP protocol to become compatible with RestMS.  For example, commands like Queue.Delete would need to become idempotent so that attempting to delete a non-existent queue was safe.  Today, AMQP treats such attempts as fatal errors.

Rather than attempt to modify existing AMQP semantics, we have chosen to definee an AMQP "extension class", which is a mechanism that AMQP allows for experimental extensions.  The advantage of an extension class is that a RestMS server can detect immediately whether its target AMQP server supports it, or not.  There is no ambiguity.

We have used the class index 61501, which falls into the space allotted for extension classes.

In order to work with a RestMS server, an AMQP server thus needs to implement this class:

[[code]]
<?xml version="1.0"?>
<!--
    Copyright (c) 1996-2009 iMatix Corporation

    This code is licensed under both the GPLv3 and the IETF licence, in
    accordance with the terms of the wiki.amqp.org IP Policy.
 -->
<class
    name    = "restms"
    handler = "connection"
    index   = "61501"
  >
  RestMS resource management class.
<doc>
    Provides methods to work with server-side resources as defined by
    the RestMS specification.  All methods are request-only, without
    response.  Errors are logged at the server side and not reported
    to the client.  This model is designed to allow a RestMS server to
    push state to the AMQP server, and vice versa, rapidly and without
    handshaking.
</doc>

<doc name = "grammar">
    restms              = C:PIPE-CREATE / C:PIPE-DESTROY
                        / C:FEED-CREATE / C:FEED-DESTROY
                        / C:JOIN-CREATE / C:JOIN-DESTROY
                        / S:PIPE-CREATE / S:PIPE-DESTROY
                        / S:FEED-CREATE / S:FEED-DESTROY
                        / S:JOIN-CREATE / S:JOIN-DESTROY
</doc>

<chassis name = "server" implement = "MAY" />
<chassis name = "client" implement = "MAY" />

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<method name = "pipe-create" index = "10">
  create a pipe
  <doc>
  Creates a pipe of the specified class.  The pipe may already exist,
  if it has the same class.  Pipe names are unique across all classes.
  </doc>
  <chassis name = "server" implement = "MUST" />
  <field name = "pipe class" type = "shortstr" >
    pipe class
    <doc>
    Specifies the class of the pipe to create.  Valid values are: pipe.
    </doc>
  </field>
  <field name = "pipe name" type = "shortstr" >
    Name of pipe
    <doc>
    Specifies the name of the pipe to create.  Pipe names may not contain
    slashes, spaces, or at signs.
    </doc>
  </field>
</method>

<method name = "pipe-delete" index = "20">
  delete a pipe
  <doc>
  Deletes a specified pipe, if it exists.  Safe to invoke on non-existent
  or already-deleted pipes.
  </doc>
  <chassis name = "server" implement = "MUST" />
  <field name = "pipe name" type = "shortstr" >
    pipe name
    <doc>
    Specifies the name of the pipe to delete.
    </doc>
  </field>
</method>

<method name = "feed-create" index = "30">
  create a feed
  <doc>
  Creates a feed of the specified class.  The feed may already exist,
  if it has the same class.  Feed names are unique across all classes.
  </doc>
  <chassis name = "server" implement = "MUST" />
  <field name = "feed class" type = "shortstr" >
    Feed class
    <doc>
    Specifies the class of the feed to create.  Valid values are: fanout,
    direct, topic, headers, system, rotator, and service.
    </doc>
  </field>
  <field name = "feed name" type = "shortstr" >
    Name of feed
    <doc>
    Specifies the name of the feed to create.  Feed names may not contain
    slashes, spaces, or at signs.
    </doc>
  </field>
</method>

<method name = "feed-delete" index = "40">
  delete a feed
  <doc>
  Deletes a specified feed, if it exists.  Safe to invoke on non-existent
  or already-deleted feeds.
  </doc>
  <chassis name = "server" implement = "MUST" />
  <field name = "feed name" type = "shortstr" >
    feed name
    <doc>
    Specifies the name of the feed to delete.
    </doc>
  </field>
</method>

<method name = "join-create" index = "50">
  create a join
  <doc>
  Creates a join on the specified pipe and feed.  The join may already
  exist, if it has the same properties.  A join will causes messages to
  be delivered on the connection.  The consumer-tag property allows
  messages to be routed into end-application pipes.  Joins on exchange
  feeds use the consumer tag "x:{pipe-name}" and joins on queue feeds
  use the consumer tag "q:{pipe-name}".  AMQP does not allow the same
  tag to be used on multiple queues.
  </doc>
  <chassis name = "server" implement = "MUST" />
  <field name = "pipe class" type = "shortstr" >
    Pipe class
    <doc>
    Specifies the class of the pipe, which must match the class of the
    existing pipe.
    </doc>
  </field>
  <field name = "pipe name" type = "shortstr" >
    Name of pipe
    <doc>
    Specifies the name of the pipe, which must exist.
    </doc>
  </field>
  <field name = "feed class" type = "shortstr" >
    Feed class
    <doc>
    Specifies the class of the feed, which must match the class of the
    existing feed.
    </doc>
  </field>
  <field name = "feed name" type = "shortstr" >
    Name of feed
    <doc>
    Specifies the name of the feed, which must exist.
    </doc>
  </field>
  <field name = "address" type = "shortstr" >
    Join address
    <doc>
    Specifies the address to join.  This is an address literal or
    pattern who's semantics depend on the feed class.  The address
    may not contain slashes, spaces, or at signs.
    </doc>
  </field>
</method>

<method name = "join-delete" index = "60">
  delete a join
  <doc>
  Deletes a specified join, if it exists.  Safe to invoke on non-existent
  or already-deleted joins, and referring to non-existent pipes and/or
  feeds.
  </doc>
  <chassis name = "server" implement = "MUST" />
  <field name = "pipe name" type = "shortstr" >
    Name of pipe
    <doc>
    Specifies the name of the pipe, which does not need to exist.
    </doc>
  </field>
  <field name = "feed name" type = "shortstr" >
    Name of feed
    <doc>
    Specifies the name of the feed, which does not need to exist.
    </doc>
  </field>
  <field name = "address" type = "shortstr" >
    Join address
    <doc>
    Specifies the join address.
    </doc>
  </field>
</method>

</class>
[[/code]]

+++ Resource synchronisation

The RestMS extension class defined above provides a clean way for the RestMS server to synchronize all its resources with an AMQP server, and vice-versa.  Since the commands are asynchronous and not confirmed, they can be executed very rapidly, so that one server can synchronize its resources on another (for example, after failover) at the rate of tens of thousands of resources per second.

To avoid "storms", a server should track the origin of resources, and synchronise only those which were created by its own local clients.

When a server receives resource specifications from another server, these resources SHOULD be treated as configured and clients SHOULD not be allowed to delete them except on the original server.

Server implementations MAY take any reasonable approach to resources that are "orphaned", i.e. where their original owning server has disconnected and/or gone off line.

+++ Message routing

RestMS does not impose a specific architecture for interconnection with an AMQP network and there are several possibilities which we explain for the benefit of implementors.

In practice, AMQP servers may be paired for high-availability, and/or may be federated themselves into larger AMQP networks.  In this discussion we will assume that the RestMS server speaks to exactly one AMQP server.

The first model relies on the AMQP server to do all routing.  In this case, the RestMS server will synchronise all feeds, pipes, and joins with the AMQP server.  All RestMS pipes and joins are instantiated as private queues and bindings on the AMQP server.  Pipes are implemented in the simplest fashion: each pipe has an exclusive queue with the same name, with a consumer with tag x:{pipe-name}.  When the RestMS server creates joins on the pipe, these are implemented as bindings that bring messages into the private queue.  This is for exchange-based feeds.  For queue-based feeds, the pipe is implemented as a consumer on the shared queue, with tag q:{pipe-name}.  These distinct tags are used by the RestMS server to route messages coming from the AMQP server into separate pipes for end-application delivery.

When a RestMS client posts a message to a feed, the RestMS server forwards that message to the AMQP server.  When an AMQP client publishes a message, this also arrives on the AMQP server.  The AMQP server then routes that to all matching bindings, and thus into private queues.  Message are then delivered to the RestMS server, which uses the consumer tag to sort the messages into their pipes.  RestMS clients can then retrieve their messages from their pipes.

A second model is to open multiple connections or channels, e.g. one per pipe, and to use these to segment messages per pipes.

The advantage of these two model is that they are easy to understand and implement.  The main disadvantage is that messages will be sent redundantly, if they match multiple joins/bindings.  This will waste LAN bandwidth.

The optimal, but most complex model, is to use federation-style normalization.  In this model, the RestMS server maintains its own routing data structures, and forwards binding requests to the AMQP server.  When messages arrive, they are routed not on consumer tag, but according to the message routing key and/or other properties.  This model demands that the RestMS implementation has the same routing capabilities as the AMQP server, i.e. implements exchanges and shared queues in much the same way.  The advantage of this model is that it allows for stand-alone RestMS operation, and is the optimal design for RestMS-to-RestMS interoperation (with no extra hops to and from the AMQP server).

Finally, a RestMS server does not need to work with an AMQP network, it can be self-standing.
