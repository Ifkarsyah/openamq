++ Generic RESTful framework

RestMS defines a generic framework by which clients issue HTTP methods to work with server-side resources as follows:

* Clients use the GET method to retrieve the representation of a known resource.
* Clients use the POST method to create a new, dynamically named resource.
* Clients use the PUT method to edit a known resource (not to create resources).
* Clients use the DELETE method to remove a known resource.

All methods work orthogonally on all types of RestMS resources, whether those resources contain or do not contain other resources.  Not all combinations of methods and resources are meaningful, implemented, or permitted.

This framework draws heavily on the design of AtomPub[n] and that specification may be helpful as a background to the mechanics of implementing a RESTful dialog over a HTTP transport.

In this section we use XML as the document language, but the reader may note that RestMS allows a choice of representations for structured data.

+++ Resource lifecycles and visibility

RestMS distinguishes between resources that are created automatically by the server ("configured resources") and resources that are created at runtime by applications ("dynamic resources").  It also distinguishes between resources that are named and visible to all applications ("public resources") and resources that are unnamed and accessible only by a (by default) secret hash ("private resources").

The lifecycle and visibility of resources is related, as follows:

* Configured resources are always public while dynamic resources are by default private.
* Applications can modify and delete dynamic resources, if they know their URIs, while they may not modify or delete configured resources.
* The URI for a public resource is derived from its type and name, while the URI for a private resource is provided by the server.
* Public resources are named, and discoverable through navigation of parent resources, while private resources are unnamed, and undiscoverable.
* Dynamic resources may in some cases be created by the server.

The URI for a public resource is derived from the resource type and name as follows:

[[code]]
http://{server-name}[:{port}]/restms/{resource type}/{resource name}
[[/code]]

The URI for a private resource takes this form:

[[code]]
http://{server-name}[:{port}]/restms/resource/{resource hash}
[[/code]]

+++ Creating a new resource

The creation of a new dynamic resource follows these rules:

* The new resource will always be the child of another resource (the 'parent') identified with a URI.
* The client creates the resource by sending a POST method on the parent URI and providing the specifications for the new resource as the POST content body.
* The client can request a public or a private resource.  Public resources are named, while private resources are unnamed, and accessible only via a server-generated URI.
* The server replies, if there was no error, with a "201 Created" reply status, a Location: header that provides a URI to the new resource, and a content body that represents the created resource.

[[code]]
Client                                     Server
  |                                           |
  |  1.) POST to parent URI                   |
  |      Resource specifications              |
  |------------------------------------------>|
  |                                           |
  |  2.) 201 Created                          |
  |      Location: Resource URI               |
  |<------------------------------------------|
  |                                           |
[[/code]]

Note that the content body of a created resource may be different than the content body provided by the client: the client provides specifications for the resource, while the server provides the actual resulting resource contents.

This is the general form of a client request to create a dynamic resource:

[[code]]
POST /{parent uri} HTTP/1.1
Host: {hostname}
User-Agent: {user agent}
Authorization: {credentials}
Content-Type: application/restms+xml;type={resource type}
Content-Length: {size of content}
Slug: {resource title}

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type} [name="{resource name"}]>
    {resource specifications}
  </{resource type}>
</restms>
[[/code]]

If allowed by the resource type, and if the <resource type> tag has a "name" attribute, the new dynamic resource will be public, otherwise it will be private.

This is the general form of a server response for a created resource:

[[code]]
HTTP/1.1 201 Created
Date: {response date}
Content-Length: {size of content}
Content-Type: application/restms+xml;type={resource type}
Location: http://{hostname}[{port}]/restms/resource/{hash}
ETag: "{resource entity tag}"

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type} [name="{resource name"}]>
    {resource contents}
  </{resource type}>
</restms>
[[/code]]

Clients may use the following short request form to create a resource - note that there is no content:

[[code]]
POST /{parent uri} HTTP/1.1
Host: {hostname}
User-Agent: {user agent}
Authorization: {credentials}
Content-Type: application/restms+xml;type={resource type}
Content-Length: 0

[[/code]]

This is the general form of a server response for a resource created using the short request form:

[[code]]
HTTP/1.1 204 No Content
Date: {response date}
Content-Length: {size of content}
Content-Type: application/restms+xml;type={resource type}
Location: http://{hostname}[{port}]/restms/resource/{hash}
ETag: "{resource entity tag}"

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type} [name="{resource name"}]>
    {resource contents}
  </{resource type}>
</restms>
[[/code]]

+++ Retrieving a known resource

Retrieving a known resource follows these rules:

* The client must know the URI of the resource.  If it does not know the URI of the resource, and the resource is public, it can discover this by retrieving the parent resource and examining its contents.  If the resource is private, the client must either have created the resource, or must receive the resource URI by an out-of-band communication (for example a message from an external resource management service application).
* The client retrieves the resource by sending a GET method on the resource URI.
* The client can optionally specify headers to control the caching of the resource both by itself and by proxies that sit between it and the server.  We explain caching below.
* The server either returns a "200 OK" reply with the contents of the resource, or returns a reply code indicating why it did not return the resource contents.

[[code]]
Client                                     Server
  |                                           |
  |  1.) GET to Resource URI                  |
  |------------------------------------------>|
  |                                           |
  |  2.) 200 Ok                               |
  |      Resource representation              |
  |<------------------------------------------|
  |                                           |
[[/code]]

This is the general form of a client request to retrieve a resource:

[[code]]
GET /{resource uri} HTTP/1.1
Host: {hostname}
User-Agent: {user agent}
Authorization: {credentials}
[[/code]]

And this is the general form of a server response:

[[code]]
HTTP/1.1 200 OK
Date: {response date}
Content-Length: {size of content}
Content-Type: application/restms+xml;type={resource type}
Date-Modified: {resource date and time}
ETag: "{resource entity tag}"

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type}>
    {resource contents}
  </{resource type}>
</restms>
[[/code]]

If the client has previously retrieved the same resource and still has that ETag, it can use the If-None-Match: header, specifying the ETag value, and/or the If-Modified-Since: to do a conditional GET:

[[code]]
GET /{resource uri} HTTP/1.1
...
If-None-Match: "{resource entity tag}"
If-Modified-Since: {resource date and time}
[[/code]]

If the resource has not changed - still has the same ETag and modification date - the server replies with a "304 Not Modified":

[[code]]
HTTP/1.1 304 Not Modified
Date: {response date}
[[/code]]

+++ Modifying a known resource

Modifying a known resource follows these rules:

* The client must know the URI of the resource.  If it does not know the URI of the resource, it can discover this by examining the contents of the parent resource.
* The client must have retrieved the resource using GET.
* The client sends new resource contents by sending a PUT method on the resource URI with a modified resource content.
* The client can optionally specify headers to control potential conflicts (two clients trying to modify the same resource at the same time).
* The server either returns a "2xx OK" reply indicating success, or returns a reply code indicating why it did not modify the resource contents.

[[code]]
Client                                     Server
  |                                           |
  |  1.) GET to Resource URI                  |
  |------------------------------------------>|
  |                                           |
  |  2.) 200 Ok                               |
  |      Resource representation              |
  |<------------------------------------------|
  |                                           |
  |  3.) PUT to Resource URI                  |
  |      Modified resource representation     |
  |------------------------------------------>|
  |                                           |
  |  4.) 200 OK                               |
  |<------------------------------------------|
[[code]]

This is the general form of a client request to modify a resource:

[[code]]
PUT /{resource uri} HTTP/1.1
Host: {hostname}
User-Agent: {user agent}
Authorization: {credentials}
Content-Length: {size of content}
Content-Type: application/restms+xml;type={resource type}

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type}>
    {resource contents}
  </{resource type}>
</restms>
[[/code]]

And this is the general form of a server response:

[[code]]
HTTP/1.1 200 OK
Date: {response date}
[[/code]]

The client can use the If-Match: header, specifying the resource's ETag value, to do a conditional PUT:

[[code]]
PUT /{resource uri} HTTP/1.1
...
If-Match: "{resource entity tag}"
[[/code]]

If the resource held by the server has the same ETag (and if there are no other errors), the update will continue and the server will reply with "200 OK".  If the resource has changed at the server, and thus has a different ETag, the server does not update the resource, and replies with a "412 Precondition Failed":

[[code]]
HTTP/1.1 412 Precondition Failed
Date: {response date}
[[/code]]

+++ Deleting a known resource

Deleting a known resource follows these rules:

* The client must know the URI of the resource.  If it does not know the URI of the resource, it can discover this by examining the contents of the parent resource.
* The client sends a DELETE method on the resource URI.
* The client can optionally specify headers to control potential conflicts.
* The server either returns a "2xx OK" reply indicating success, or returns a reply code indicating why it did not delete the resource contents.

[[code]]
Client                                     Server
  |                                           |
  |  1.) DELETE to resource URI               |
  |------------------------------------------>|
  |                                           |
  |  2.) 200 OK                               |
  |<------------------------------------------|
  |                                           |
[[/code]]

This is the general form of a client request to delete a resource:

[[code]]
DELETE /{resource uri} HTTP/1.1
Host: {hostname}
User-Agent: {user agent}
Authorization: {credentials}
Content-Type: application/restms+xml;type={resource type}
[[/code]]

And this is the general form of a server response when the resource is successfully deleted:

[[code]]
HTTP/1.1 200 OK
Date: {response date}
[[/code]]

If the client previously read the resource, it can can use the If-Match: header, specifying the resource's ETag value, to do a conditional DELETE:

[[code]]
DELETE /{resource uri} HTTP/1.1
...
If-Match: "{resource entity tag}"
[[/code]]

If the resource held by the server has the same ETag (and if there are no other errors), the delete will continue and the server will reply with "200 OK".  If the resource has changed at the server, and thus has a different ETag, the server does not delete the resource, and replies with a "412 Precondition Failed":

[[code]]
HTTP/1.1 412 Precondition Failed
Date: {response date}
[[/code]]

+++ MIME types

When retrieving a document through the GET method a client MAY specify which MIME types it will accept using the Accept header.  While section 14.1 of RFC 2616 (the HTTP specification) defines a sophisticated format for the Accept header, RestMS currently allows these three possibilities:

* Accept: application/restms+xml
* Accept: application/restms+json
* no Accept header, or any other value.

If there is no Accept header, or it is not one of the allowed values, then it is assumed to be "application/restms+xml".

When creating a new resource using the POST method, or when modifying an existing resource using the PUT method, the client SHOULD specify the MIME type of the document that it is sending to the browser, using the Content-Type header.  For RestMS documents this MUST be one of these two:

* Content-Type: application/restms+xml;type={resource type}
* Content-Type: application/restms+json;type={resource type}

For the DELETE method, neither the Accept nor the Content-Type header have any significance, and if specified by the client, MUST BE ignored by the server.

If a server does not support the structured content type requested or provided by the client, it SHOULD return a response code 501 Not Implemented.

+++ Asynchronous access via asynclets

HTTP is generally a synchronous protocol in which a client polls a server for resources.  This is undesirable in many architectures, both from a design and a performance perspective.  RestMS allows for asynchronous retrieval of resources with the concept of an "asynchronous resource instance", which we call an "asynclet".

A normal resource is identified in a parent resource by a href attribute, and other attributes:

[[code]]
    <some-type href="some-URI" ... />
[[/code]]

An asynclet has the href attribute and a second attribute 'async="1"', telling the client that this resource, though it has a URI, does not in fact yet exist:

[[code]]
    <some-type href="some-URI" async="1" />
[[/code]]

When the client retrieves an asynclet, the server waits until a resource of the right type is created, within that parent, and it then responds to the client with the contents of that new resource.

In those cases where asynclets are meaningful, and implemented, the representation for a parent resource will list all existing resources plus a single asynclet:

[[code]]
    <some-type href="some-URI-1" ... />
    <some-type href="some-URI-2" ... />
    <some-type href="some-URI-3" ... />
    <some-type href="some-URI-4" ... />
    <some-type href="some-URI-5" async="1" />
[[/code]]

When the server returns the document for an asynclet, it always defines an attribute "next" which contains the URI of a new asynclet that represents the next resource which will be created.

At any time, of course, a new resource may 'arrive' and the URI held by a client for an asynclet will then refer to a real existing resource.  This is transparent to the client except that there will be no wait when the client issues a GET on that URI.

The asynclet model gives the client full choice between a synchronous polling dialog (in which it would fetch the parent each time), or an event-driven dialog (in which case it would fetch an asynclet each time).

The asynclet design addresses a similar problem as the Comet "When-Modified-After" HTTP extension header does, but without extending the HTTP protocol and allowing clients to wait for specific resources within a parent resource context.

+++ Cacheing

RestMS assumes that all resources may be cached.  We define two types of cache.  First, the "end cache", is held in the browser or HTTP client layer.  Second, the "proxy cache" is a service that sits between the client and the server.

The server can allow, or disallow, both types of cache from holding content.  It does this by adding a "Cache-Control: No-cache" header to the response.

The client can inform the server or proxy cache that it has cacheable content for a resource by specifying either one of, or both of, the If-Modified-Since and If-None-Match header.  Usually, specifying both headers will give best results.

Note that if a proxy cache is enabled, clients will not be guaranteed to receive the freshest version of a resource for a GET method.  There is no mechanism to push resource updates to proxy servers.

+++ Idempotency and side-effects

The GET, PUT, and DELETE methods are idempotent: the client can safely issue these more than once.  The POST method is not idempotent and if issued more than once, will create a corresponding number of new resources.

Idempotency allows the client to safely recover from failures where it did not get a response, yet could not sure the server did not receive the request.  For example, any failure in the network, the client, or an intermediary that happens after the server receives the request but before the client receives the response.  The client recovers by simply reissuing any GET, PUT and DELETE requests that were not completed.

The GET method does not modify the state of any resource on the server.

+++ Pipelining

The client may send requests in parallel, which is called "pipelining".  RFC 2616 section 8.1.2.2 says,

> Clients SHOULD NOT pipeline requests using non-idempotent methods or non-idempotent sequences of methods (see section 9.1.2). Otherwise, a premature termination of the transport connection could lead to indeterminate results. A client wishing to send a non-idempotent request SHOULD wait to send that request until it has received the response status for the previous request.

RestMS clients MAY pipeline GET, PUT and DELETE methods, but SHOULD NOT pipeline POST methods.
