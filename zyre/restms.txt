This document describes RestMS, a RESTful Messaging Service that exposes AMQP networks as a set of resources clearly identified by URIs and each supporting the appropriate HTTP methods.  RestMS is designed to interoperate with AMQP/0.9.1 and future versions of AMQP.

* Name: 7-RESTMS@wiki.amqp.org
* Editor: Pieter Hintjens <ph@imatix.com>
* Contributors: Steve Vinoski <vinoski@ieee.org>
* Resources: http://www.restms.org.

++ License

This document is licensed under the [http://wiki.amqp.org/main:intellectual-property-policy Intellectual Property Policy] of the wiki.amqp.org site.

++ Change Process

This document is governed by the [spec:1|1-COSS@wiki.amqp.org specification].

++ Goals

RestMS aims to:

* Map the AMQP architecture to a set of resources that can be identified by URIs.
* Map the AMQP protocol to a set of methods operating on these URIs.
* Define standard representations for these resources where needed.

And in doing to, hopes to:

* Deliver AMQP-interoperable enterprise messaging to web applications.
* Deliver the scalability and simplicity of the RESTful model.
* Be easy to use in any programming language, for any application, on any platform.
* Define a standardized and implementation-independent URI mapping scheme.

This specification is an initial, simple RESTful mapping of AMQP.  It does not claim to be complete, robust, or fast.  Our intention is to demonstrate that RESTful messaging is feasible today.  We also wish to show that a RESTful messaging model - a set of resources clearly identified with URIs and each supporting the appropriate HTTP methods - can be a constructive input into the design of AMQP/1.0.

++ Language

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

Key words for use in RFCs to Indicate Requirement Levels
http://tools.ietf.org/html/rfc2119

++ Terminolgy

* Resource - a network-addressable data object or service identified by a URI.
* Collection - A Resource that contains a set of Member Resources. Collections are represented as Atom Feeds. See Section 9.
* Workspace - A named group of Collections. See Section 8.1.
* Service Document - A document that describes the location and capabilities of one or more Collections, grouped into Workspaces. See Section 8.
* Category Document - A document that describes the categories allowed in a Collection. See Section 7.


++ Introduction

"All REST interactions are stateless. That is, each request contains all of the information necessary for a connector to understand the request, independent of any requests that may have preceded it." -- [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm Roy Fielding]

RestMS is a RESTful messaging service designed for web applications.  A RestMS application can be as simple as this fully working "Hello World!" example in Perl:

[[code]]
#!/usr/bin/perl
#   Hello World application for RestMS
#
use LWP::UserAgent;
use HTTP::Request::Common;

my $hostname = $ARGV [0]? $ARGV [0]: "localhost";
my $base = "http://$hostname/restms";
my $ua = new LWP::UserAgent;
$ua->agent ('Perl');
$ua->credentials ($hostname, "RestMS", "guest", "guest");

#   In one step, create a pipe named 'world', create a fanout feed named
#   'ping', and create a join on all messages, using address string 'hello':
my $response = $ua->request (PUT "$base/pipe/world/hello\@ping/fanout");
$response->code == 200 || die;

my $response = $ua->request (POST "$base/hello\@ping",
    Content => "Hello World!\n");
$response->code == 200 || die;

#   Message goes into feed and then comes back to our pipe
my $response = $ua->request (GET "$base/pipe/world/");
$response->code == 200 || die;
print $response->content;
[[/code]]


++ Implementation architecture

The RestMS software architecture consists of these components:

* A RestMS //server//, which speaks HTTP or HTTPS at one side, and one or more messaging protocols (such as AMQP) at the other.
* A set of RestMS //client// applications, which use the HTTP protocol to execute RestMS methods, and thus to send and receive messages.
* One or more messaging infrastructures, for example an AMQP server connected to a set of AMQP client applications.  This infrastructure is invisible to the RestMS clients, except insofar as it exists as a sink for and a source of interesting messages.

In this document we provide a formal specification for the syntax and semantics of the HTTP conversation carried out between RestMS clients and the RestMS server, with the goal of explaining to developers how to write RestMS client applications, and to implementors how to build conforming RestMS server implementations.


++ RestMS design overview

RestMS consists of these design aspects, each presented as a section of this specification:

# A generic document syntax.  This section explains how resources are represented as structured documents in both XML and JSON.  While this generic syntax was designed for RestMS, it is reusable in other applications.
# A generic RESTful framework.  This section explains how HTTP methods are used to create, retrieve, modify, and delete server-side resources.  Like the generic document structure, this generic framework is applicable more widely than RestMS.
# The RestMS protocol semantics.  This section explains the specific semantics of RestMS, in terms of the RestMS resources and methods.
# Specifications of the RestMS feed and pipe types.  This section is intended for RestMS users.
# A guide to AMQP interoperability and security.  This section is intended for AMQP implementors who wish to support RestMS in their products.
# A guide to HTTP interoperability and security.


Differences between RestMS and AtomPub
Differences between RestMS and AMQP



-- using RestMS in five minutes
    - examples, minimal rules

++ RestMS is an evolution of AMQP

While RestMS remains interoperable with existing AMQP networks (via AMQP servers that implement the RestMS extension class), it is intended to be both simpler to understand and use, and more in line with the evolution of AMQP towards an AMQP/1.0 specification.

RestMS deliberately invents new nomenclature but for those familiar with AMQP, a feed corresponds to an exchange and/or shared queue, an address corresponds to a routing key, a pipe is analogous to a private queue, and a join matches an AMQP binding.  If it helps to understand RestMS, these are the main shifts that RestMS makes from the AMQP/0.9.1 semantic model:

* Shared queues are merged into exchanges, and the resulting entity is renamed "feed".  In AMQP, exchanges have no state, while shared queues cannot do routing.  In RestMS, feeds have both state and capacity to route messages.
* The exclusive queue concept are renamed to "pipe" and moved closer to the client edge.
* The consumer and transaction concepts are merged, renamed to "nozzle", and moved to the client edge.
* The binding / routing key concepts are merged into a new concept called "address", which is used both for publishing messages and for joining pipes to feeds.

The main semantic change from AMQP to RestMS is that we do not allow loose coupling of shared queues, i.e. the ability to bind and address a shared queue using arbitrary routing keys.  We consider this AMQP functionality to be confusing and not needed by any common messaging scenarios.  In RestMS, shared queues are addressed directly, as named feeds.  This simplification is a key part of RestMS's overall design.



